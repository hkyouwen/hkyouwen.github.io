<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="HK书屋">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HK书屋">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="HH KKs">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>HK书屋</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HK书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/" itemprop="url">Flink的checkpoint生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T10:56:16+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>checkpoint的发起过程，首先在生产jobgraph的过程中会配置Checkpoint。</p>
<p>在StreamingJobGraphGenerator类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">private JobGraph createJobGraph() &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置 checkpoint</span><br><span class="line">   configureCheckpointing();</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">   return jobGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取Checkpoint的所有配置</span><br><span class="line">private void configureCheckpointing() &#123;</span><br><span class="line">		CheckpointConfig cfg &#x3D; streamGraph.getCheckpointConfig();</span><br><span class="line"></span><br><span class="line">		long interval &#x3D; cfg.getCheckpointInterval();</span><br><span class="line">		if (interval &lt; MINIMAL_CHECKPOINT_TIME) &#123;</span><br><span class="line">			&#x2F;&#x2F; interval of max value means disable periodic checkpoint</span><br><span class="line">			interval &#x3D; Long.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure the participating vertices ---</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that receive &quot;trigger checkpoint&quot; messages.</span><br><span class="line">		&#x2F;&#x2F; currently, these are all the sources</span><br><span class="line">		&#x2F;&#x2F; 只包含那些作为 source 的节点</span><br><span class="line">		List&lt;JobVertexID&gt; triggerVertices &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that need to acknowledge the checkpoint</span><br><span class="line">		&#x2F;&#x2F; currently, these are all vertices</span><br><span class="line">		List&lt;JobVertexID&gt; ackVertices &#x3D; new ArrayList&lt;&gt;(jobVertices.size());</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that receive &quot;commit checkpoint&quot; messages</span><br><span class="line">		&#x2F;&#x2F; currently, these are all vertices</span><br><span class="line">		List&lt;JobVertexID&gt; commitVertices &#x3D; new ArrayList&lt;&gt;(jobVertices.size());</span><br><span class="line"></span><br><span class="line">		for (JobVertex vertex : jobVertices.values()) &#123;</span><br><span class="line">			if (vertex.isInputVertex()) &#123;</span><br><span class="line">				triggerVertices.add(vertex.getID());</span><br><span class="line">			&#125;</span><br><span class="line">			commitVertices.add(vertex.getID());</span><br><span class="line">			ackVertices.add(vertex.getID());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure options ---</span><br><span class="line"></span><br><span class="line">		CheckpointRetentionPolicy retentionAfterTermination;</span><br><span class="line">		if (cfg.isExternalizedCheckpointsEnabled()) &#123;</span><br><span class="line">			CheckpointConfig.ExternalizedCheckpointCleanup cleanup &#x3D; cfg.getExternalizedCheckpointCleanup();</span><br><span class="line">			&#x2F;&#x2F; Sanity check</span><br><span class="line">			if (cleanup &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;Externalized checkpoints enabled, but no cleanup mode configured.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			retentionAfterTermination &#x3D; cleanup.deleteOnCancellation() ?</span><br><span class="line">					CheckpointRetentionPolicy.RETAIN_ON_FAILURE :</span><br><span class="line">					CheckpointRetentionPolicy.RETAIN_ON_CANCELLATION;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			retentionAfterTermination &#x3D; CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CheckpointingMode mode &#x3D; cfg.getCheckpointingMode();</span><br><span class="line"></span><br><span class="line">		boolean isExactlyOnce;</span><br><span class="line">		if (mode &#x3D;&#x3D; CheckpointingMode.EXACTLY_ONCE) &#123;</span><br><span class="line">			isExactlyOnce &#x3D; true;</span><br><span class="line">		&#125; else if (mode &#x3D;&#x3D; CheckpointingMode.AT_LEAST_ONCE) &#123;</span><br><span class="line">			isExactlyOnce &#x3D; false;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;Unexpected checkpointing mode. &quot; +</span><br><span class="line">				&quot;Did not expect there to be another checkpointing mode besides &quot; +</span><br><span class="line">				&quot;exactly-once or at-least-once.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure the master-side checkpoint hooks ---</span><br><span class="line"></span><br><span class="line">		final ArrayList&lt;MasterTriggerRestoreHook.Factory&gt; hooks &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		for (StreamNode node : streamGraph.getStreamNodes()) &#123;</span><br><span class="line">			if (node.getOperatorFactory() instanceof UdfStreamOperatorFactory) &#123;</span><br><span class="line">				Function f &#x3D; ((UdfStreamOperatorFactory) node.getOperatorFactory()).getUserFunction();</span><br><span class="line"></span><br><span class="line">				if (f instanceof WithMasterCheckpointHook) &#123;</span><br><span class="line">					hooks.add(new FunctionMasterCheckpointHookFactory((WithMasterCheckpointHook&lt;?&gt;) f));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; because the hooks can have user-defined code, they need to be stored as</span><br><span class="line">		&#x2F;&#x2F; eagerly serialized values</span><br><span class="line">		final SerializedValue&lt;MasterTriggerRestoreHook.Factory[]&gt; serializedHooks;</span><br><span class="line">		if (hooks.isEmpty()) &#123;</span><br><span class="line">			serializedHooks &#x3D; null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				MasterTriggerRestoreHook.Factory[] asArray &#x3D;</span><br><span class="line">						hooks.toArray(new MasterTriggerRestoreHook.Factory[hooks.size()]);</span><br><span class="line">				serializedHooks &#x3D; new SerializedValue&lt;&gt;(asArray);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (IOException e) &#123;</span><br><span class="line">				throw new FlinkRuntimeException(&quot;Trigger&#x2F;restore hook is not serializable&quot;, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; because the state backend can have user-defined code, it needs to be stored as</span><br><span class="line">		&#x2F;&#x2F; eagerly serialized value</span><br><span class="line">		final SerializedValue&lt;StateBackend&gt; serializedStateBackend;</span><br><span class="line">		if (streamGraph.getStateBackend() &#x3D;&#x3D; null) &#123;</span><br><span class="line">			serializedStateBackend &#x3D; null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				serializedStateBackend &#x3D;</span><br><span class="line">					new SerializedValue&lt;StateBackend&gt;(streamGraph.getStateBackend());</span><br><span class="line">			&#125;</span><br><span class="line">			catch (IOException e) &#123;</span><br><span class="line">				throw new FlinkRuntimeException(&quot;State backend is not serializable&quot;, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- done, put it all together ---</span><br><span class="line">       &#x2F;&#x2F;加入jobGraph的配置</span><br><span class="line">		JobCheckpointingSettings settings &#x3D; new JobCheckpointingSettings(</span><br><span class="line">			triggerVertices,</span><br><span class="line">			ackVertices,</span><br><span class="line">			commitVertices,</span><br><span class="line">			new CheckpointCoordinatorConfiguration(</span><br><span class="line">				interval,</span><br><span class="line">				cfg.getCheckpointTimeout(),</span><br><span class="line">				cfg.getMinPauseBetweenCheckpoints(),</span><br><span class="line">				cfg.getMaxConcurrentCheckpoints(),</span><br><span class="line">				retentionAfterTermination,</span><br><span class="line">				isExactlyOnce,</span><br><span class="line">				cfg.isPreferCheckpointForRecovery(),</span><br><span class="line">				cfg.getTolerableCheckpointFailureNumber()),</span><br><span class="line">			serializedStateBackend,</span><br><span class="line">			serializedHooks);</span><br><span class="line"></span><br><span class="line">		jobGraph.setSnapshotSettings(settings);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着jobGraph进入ExecutionGraph的构建过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutionGraph buildGraph(</span><br><span class="line">   @Nullable ExecutionGraph prior,</span><br><span class="line">   JobGraph jobGraph,</span><br><span class="line">   Configuration jobManagerConfig,</span><br><span class="line">   ScheduledExecutorService futureExecutor,</span><br><span class="line">   Executor ioExecutor,</span><br><span class="line">   SlotProvider slotProvider,</span><br><span class="line">   ClassLoader classLoader,</span><br><span class="line">   CheckpointRecoveryFactory recoveryFactory,</span><br><span class="line">   Time rpcTimeout,</span><br><span class="line">   RestartStrategy restartStrategy,</span><br><span class="line">   MetricGroup metrics,</span><br><span class="line">   BlobWriter blobWriter,</span><br><span class="line">   Time allocationTimeout,</span><br><span class="line">   Logger log,</span><br><span class="line">   ShuffleMaster&lt;?&gt; shuffleMaster,</span><br><span class="line">   JobMasterPartitionTracker partitionTracker,</span><br><span class="line">   FailoverStrategy.Factory failoverStrategyFactory) throws JobExecutionException, JobException &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据jobGraph的Checkpoint的配置来配置ExecutionGraph</span><br><span class="line">   &#x2F;&#x2F; configure the state checkpointing</span><br><span class="line">   JobCheckpointingSettings snapshotSettings &#x3D; jobGraph.getCheckpointingSettings();</span><br><span class="line">   if (snapshotSettings !&#x3D; null) &#123;</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; triggerVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToTrigger(), executionGraph);</span><br><span class="line"></span><br><span class="line">      List&lt;ExecutionJobVertex&gt; ackVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToAcknowledge(), executionGraph);</span><br><span class="line"></span><br><span class="line">      List&lt;ExecutionJobVertex&gt; confirmVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToConfirm(), executionGraph);</span><br><span class="line"></span><br><span class="line">      CompletedCheckpointStore completedCheckpoints;</span><br><span class="line">      CheckpointIDCounter checkpointIdCounter;</span><br><span class="line">      try &#123;</span><br><span class="line">         int maxNumberOfCheckpointsToRetain &#x3D; jobManagerConfig.getInteger(</span><br><span class="line">               CheckpointingOptions.MAX_RETAINED_CHECKPOINTS);</span><br><span class="line"></span><br><span class="line">         if (maxNumberOfCheckpointsToRetain &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; warning and use 1 as the default value if the setting in</span><br><span class="line">            &#x2F;&#x2F; state.checkpoints.max-retained-checkpoints is not greater than 0.</span><br><span class="line">            log.warn(&quot;The setting for &#39;&#123;&#125; : &#123;&#125;&#39; is invalid. Using default value of &#123;&#125;&quot;,</span><br><span class="line">                  CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.key(),</span><br><span class="line">                  maxNumberOfCheckpointsToRetain,</span><br><span class="line">                  CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.defaultValue());</span><br><span class="line"></span><br><span class="line">            maxNumberOfCheckpointsToRetain &#x3D; CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.defaultValue();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         completedCheckpoints &#x3D; recoveryFactory.createCheckpointStore(jobId, maxNumberOfCheckpointsToRetain, classLoader);</span><br><span class="line">         checkpointIdCounter &#x3D; recoveryFactory.createCheckpointIDCounter(jobId);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new JobExecutionException(jobId, &quot;Failed to initialize high-availability checkpoint handler&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Maximum number of remembered checkpoints</span><br><span class="line">      </span><br><span class="line">      int historySize &#x3D; jobManagerConfig.getInteger(WebOptions.CHECKPOINTS_HISTORY_SIZE);</span><br><span class="line"></span><br><span class="line">      CheckpointStatsTracker checkpointStatsTracker &#x3D; new CheckpointStatsTracker(</span><br><span class="line">            historySize,</span><br><span class="line">            ackVertices,</span><br><span class="line">            snapshotSettings.getCheckpointCoordinatorConfiguration(),</span><br><span class="line">            metrics);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; load the state backend from the application settings</span><br><span class="line">      final StateBackend applicationConfiguredBackend;</span><br><span class="line">      final SerializedValue&lt;StateBackend&gt; serializedAppConfigured &#x3D; snapshotSettings.getDefaultStateBackend();</span><br><span class="line"></span><br><span class="line">      if (serializedAppConfigured &#x3D;&#x3D; null) &#123;</span><br><span class="line">         applicationConfiguredBackend &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            applicationConfiguredBackend &#x3D; serializedAppConfigured.deserializeValue(classLoader);</span><br><span class="line">         &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new JobExecutionException(jobId,</span><br><span class="line">                  &quot;Could not deserialize application-defined state backend.&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final StateBackend rootBackend;</span><br><span class="line">      try &#123;</span><br><span class="line">         rootBackend &#x3D; StateBackendLoader.fromApplicationOrConfigOrDefault(</span><br><span class="line">               applicationConfiguredBackend, jobManagerConfig, classLoader, log);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (IllegalConfigurationException | IOException | DynamicCodeLoadingException e) &#123;</span><br><span class="line">         throw new JobExecutionException(jobId, &quot;Could not instantiate configured state backend&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; instantiate the user-defined checkpoint hooks</span><br><span class="line">&#x2F;&#x2F;回调用户自己实现的Checkpoint逻辑</span><br><span class="line">      final SerializedValue&lt;MasterTriggerRestoreHook.Factory[]&gt; serializedHooks &#x3D; snapshotSettings.getMasterHooks();</span><br><span class="line">      final List&lt;MasterTriggerRestoreHook&lt;?&gt;&gt; hooks;</span><br><span class="line"></span><br><span class="line">      if (serializedHooks &#x3D;&#x3D; null) &#123;</span><br><span class="line">         hooks &#x3D; Collections.emptyList();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         final MasterTriggerRestoreHook.Factory[] hookFactories;</span><br><span class="line">         try &#123;</span><br><span class="line">            hookFactories &#x3D; serializedHooks.deserializeValue(classLoader);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new JobExecutionException(jobId, &quot;Could not instantiate user-defined checkpoint hooks&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         final Thread thread &#x3D; Thread.currentThread();</span><br><span class="line">         final ClassLoader originalClassLoader &#x3D; thread.getContextClassLoader();</span><br><span class="line">         thread.setContextClassLoader(classLoader);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">            hooks &#x3D; new ArrayList&lt;&gt;(hookFactories.length);</span><br><span class="line">            for (MasterTriggerRestoreHook.Factory factory : hookFactories) &#123;</span><br><span class="line">               hooks.add(MasterHooks.wrapHook(factory.create(), classLoader));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         finally &#123;</span><br><span class="line">            thread.setContextClassLoader(originalClassLoader);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final CheckpointCoordinatorConfiguration chkConfig &#x3D; snapshotSettings.getCheckpointCoordinatorConfiguration();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开启Checkpoint</span><br><span class="line">      executionGraph.enableCheckpointing(</span><br><span class="line">         chkConfig,</span><br><span class="line">         triggerVertices,</span><br><span class="line">         ackVertices,</span><br><span class="line">         confirmVertices,</span><br><span class="line">         hooks,</span><br><span class="line">         checkpointIdCounter,</span><br><span class="line">         completedCheckpoints,</span><br><span class="line">         rootBackend,</span><br><span class="line">         checkpointStatsTracker);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return executionGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executionGraph.enableCheckpointing开启Checkpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public void enableCheckpointing(</span><br><span class="line">      CheckpointCoordinatorConfiguration chkConfig,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToTrigger,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToWaitFor,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToCommitTo,</span><br><span class="line">      List&lt;MasterTriggerRestoreHook&lt;?&gt;&gt; masterHooks,</span><br><span class="line">      CheckpointIDCounter checkpointIDCounter,</span><br><span class="line">      CompletedCheckpointStore checkpointStore,</span><br><span class="line">      StateBackend checkpointStateBackend,</span><br><span class="line">      CheckpointStatsTracker statsTracker) &#123;</span><br><span class="line"></span><br><span class="line">   checkState(state &#x3D;&#x3D; JobStatus.CREATED, &quot;Job must be in CREATED state&quot;);</span><br><span class="line">   checkState(checkpointCoordinator &#x3D;&#x3D; null, &quot;checkpointing already enabled&quot;);</span><br><span class="line"></span><br><span class="line">   ExecutionVertex[] tasksToTrigger &#x3D; collectExecutionVertices(verticesToTrigger);</span><br><span class="line">   ExecutionVertex[] tasksToWaitFor &#x3D; collectExecutionVertices(verticesToWaitFor);</span><br><span class="line">   ExecutionVertex[] tasksToCommitTo &#x3D; collectExecutionVertices(verticesToCommitTo);</span><br><span class="line"></span><br><span class="line">   checkpointStatsTracker &#x3D; checkNotNull(statsTracker, &quot;CheckpointStatsTracker&quot;);</span><br><span class="line"></span><br><span class="line">   CheckpointFailureManager failureManager &#x3D; new CheckpointFailureManager(</span><br><span class="line">      chkConfig.getTolerableCheckpointFailureNumber(),</span><br><span class="line">      new CheckpointFailureManager.FailJobCallback() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void failJob(Throwable cause) &#123;</span><br><span class="line">            getJobMasterMainThreadExecutor().execute(() -&gt; failGlobal(cause));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void failJobDueToTaskFailure(Throwable cause, ExecutionAttemptID failingTask) &#123;</span><br><span class="line">            getJobMasterMainThreadExecutor().execute(() -&gt; failGlobalIfExecutionIsStillRunning(cause, failingTask));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   checkState(checkpointCoordinatorTimer &#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">   checkpointCoordinatorTimer &#x3D; Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">      new DispatcherThreadFactory(</span><br><span class="line">         Thread.currentThread().getThreadGroup(), &quot;Checkpoint Timer&quot;));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create the coordinator that triggers and commits checkpoints and holds the state</span><br><span class="line">   &#x2F;&#x2F;创建 CheckpointCoordinator 对象</span><br><span class="line">   checkpointCoordinator &#x3D; new CheckpointCoordinator(</span><br><span class="line">      jobInformation.getJobId(),</span><br><span class="line">      chkConfig,</span><br><span class="line">      tasksToTrigger,</span><br><span class="line">      tasksToWaitFor,</span><br><span class="line">      tasksToCommitTo,</span><br><span class="line">      checkpointIDCounter,</span><br><span class="line">      checkpointStore,</span><br><span class="line">      checkpointStateBackend,</span><br><span class="line">      ioExecutor,</span><br><span class="line">      new ScheduledExecutorServiceAdapter(checkpointCoordinatorTimer),</span><br><span class="line">      SharedStateRegistry.DEFAULT_FACTORY,</span><br><span class="line">      failureManager);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; register the master hooks on the checkpoint coordinator</span><br><span class="line">   for (MasterTriggerRestoreHook&lt;?&gt; hook : masterHooks) &#123;</span><br><span class="line">      if (!checkpointCoordinator.addMasterHook(hook)) &#123;</span><br><span class="line">         LOG.warn(&quot;Trying to register multiple checkpoint hooks with the name: &#123;&#125;&quot;, hook.getIdentifier());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   checkpointCoordinator.setCheckpointStatsTracker(checkpointStatsTracker);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; interval of max long value indicates disable periodic checkpoint,</span><br><span class="line">   &#x2F;&#x2F; the CheckpointActivatorDeactivator should be created only if the interval is not max value</span><br><span class="line">   if (chkConfig.getCheckpointInterval() !&#x3D; Long.MAX_VALUE) &#123;</span><br><span class="line">      &#x2F;&#x2F; the periodic checkpoint scheduler is activated and deactivated as a result of</span><br><span class="line">      &#x2F;&#x2F; job status changes (running -&gt; on, all other states -&gt; off)</span><br><span class="line">      &#x2F;&#x2F;注册一个作业状态的监听 CheckpointCoordinatorDeActivator</span><br><span class="line">      registerJobStatusListener(checkpointCoordinator.createActivatorDeactivator());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.stateBackendName &#x3D; checkpointStateBackend.getClass().getSimpleName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinatorDeActivator实现JobStatusListener接口，当Job状态变为 RUNNING 时，通过startCheckpointScheduler启动 checkpoint 的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CheckpointCoordinatorDeActivator implements JobStatusListener &#123;</span><br><span class="line"></span><br><span class="line">   private final CheckpointCoordinator coordinator;</span><br><span class="line"></span><br><span class="line">   public CheckpointCoordinatorDeActivator(CheckpointCoordinator coordinator) &#123;</span><br><span class="line">      this.coordinator &#x3D; checkNotNull(coordinator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void jobStatusChanges(JobID jobId, JobStatus newJobStatus, long timestamp, Throwable error) &#123;</span><br><span class="line">      if (newJobStatus &#x3D;&#x3D; JobStatus.RUNNING) &#123;</span><br><span class="line">         &#x2F;&#x2F; start the checkpoint scheduler</span><br><span class="line">         coordinator.startCheckpointScheduler();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; anything else should stop the trigger for now</span><br><span class="line">         coordinator.stopCheckpointScheduler();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void startCheckpointScheduler() &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Checkpoint coordinator is shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure all prior timers are cancelled</span><br><span class="line">      stopCheckpointScheduler();</span><br><span class="line"></span><br><span class="line">      periodicScheduling &#x3D; true;</span><br><span class="line">      currentPeriodicTrigger &#x3D; scheduleTriggerWithDelay(getRandomInitDelay());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开启定时任务，baseInterval从配置文件getCheckpointInterval获取</span><br><span class="line">private ScheduledFuture&lt;?&gt; scheduleTriggerWithDelay(long initDelay) &#123;</span><br><span class="line">		return timer.scheduleAtFixedRate(</span><br><span class="line">			new ScheduledTrigger(),</span><br><span class="line">			initDelay, baseInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务的内容就是ScheduledTrigger类 的triggerCheckpoint，包括以下几个步骤：</p>
<ul>
<li>检查是否可以触发 checkpoint，包括是否需要强制进行 checkpoint，当前正在排队的并发 checkpoint 的数目是否超过阈值，距离上一次成功 checkpoint 的间隔时间是否过小等，如果这些条件不满足，则当前检查点的触发请求不会执行</li>
<li>检查是否所有需要触发 checkpoint 的 Execution 都是 <code>RUNNING</code> 状态</li>
<li>生成此次 checkpoint 的 checkpointID（id 是严格自增的），并初始化 <code>CheckpointStorageLocation</code>，<code>CheckpointStorageLocation</code> 是此次 checkpoint 存储位置的抽象，通过 <code>CheckpointStorage.initializeLocationForCheckpoint()</code> 创建（<code>CheckpointStorage</code> 目前有两个具体实现，分别为 <code>FsCheckpointStorage</code> 和 <code>MemoryBackendCheckpointStorage</code>），<code>CheckpointStorage</code> 则是从 <code>StateBackend</code> 中创建</li>
<li>生成 <code>PendingCheckpoint</code>，这表示一个处于中间状态的 checkpoint，并保存在 <code>checkpointId -&gt; PendingCheckpoint</code> 这样的映射关系中</li>
<li>注册一个调度任务，在 checkpoint 超时后取消此次 checkpoint，并重新触发一次新的 checkpoint</li>
<li>调用 <code>Execution.triggerCheckpoint()</code> 方法向所有需要 trigger 的 task 发起 checkpoint 请求</li>
</ul>
<p>savepoint 和 checkpoint 的处理逻辑基本一致，只是 savepoint 是强制触发的，需要调用 <code>Execution.triggerSynchronousSavepoint()</code> 进行触发。</p>
<p>在CheckpointCoordinator 内部也有三个列表：</p>
<ul>
<li><code>ExecutionVertex[] tasksToTrigger</code>;</li>
<li><code>ExecutionVertex[] tasksToWaitFor</code>;</li>
<li><code>ExecutionVertex[] tasksToCommitTo</code>;</li>
</ul>
<p>这就对应了前面 <code>JobGraph</code> 中的三个列表，在触发 checkpoint 的时候，只有作为 source 的 Execution 会调用 <code>Execution.triggerCheckpoint()</code> 方法。会通过 RPC 调用通知对应的 <code>RpcTaskManagerGateway</code> 调用 <code>triggerCheckpoint</code>。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">private final class ScheduledTrigger implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         triggerCheckpoint(System.currentTimeMillis(), true);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         LOG.error(&quot;Exception while triggering checkpoint for job &#123;&#125;.&quot;, job, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CompletableFuture&lt;CompletedCheckpoint&gt; triggerCheckpoint(long timestamp, boolean isPeriodic) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;进入triggerCheckpoint</span><br><span class="line">			return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic, false);</span><br><span class="line">		&#125; catch (CheckpointException e) &#123;</span><br><span class="line">			long latestGeneratedCheckpointId &#x3D; getCheckpointIdCounter().get();</span><br><span class="line">			&#x2F;&#x2F; here we can not get the failed pending checkpoint&#39;s id,</span><br><span class="line">			&#x2F;&#x2F; so we pass the negative latest generated checkpoint id as a special flag</span><br><span class="line">			failureManager.handleJobLevelCheckpointException(e, -1 * latestGeneratedCheckpointId);</span><br><span class="line">			return FutureUtils.completedExceptionally(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@VisibleForTesting</span><br><span class="line">	public CompletableFuture&lt;CompletedCheckpoint&gt; triggerCheckpoint(</span><br><span class="line">			long timestamp,</span><br><span class="line">			CheckpointProperties props,</span><br><span class="line">			@Nullable String externalSavepointLocation,</span><br><span class="line">			boolean isPeriodic,</span><br><span class="line">			boolean advanceToEndOfTime) throws CheckpointException &#123;</span><br><span class="line"></span><br><span class="line">		if (advanceToEndOfTime &amp;&amp; !(props.isSynchronous() &amp;&amp; props.isSavepoint())) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; make some eager pre-checks</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">		&#x2F;&#x2F;检查是否可以触发 checkpoint</span><br><span class="line">			preCheckBeforeTriggeringCheckpoint(isPeriodic, props.forceCheckpoint());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; check if all tasks that we need to trigger are running.</span><br><span class="line">		&#x2F;&#x2F; if not, abort the checkpoint</span><br><span class="line">		&#x2F;&#x2F;检查是否所有需要触发 checkpoint 的 Execution 都是 RUNNING 状态</span><br><span class="line">		Execution[] executions &#x3D; new Execution[tasksToTrigger.length];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; tasksToTrigger.length; i++) &#123;</span><br><span class="line">			Execution ee &#x3D; tasksToTrigger[i].getCurrentExecutionAttempt();</span><br><span class="line">			if (ee &#x3D;&#x3D; null) &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not being executed at the moment. Aborting checkpoint.&quot;,</span><br><span class="line">						tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job);</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125; else if (ee.getState() &#x3D;&#x3D; ExecutionState.RUNNING) &#123;</span><br><span class="line">				executions[i] &#x3D; ee;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not in state &#123;&#125; but &#123;&#125; instead. Aborting checkpoint.&quot;,</span><br><span class="line">						tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job,</span><br><span class="line">						ExecutionState.RUNNING,</span><br><span class="line">						ee.getState());</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; next, check if all tasks that need to acknowledge the checkpoint are running.</span><br><span class="line">		&#x2F;&#x2F; if not, abort the checkpoint</span><br><span class="line">		Map&lt;ExecutionAttemptID, ExecutionVertex&gt; ackTasks &#x3D; new HashMap&lt;&gt;(tasksToWaitFor.length);</span><br><span class="line"></span><br><span class="line">		for (ExecutionVertex ev : tasksToWaitFor) &#123;</span><br><span class="line">			Execution ee &#x3D; ev.getCurrentExecutionAttempt();</span><br><span class="line">			if (ee !&#x3D; null) &#123;</span><br><span class="line">				ackTasks.put(ee.getAttemptId(), ev);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint acknowledging task &#123;&#125; of job &#123;&#125; is not being executed at the moment. Aborting checkpoint.&quot;,</span><br><span class="line">						ev.getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job);</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; we will actually trigger this checkpoint!</span><br><span class="line"></span><br><span class="line">		final CheckpointStorageLocation checkpointStorageLocation;</span><br><span class="line">		final long checkpointID;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; this must happen outside the coordinator-wide lock, because it communicates</span><br><span class="line">			&#x2F;&#x2F; with external services (in HA mode) and may block for a while.</span><br><span class="line">			&#x2F;&#x2F;checkpointID用CAS递增</span><br><span class="line">			checkpointID &#x3D; checkpointIdCounter.getAndIncrement();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;初始化checkpoint存储位置</span><br><span class="line">			checkpointStorageLocation &#x3D; props.isSavepoint() ?</span><br><span class="line">					checkpointStorage.initializeLocationForSavepoint(checkpointID, externalSavepointLocation) :</span><br><span class="line">					checkpointStorage.initializeLocationForCheckpoint(checkpointID);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable t) &#123;</span><br><span class="line">			int numUnsuccessful &#x3D; numUnsuccessfulCheckpointsTriggers.incrementAndGet();</span><br><span class="line">			LOG.warn(&quot;Failed to trigger checkpoint for job &#123;&#125; (&#123;&#125; consecutive failed attempts so far).&quot;,</span><br><span class="line">					job,</span><br><span class="line">					numUnsuccessful,</span><br><span class="line">					t);</span><br><span class="line">			throw new CheckpointException(CheckpointFailureReason.EXCEPTION, t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化PendingCheckpoint，中间状态的checkpoint</span><br><span class="line">		final PendingCheckpoint checkpoint &#x3D; new PendingCheckpoint(</span><br><span class="line">			job,</span><br><span class="line">			checkpointID,</span><br><span class="line">			timestamp,</span><br><span class="line">			ackTasks,</span><br><span class="line">			masterHooks.keySet(),</span><br><span class="line">			props,</span><br><span class="line">			checkpointStorageLocation,</span><br><span class="line">			executor);</span><br><span class="line"></span><br><span class="line">		if (statsTracker !&#x3D; null) &#123;</span><br><span class="line">			PendingCheckpointStats callback &#x3D; statsTracker.reportPendingCheckpoint(</span><br><span class="line">				checkpointID,</span><br><span class="line">				timestamp,</span><br><span class="line">				props);</span><br><span class="line"></span><br><span class="line">			checkpoint.setStatsCallback(callback);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;定时清除已过期的checkpoints</span><br><span class="line">		&#x2F;&#x2F; schedule the timer that will clean up the expired checkpoints</span><br><span class="line">		final Runnable canceller &#x3D; () -&gt; &#123;</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">				&#x2F;&#x2F; only do the work if the checkpoint is not discarded anyways</span><br><span class="line">				&#x2F;&#x2F; note that checkpoint completion discards the pending checkpoint object</span><br><span class="line">				if (!checkpoint.isDiscarded()) &#123;</span><br><span class="line">					LOG.info(&quot;Checkpoint &#123;&#125; of job &#123;&#125; expired before completing.&quot;, checkpointID, job);</span><br><span class="line"></span><br><span class="line">					failPendingCheckpoint(checkpoint, CheckpointFailureReason.CHECKPOINT_EXPIRED);</span><br><span class="line">					pendingCheckpoints.remove(checkpointID);</span><br><span class="line">					rememberRecentCheckpointId(checkpointID);</span><br><span class="line"></span><br><span class="line">					triggerQueuedRequests();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; re-acquire the coordinator-wide lock</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">			&#x2F;&#x2F;二次检查</span><br><span class="line">				preCheckBeforeTriggeringCheckpoint(isPeriodic, props.forceCheckpoint());</span><br><span class="line"></span><br><span class="line">				LOG.info(&quot;Triggering checkpoint &#123;&#125; @ &#123;&#125; for job &#123;&#125;.&quot;, checkpointID, timestamp, job);</span><br><span class="line"></span><br><span class="line">				pendingCheckpoints.put(checkpointID, checkpoint);</span><br><span class="line"></span><br><span class="line">				ScheduledFuture&lt;?&gt; cancellerHandle &#x3D; timer.schedule(</span><br><span class="line">						canceller,</span><br><span class="line">						checkpointTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">				if (!checkpoint.setCancellerHandle(cancellerHandle)) &#123;</span><br><span class="line">					&#x2F;&#x2F; checkpoint is already disposed!</span><br><span class="line">					cancellerHandle.cancel(false);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; TODO, asynchronously snapshots master hook without waiting here</span><br><span class="line">				&#x2F;&#x2F;回调用户函数</span><br><span class="line">				for (MasterTriggerRestoreHook&lt;?&gt; masterHook : masterHooks.values()) &#123;</span><br><span class="line">					final MasterState masterState &#x3D;</span><br><span class="line">						MasterHooks.triggerHook(masterHook, checkpointID, timestamp, executor)</span><br><span class="line">							.get(checkpointTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">					checkpoint.acknowledgeMasterState(masterHook.getIdentifier(), masterState);</span><br><span class="line">				&#125;</span><br><span class="line">				Preconditions.checkState(checkpoint.areMasterStatesFullyAcknowledged());</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; end of lock scope</span><br><span class="line"></span><br><span class="line">			final CheckpointOptions checkpointOptions &#x3D; new CheckpointOptions(</span><br><span class="line">					props.getCheckpointType(),</span><br><span class="line">					checkpointStorageLocation.getLocationReference());</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; send the messages to the tasks that trigger their checkpoint</span><br><span class="line">			&#x2F;&#x2F;触发tasksToTrigger的task发出checkpoint</span><br><span class="line">			for (Execution execution: executions) &#123;</span><br><span class="line">				if (props.isSynchronous()) &#123;</span><br><span class="line">					execution.triggerSynchronousSavepoint(checkpointID, timestamp, checkpointOptions, advanceToEndOfTime);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			numUnsuccessfulCheckpointsTriggers.set(0);</span><br><span class="line">			return checkpoint.getCompletionFuture();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable t) &#123;</span><br><span class="line">			&#x2F;&#x2F; guard the map against concurrent modifications</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">				pendingCheckpoints.remove(checkpointID);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int numUnsuccessful &#x3D; numUnsuccessfulCheckpointsTriggers.incrementAndGet();</span><br><span class="line">			LOG.warn(&quot;Failed to trigger checkpoint &#123;&#125; for job &#123;&#125;. (&#123;&#125; consecutive failed attempts so far)&quot;,</span><br><span class="line">					checkpointID, job, numUnsuccessful, t);</span><br><span class="line"></span><br><span class="line">			if (!checkpoint.isDiscarded()) &#123;</span><br><span class="line">				failPendingCheckpoint(checkpoint, CheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE, t);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				checkpointStorageLocation.disposeOnFailure();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable t2) &#123;</span><br><span class="line">				LOG.warn(&quot;Cannot dispose failed checkpoint storage location &#123;&#125;&quot;, checkpointStorageLocation, t2);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; rethrow the CheckpointException directly.</span><br><span class="line">			if (t instanceof CheckpointException) &#123;</span><br><span class="line">				throw (CheckpointException) t;</span><br><span class="line">			&#125;</span><br><span class="line">			throw new CheckpointException(CheckpointFailureReason.EXCEPTION, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>tasksToTrigger的task的触发Checkpoint，调用Execution的triggerCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) &#123;</span><br><span class="line">   triggerCheckpointHelper(checkpointId, timestamp, checkpointOptions, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void triggerCheckpointHelper(long checkpointId, long timestamp, CheckpointOptions checkpointOptions, boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">		final CheckpointType checkpointType &#x3D; checkpointOptions.getCheckpointType();</span><br><span class="line">		if (advanceToEndOfEventTime &amp;&amp; !(checkpointType.isSynchronous() &amp;&amp; checkpointType.isSavepoint())) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		final LogicalSlot slot &#x3D; assignedResource;</span><br><span class="line"></span><br><span class="line">		if (slot !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;通过slot资源信息获取TaskManagerGateway并发送triggerCheckpoint请求</span><br><span class="line">			final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			LOG.debug(&quot;The execution has no slot assigned. This indicates that the execution is no longer running.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>TaskManagerGateway转发TaskExecutorGateway，调用Gateway的triggerCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; triggerCheckpoint(</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long checkpointTimestamp,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      boolean advanceToEndOfEventTime) &#123;</span><br><span class="line">   log.debug(&quot;Trigger checkpoint &#123;&#125;@&#123;&#125; for &#123;&#125;.&quot;, checkpointId, checkpointTimestamp, executionAttemptID);</span><br><span class="line"></span><br><span class="line">   final CheckpointType checkpointType &#x3D; checkpointOptions.getCheckpointType();</span><br><span class="line">   if (advanceToEndOfEventTime &amp;&amp; !(checkpointType.isSynchronous() &amp;&amp; checkpointType.isSavepoint())) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为一个 TaskExecutor 中可能有多个 Task 正在运行，所以获取executionAttemptID对应的task</span><br><span class="line">   final Task task &#x3D; taskSlotTable.getTask(executionAttemptID);</span><br><span class="line"></span><br><span class="line">   if (task !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;task发出CheckpointBarrier</span><br><span class="line">      task.triggerCheckpointBarrier(checkpointId, checkpointTimestamp, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line"></span><br><span class="line">      return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final String message &#x3D; &quot;TaskManager received a checkpoint request for unknown task &quot; + executionAttemptID + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">      log.debug(message);</span><br><span class="line">      return FutureUtils.completedExceptionally(new CheckpointException(message, CheckpointFailureReason.TASK_CHECKPOINT_FAILURE));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task发出CheckpointBarrier，只有作为 source 的 Task 才会触发 <code>triggerCheckpointBarrier()</code> 方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpointBarrier(</span><br><span class="line">			final long checkpointID,</span><br><span class="line">			final long checkpointTimestamp,</span><br><span class="line">			final CheckpointOptions checkpointOptions,</span><br><span class="line">			final boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">		final AbstractInvokable invokable &#x3D; this.invokable;</span><br><span class="line">		final CheckpointMetaData checkpointMetaData &#x3D; new CheckpointMetaData(checkpointID, checkpointTimestamp);</span><br><span class="line"></span><br><span class="line">		if (executionState &#x3D;&#x3D; ExecutionState.RUNNING &amp;&amp; invokable !&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">			&#x2F;&#x2F;异步执行triggerCheckpoint</span><br><span class="line">				invokable.triggerCheckpointAsync(checkpointMetaData, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RejectedExecutionException ex) &#123;</span><br><span class="line">				&#x2F;&#x2F; This may happen if the mailbox is closed. It means that the task is shutting down, so we just ignore it.</span><br><span class="line">				LOG.debug(</span><br><span class="line">					&quot;Triggering checkpoint &#123;&#125; for &#123;&#125; (&#123;&#125;) was rejected by the mailbox&quot;,</span><br><span class="line">					checkpointID, taskNameWithSubtask, executionId);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable t) &#123;</span><br><span class="line">				if (getExecutionState() &#x3D;&#x3D; ExecutionState.RUNNING) &#123;</span><br><span class="line">					failExternally(new Exception(</span><br><span class="line">						&quot;Error while triggering checkpoint &quot; + checkpointID + &quot; for &quot; +</span><br><span class="line">							taskNameWithSubtask, t));</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					LOG.debug(&quot;Encountered error while triggering checkpoint &#123;&#125; for &quot; +</span><br><span class="line">						&quot;&#123;&#125; (&#123;&#125;) while being not in state running.&quot;, checkpointID,</span><br><span class="line">						taskNameWithSubtask, executionId, t);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			LOG.debug(&quot;Declining checkpoint request for non-running task &#123;&#125; (&#123;&#125;).&quot;, taskNameWithSubtask, executionId);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; send back a message that we did not do the checkpoint</span><br><span class="line">			checkpointResponder.declineCheckpoint(jobId, executionId, checkpointID,</span><br><span class="line">					new CheckpointException(&quot;Task name with subtask : &quot; + taskNameWithSubtask, CheckpointFailureReason.CHECKPOINT_DECLINED_TASK_NOT_READY));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>执行AbstractInvokable的triggerCheckpointAsync，最终调用StreamTask的triggerCheckpointAsync，triggerCheckpointAsync向mailboxProcessor发送triggerCheckpoint的事件，从而实现异步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;Boolean&gt; triggerCheckpointAsync(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">   return mailboxProcessor.getMainMailboxExecutor().submit(</span><br><span class="line">         () -&gt; triggerCheckpoint(checkpointMetaData, checkpointOptions, advanceToEndOfEventTime),</span><br><span class="line">         &quot;checkpoint %s with %s&quot;,</span><br><span class="line">      checkpointMetaData,</span><br><span class="line">      checkpointOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private boolean triggerCheckpoint(</span><br><span class="line">			CheckpointMetaData checkpointMetaData,</span><br><span class="line">			CheckpointOptions checkpointOptions,</span><br><span class="line">			boolean advanceToEndOfEventTime) throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; No alignment if we inject a checkpoint</span><br><span class="line">			CheckpointMetrics checkpointMetrics &#x3D; new CheckpointMetrics()</span><br><span class="line">				.setBytesBufferedInAlignment(0L)</span><br><span class="line">				.setAlignmentDurationNanos(0L);</span><br><span class="line"></span><br><span class="line">			boolean success &#x3D; performCheckpoint(checkpointMetaData, checkpointOptions, checkpointMetrics, advanceToEndOfEventTime);</span><br><span class="line">			if (!success) &#123;</span><br><span class="line">				declineCheckpoint(checkpointMetaData.getCheckpointId());</span><br><span class="line">			&#125;</span><br><span class="line">			return success;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private boolean performCheckpoint(</span><br><span class="line">			CheckpointMetaData checkpointMetaData,</span><br><span class="line">			CheckpointOptions checkpointOptions,</span><br><span class="line">			CheckpointMetrics checkpointMetrics,</span><br><span class="line">			boolean advanceToEndOfTime) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		LOG.debug(&quot;Starting checkpoint (&#123;&#125;) &#123;&#125; on task &#123;&#125;&quot;,</span><br><span class="line">			checkpointMetaData.getCheckpointId(), checkpointOptions.getCheckpointType(), getName());</span><br><span class="line"></span><br><span class="line">		final long checkpointId &#x3D; checkpointMetaData.getCheckpointId();</span><br><span class="line"></span><br><span class="line">		if (isRunning) &#123;</span><br><span class="line">			actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">				if (checkpointOptions.getCheckpointType().isSynchronous()) &#123;</span><br><span class="line">					setSynchronousSavepointId(checkpointId);</span><br><span class="line"></span><br><span class="line">					if (advanceToEndOfTime) &#123;</span><br><span class="line">						advanceToEndOfEventTime();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; All of the following steps happen as an atomic step from the perspective of barriers and</span><br><span class="line">				&#x2F;&#x2F; records&#x2F;watermarks&#x2F;timers&#x2F;callbacks.</span><br><span class="line">				&#x2F;&#x2F; We generally try to emit the checkpoint barrier as soon as possible to not affect downstream</span><br><span class="line">				&#x2F;&#x2F; checkpoint alignments</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (1): Prepare the checkpoint, allow operators to do some pre-barrier work.</span><br><span class="line">				&#x2F;&#x2F;           The pre-barrier work should be nothing or minimal in the common case.</span><br><span class="line">				&#x2F;&#x2F;准备发送Barrier</span><br><span class="line">				operatorChain.prepareSnapshotPreBarrier(checkpointId);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (2): Send the checkpoint barrier downstream</span><br><span class="line">				&#x2F;&#x2F;向下游发送 barrier</span><br><span class="line">				operatorChain.broadcastCheckpointBarrier(</span><br><span class="line">						checkpointId,</span><br><span class="line">						checkpointMetaData.getTimestamp(),</span><br><span class="line">						checkpointOptions);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (3): Take the state snapshot. This should be largely asynchronous, to not</span><br><span class="line">				&#x2F;&#x2F;           impact progress of the streaming topology</span><br><span class="line">				&#x2F;&#x2F;存储检查点快照</span><br><span class="line">				checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">				&#x2F;&#x2F; we cannot perform our checkpoint - let the downstream operators know that they</span><br><span class="line">				&#x2F;&#x2F; should not wait for any input from this operator</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; we cannot broadcast the cancellation markers on the &#39;operator chain&#39;, because it may not</span><br><span class="line">				&#x2F;&#x2F; yet be created</span><br><span class="line">				final CancelCheckpointMarker message &#x3D; new CancelCheckpointMarker(checkpointMetaData.getCheckpointId());</span><br><span class="line">				recordWriter.broadcastEvent(message);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>OperatorChain类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void prepareSnapshotPreBarrier(long checkpointId) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; go forward through the operator chain and tell each operator</span><br><span class="line">   &#x2F;&#x2F; to prepare the checkpoint</span><br><span class="line">   final StreamOperator&lt;?&gt;[] operators &#x3D; this.allOperators;</span><br><span class="line">   for (int i &#x3D; operators.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">      final StreamOperator&lt;?&gt; op &#x3D; operators[i];</span><br><span class="line">      if (op !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;用户函数实现</span><br><span class="line">         op.prepareSnapshotPreBarrier(checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void broadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个 CheckpointBarrier</span><br><span class="line">		CheckpointBarrier barrier &#x3D; new CheckpointBarrier(id, timestamp, checkpointOptions);</span><br><span class="line">		for (RecordWriterOutput&lt;?&gt; streamOutput : streamOutputs) &#123;</span><br><span class="line">		&#x2F;&#x2F;向所有的下游发送</span><br><span class="line">			streamOutput.broadcastEvent(barrier);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">RecordWriterOutput:</span><br><span class="line">public void broadcastEvent(AbstractEvent event) throws IOException &#123;</span><br><span class="line">		recordWriter.broadcastEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">RecordWriter:</span><br><span class="line">&#x2F;&#x2F;barrier被发送至ResultPartition</span><br><span class="line">public void broadcastEvent(AbstractEvent event) throws IOException &#123;</span><br><span class="line">		try (BufferConsumer eventBufferConsumer &#x3D; EventSerializer.toBufferConsumer(event)) &#123;</span><br><span class="line">			for (int targetChannel &#x3D; 0; targetChannel &lt; numberOfChannels; targetChannel++) &#123;</span><br><span class="line">				tryFinishCurrentBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Retain the buffer so that it can be recycled by each channel of targetPartition</span><br><span class="line">				targetPartition.addBufferConsumer(eventBufferConsumer.copy(), targetChannel);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (flushAlways) &#123;</span><br><span class="line">				flushAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道，每一个 Task 的通过 <code>InputGate</code> 消费上游 Task 产生的数据，而实际上在 <code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 中会创建 <code>CheckpointBarrierHandler</code>, <code>CheckpointBarrierHandler</code> 有两个具体的实现，即 CheckpointBarrierTracker和 CheckpointBarrierAligner，分别对应 AT_LEAST_ONCE 和 EXACTLY_ONCE 这两种模式。</p>
<p><code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 循环调用 <code>CheckpointBarrierHandler.getNextNonBlocked()</code> 获取新数据，因而在 <code>CheckpointBarrierHandler</code> 获得 <code>CheckpointBarrier</code> 后可以及时地进行 checkpoint 相关的操作。</p>
<p>回顾OneInputStreamTask的初始化过程，会创建CheckpointedInputGate用来接收Checkpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws Exception &#123;</span><br><span class="line">   StreamConfig configuration &#x3D; getConfiguration();</span><br><span class="line">   int numberOfInputs &#x3D; configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">   if (numberOfInputs &gt; 0) &#123;</span><br><span class="line">      CheckpointedInputGate inputGate &#x3D; createCheckpointedInputGate();</span><br><span class="line">      TaskIOMetricGroup taskIOMetricGroup &#x3D; getEnvironment().getMetricGroup().getIOMetricGroup();</span><br><span class="line">      taskIOMetricGroup.gauge(&quot;checkpointAlignmentTime&quot;, inputGate::getAlignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">      DataOutput&lt;IN&gt; output &#x3D; createDataOutput();</span><br><span class="line">      StreamTaskInput&lt;IN&gt; input &#x3D; createTaskInput(inputGate, output);</span><br><span class="line">      inputProcessor &#x3D; new StreamOneInputProcessor&lt;&gt;(</span><br><span class="line">         input,</span><br><span class="line">         output,</span><br><span class="line">         getCheckpointLock(),</span><br><span class="line">         operatorChain);</span><br><span class="line">   &#125;</span><br><span class="line">   headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge);</span><br><span class="line">   &#x2F;&#x2F; wrap watermark gauge since registered metrics must be unique</span><br><span class="line">   getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge::getValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CheckpointedInputGate，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private CheckpointedInputGate createCheckpointedInputGate() throws IOException &#123;</span><br><span class="line">   InputGate[] inputGates &#x3D; getEnvironment().getAllInputGates();</span><br><span class="line">   InputGate inputGate &#x3D; InputGateUtil.createInputGate(inputGates);</span><br><span class="line"></span><br><span class="line">   return InputProcessorUtil.createCheckpointedInputGate(</span><br><span class="line">      this,</span><br><span class="line">      configuration.getCheckpointMode(),</span><br><span class="line">      getEnvironment().getIOManager(),</span><br><span class="line">      inputGate,</span><br><span class="line">      getEnvironment().getTaskManagerInfo().getConfiguration(),</span><br><span class="line">      getTaskNameWithSubtaskAndId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputProcessorUtil.createCheckpointedInputGate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class InputProcessorUtil &#123;</span><br><span class="line"></span><br><span class="line">   public static CheckpointedInputGate createCheckpointedInputGate(</span><br><span class="line">         AbstractInvokable toNotifyOnCheckpoint,</span><br><span class="line">         CheckpointingMode checkpointMode,</span><br><span class="line">         IOManager ioManager,</span><br><span class="line">         InputGate inputGate,</span><br><span class="line">         Configuration taskManagerConfig,</span><br><span class="line">         String taskName) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      int pageSize &#x3D; ConfigurationParserUtils.getPageSize(taskManagerConfig);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建用于barrier对齐的数据缓存</span><br><span class="line">      BufferStorage bufferStorage &#x3D; createBufferStorage(</span><br><span class="line">         checkpointMode, ioManager, pageSize, taskManagerConfig, taskName);</span><br><span class="line">         &#x2F;&#x2F;创建CheckpointBarrierHandler</span><br><span class="line">      CheckpointBarrierHandler barrierHandler &#x3D; createCheckpointBarrierHandler(</span><br><span class="line">         checkpointMode, inputGate.getNumberOfInputChannels(), taskName, toNotifyOnCheckpoint);</span><br><span class="line">      return new CheckpointedInputGate(inputGate, bufferStorage, barrierHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>EXACTLY_ONCE才需要BufferStorage，AT_LEAST_ONCE不需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static BufferStorage createBufferStorage(</span><br><span class="line">      CheckpointingMode checkpointMode,</span><br><span class="line">      IOManager ioManager,</span><br><span class="line">      int pageSize,</span><br><span class="line">      Configuration taskManagerConfig,</span><br><span class="line">      String taskName) &#123;</span><br><span class="line">   switch (checkpointMode) &#123;</span><br><span class="line">      case EXACTLY_ONCE: &#123;</span><br><span class="line">         long maxAlign &#x3D; taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);</span><br><span class="line">         if (!(maxAlign &#x3D;&#x3D; -1 || maxAlign &gt; 0)) &#123;</span><br><span class="line">            throw new IllegalConfigurationException(</span><br><span class="line">               TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()</span><br><span class="line">                  + &quot; must be positive or -1 (infinite)&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         return new CachedBufferStorage(pageSize, maxAlign, taskName);</span><br><span class="line">      &#125;</span><br><span class="line">      case AT_LEAST_ONCE:</span><br><span class="line">         return new EmptyBufferStorage();</span><br><span class="line">      default:</span><br><span class="line">         throw new UnsupportedOperationException(&quot;Unrecognized Checkpointing Mode: &quot; + checkpointMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EXACTLY_ONCE创建CheckpointBarrierAligner，AT_LEAST_ONCE创建CheckpointBarrierTracker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static CheckpointBarrierHandler createCheckpointBarrierHandler(</span><br><span class="line">      CheckpointingMode checkpointMode,</span><br><span class="line">      int numberOfInputChannels,</span><br><span class="line">      String taskName,</span><br><span class="line">      AbstractInvokable toNotifyOnCheckpoint) &#123;</span><br><span class="line">   switch (checkpointMode) &#123;</span><br><span class="line">      case EXACTLY_ONCE:</span><br><span class="line">         return new CheckpointBarrierAligner(</span><br><span class="line">            numberOfInputChannels,</span><br><span class="line">            taskName,</span><br><span class="line">            toNotifyOnCheckpoint);</span><br><span class="line">      case AT_LEAST_ONCE:</span><br><span class="line">         return new CheckpointBarrierTracker(numberOfInputChannels, toNotifyOnCheckpoint);</span><br><span class="line">      default:</span><br><span class="line">         throw new UnsupportedOperationException(&quot;Unrecognized Checkpointing Mode: &quot; + checkpointMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>StreamTwoInputProcessor</code> 的执行阶段会调用checkpointedInputGate.pollNext()循环获取事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public InputStatus processInput() throws Exception &#123;</span><br><span class="line">   InputStatus status &#x3D; input.emitNext(output);</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">   return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public InputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">			Optional&lt;BufferOrEvent&gt; bufferOrEvent &#x3D; checkpointedInputGate.pollNext();</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>pollNext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;BufferOrEvent&gt; pollNext() throws Exception &#123;</span><br><span class="line">   while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; process buffered BufferOrEvents before grabbing new ones</span><br><span class="line">      &#x2F;&#x2F;如果bufferStorage不为空，则优先处理bufferStorage的数据</span><br><span class="line">      Optional&lt;BufferOrEvent&gt; next;</span><br><span class="line">      if (bufferStorage.isEmpty()) &#123;</span><br><span class="line">         next &#x3D; inputGate.pollNext();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; TODO: FLINK-12536 for non credit-based flow control, getNext method is blocking</span><br><span class="line">         next &#x3D; bufferStorage.pollNext();</span><br><span class="line">         if (!next.isPresent()) &#123;</span><br><span class="line">            return pollNext();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!next.isPresent()) &#123;</span><br><span class="line">         return handleEmptyBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BufferOrEvent bufferOrEvent &#x3D; next.get();</span><br><span class="line">      </span><br><span class="line">      if (barrierHandler.isBlocked(offsetChannelIndex(bufferOrEvent.getChannelIndex()))) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果是EXACTLY_ONCE的CheckpointBarrierAligner，则阻塞，将消息刚入bufferStorage</span><br><span class="line">         &#x2F;&#x2F; if the channel is blocked, we just store the BufferOrEvent</span><br><span class="line">         bufferStorage.add(bufferOrEvent);</span><br><span class="line">         if (bufferStorage.isFull()) &#123;</span><br><span class="line">            barrierHandler.checkpointSizeLimitExceeded(bufferStorage.getMaxBufferedBytes());</span><br><span class="line">            &#x2F;&#x2F;如果bufferStorage满了，则开启一个新的存储队列</span><br><span class="line">            bufferStorage.rollOver();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">         return next;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;如果是CheckpointBarrier数据，则调用barrierHandler.processBarrier</span><br><span class="line">      else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CheckpointBarrier.class) &#123;</span><br><span class="line">         CheckpointBarrier checkpointBarrier &#x3D; (CheckpointBarrier) bufferOrEvent.getEvent();</span><br><span class="line">         if (!endOfInputGate) &#123;</span><br><span class="line">            &#x2F;&#x2F; process barriers only if there is a chance of the checkpoint completing</span><br><span class="line">            if (barrierHandler.processBarrier(checkpointBarrier, offsetChannelIndex(bufferOrEvent.getChannelIndex()), bufferStorage.getPendingBytes())) &#123;</span><br><span class="line">               bufferStorage.rollOver();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CancelCheckpointMarker.class) &#123;</span><br><span class="line">         if (barrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent())) &#123;</span><br><span class="line">            bufferStorage.rollOver();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">            if (barrierHandler.processEndOfPartition()) &#123;</span><br><span class="line">               bufferStorage.rollOver();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return next;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AT_LEAST_ONCE的CheckpointBarrierTracker的processBarrier过程，它仅仅追踪从每一个 input channel 接收到的 barrier，当所有 input channel 的 barrier 都被接收时，就可以触发 checkpoint 了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception &#123;</span><br><span class="line">   final long barrierId &#x3D; receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; fast path for single channel trackers</span><br><span class="line">   if (totalNumberOfInputChannels &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      notifyCheckpoint(receivedBarrier, 0, 0);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; general path for multiple input channels</span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;Received barrier for checkpoint &#123;&#125; from channel &#123;&#125;&quot;, barrierId, channelIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; find the checkpoint barrier in the queue of pending barriers</span><br><span class="line">   CheckpointBarrierCount barrierCount &#x3D; null;</span><br><span class="line">   int pos &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   for (CheckpointBarrierCount next : pendingCheckpoints) &#123;</span><br><span class="line">      if (next.checkpointId &#x3D;&#x3D; barrierId) &#123;</span><br><span class="line">         barrierCount &#x3D; next;</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      pos++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (barrierCount !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; add one to the count to that barrier and check for completion</span><br><span class="line">      int numBarriersNew &#x3D; barrierCount.incrementBarrierCount();</span><br><span class="line">      if (numBarriersNew &#x3D;&#x3D; totalNumberOfInputChannels) &#123;</span><br><span class="line">      &#x2F;&#x2F; 在当前 barrierId 前面的所有未完成的 checkpoint 都可以丢弃了</span><br><span class="line">         &#x2F;&#x2F; checkpoint can be triggered (or is aborted and all barriers have been seen)</span><br><span class="line">         &#x2F;&#x2F; first, remove this checkpoint and all all prior pending</span><br><span class="line">         &#x2F;&#x2F; checkpoints (which are now subsumed)</span><br><span class="line">         for (int i &#x3D; 0; i &lt;&#x3D; pos; i++) &#123;</span><br><span class="line">            pendingCheckpoints.pollFirst();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; notify the listener</span><br><span class="line">         if (!barrierCount.isAborted()) &#123;</span><br><span class="line">            if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">               LOG.debug(&quot;Received all barriers for checkpoint &#123;&#125;&quot;, barrierId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知进行 checkpoint</span><br><span class="line">            notifyCheckpoint(receivedBarrier, 0, 0);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; first barrier for that checkpoint ID</span><br><span class="line">      &#x2F;&#x2F; add it only if it is newer than the latest checkpoint.</span><br><span class="line">      &#x2F;&#x2F; if it is not newer than the latest checkpoint ID, then there cannot be a</span><br><span class="line">      &#x2F;&#x2F; successful checkpoint for that ID anyways</span><br><span class="line">      if (barrierId &gt; latestPendingCheckpointID) &#123;</span><br><span class="line">         latestPendingCheckpointID &#x3D; barrierId;</span><br><span class="line">         pendingCheckpoints.addLast(new CheckpointBarrierCount(barrierId));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; make sure we do not track too many checkpoints</span><br><span class="line">         if (pendingCheckpoints.size() &gt; MAX_CHECKPOINTS_TO_TRACK) &#123;</span><br><span class="line">            pendingCheckpoints.pollFirst();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于 EXACTLY_ONCE 模式下的 <code>BarrierBuffer</code>，它除了要追踪每一个 input channel 接收到的 barrier 之外，在接收到所有的 barrier 之前，先收到 barrier 的 channel 要进入阻塞状态。当然为了避免进入“反压”状态，<code>BarrierBuffer</code> 会继续接收数据，但会对接收到的数据进行缓存，直到所有的 barrier 都到达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception &#123;</span><br><span class="line">   final long barrierId &#x3D; receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; fast path for single channel cases</span><br><span class="line">   &#x2F;&#x2F;只有一个InputChannel，即只有1个barrier</span><br><span class="line">   if (totalNumberOfInputChannels &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">         &#x2F;&#x2F; new checkpoint</span><br><span class="line">         currentCheckpointId &#x3D; barrierId;</span><br><span class="line">         notifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   boolean checkpointAborted &#x3D; false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; -- general code path for multiple input channels --</span><br><span class="line"></span><br><span class="line">   if (numBarriersReceived &gt; 0) &#123;</span><br><span class="line">   &#x2F;&#x2F;已经收到了多个Barriers</span><br><span class="line">      &#x2F;&#x2F; this is only true if some alignment is already progress and was not canceled</span><br><span class="line"></span><br><span class="line">      if (barrierId &#x3D;&#x3D; currentCheckpointId) &#123;</span><br><span class="line">         &#x2F;&#x2F; regular case</span><br><span class="line">         &#x2F;&#x2F;barrierId是当前正在对齐的barrierId</span><br><span class="line">         onBarrier(channelIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">      &#x2F;&#x2F;barrierId比正在对齐的barrierId大，则废除当前正在做的Checkpoint</span><br><span class="line">         &#x2F;&#x2F; we did not complete the current checkpoint, another started before</span><br><span class="line">         LOG.warn(&quot;&#123;&#125;: Received checkpoint barrier for checkpoint &#123;&#125; before completing current checkpoint &#123;&#125;. &quot; +</span><br><span class="line">               &quot;Skipping current checkpoint.&quot;,</span><br><span class="line">            taskName,</span><br><span class="line">            barrierId,</span><br><span class="line">            currentCheckpointId);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; let the task know we are not completing this</span><br><span class="line">         notifyAbort(currentCheckpointId,</span><br><span class="line">            new CheckpointException(</span><br><span class="line">               &quot;Barrier id: &quot; + barrierId,</span><br><span class="line">               CheckpointFailureReason.CHECKPOINT_DECLINED_SUBSUMED));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; abort the current checkpoint</span><br><span class="line">         releaseBlocksAndResetBarriers();</span><br><span class="line">         checkpointAborted &#x3D; true;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; begin a the new checkpoint</span><br><span class="line">         &#x2F;&#x2F;重新开始对齐</span><br><span class="line">         beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; ignore trailing barrier from an earlier checkpoint (obsolete now)</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">      &#x2F;&#x2F; first barrier of a new checkpoint</span><br><span class="line">      &#x2F;&#x2F;收到了第一个barrier并且之前对齐的barrierId大</span><br><span class="line">      beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; either the current checkpoint was canceled (numBarriers &#x3D;&#x3D; 0) or</span><br><span class="line">      &#x2F;&#x2F; this barrier is from an old subsumed checkpoint</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; check if we have all barriers - since canceled checkpoints always have zero barriers</span><br><span class="line">   &#x2F;&#x2F; this can only happen on a non canceled checkpoint</span><br><span class="line">   &#x2F;&#x2F;是否收到了所有InputChannel的barrier</span><br><span class="line">   if (numBarriersReceived + numClosedChannels &#x3D;&#x3D; totalNumberOfInputChannels) &#123;</span><br><span class="line">      &#x2F;&#x2F; actually trigger checkpoint</span><br><span class="line">      if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">         LOG.debug(&quot;&#123;&#125;: Received all barriers, triggering checkpoint &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">            taskName,</span><br><span class="line">            receivedBarrier.getId(),</span><br><span class="line">            receivedBarrier.getTimestamp());</span><br><span class="line">      &#125;</span><br><span class="line">  &#x2F;&#x2F;释放缓存，并通知进行 checkpoint</span><br><span class="line">      releaseBlocksAndResetBarriers();</span><br><span class="line">      notifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return checkpointAborted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;阻塞已收到barrier的InputChannel</span><br><span class="line">protected void onBarrier(int channelIndex) throws IOException &#123;</span><br><span class="line">		if (!blockedChannels[channelIndex]) &#123;</span><br><span class="line">			blockedChannels[channelIndex] &#x3D; true;</span><br><span class="line"></span><br><span class="line">			numBarriersReceived++;</span><br><span class="line"></span><br><span class="line">			if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">				LOG.debug(&quot;&#123;&#125;: Received barrier from channel &#123;&#125;.&quot;, taskName, channelIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			throw new IOException(&quot;Stream corrupt: Repeated barrier for same checkpoint on input &quot; + channelIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;开启新的对齐，更新currentCheckpointId，并阻塞InputChannel</span><br><span class="line">protected void beginNewAlignment(long checkpointId, int channelIndex) throws IOException &#123;</span><br><span class="line">		currentCheckpointId &#x3D; checkpointId;</span><br><span class="line">		onBarrier(channelIndex);</span><br><span class="line"></span><br><span class="line">		startOfAlignmentTimestamp &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">		if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">			LOG.debug(&quot;&#123;&#125;: Starting stream alignment for checkpoint &#123;&#125;.&quot;, taskName, checkpointId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;将InputChannel变为非阻塞，并计算对齐耗时</span><br><span class="line">public void releaseBlocksAndResetBarriers() &#123;</span><br><span class="line">		LOG.debug(&quot;&#123;&#125;: End of stream alignment, feeding buffered data back.&quot;, taskName);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; blockedChannels.length; i++) &#123;</span><br><span class="line">			blockedChannels[i] &#x3D; false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; the next barrier that comes must assume it is the first</span><br><span class="line">		numBarriersReceived &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		if (startOfAlignmentTimestamp &gt; 0) &#123;</span><br><span class="line">			latestAlignmentDurationNanos &#x3D; System.nanoTime() - startOfAlignmentTimestamp;</span><br><span class="line">			startOfAlignmentTimestamp &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用CheckpointBarrierHandler的notifyCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void notifyCheckpoint(CheckpointBarrier checkpointBarrier, long bufferedBytes, long alignmentDurationNanos) throws Exception &#123;</span><br><span class="line">   if (toNotifyOnCheckpoint !&#x3D; null) &#123;</span><br><span class="line">      CheckpointMetaData checkpointMetaData &#x3D;</span><br><span class="line">         new CheckpointMetaData(checkpointBarrier.getId(), checkpointBarrier.getTimestamp());</span><br><span class="line"></span><br><span class="line">      CheckpointMetrics checkpointMetrics &#x3D; new CheckpointMetrics()</span><br><span class="line">         .setBytesBufferedInAlignment(bufferedBytes)</span><br><span class="line">         .setAlignmentDurationNanos(alignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">      toNotifyOnCheckpoint.triggerCheckpointOnBarrier(</span><br><span class="line">         checkpointMetaData,</span><br><span class="line">         checkpointBarrier.getCheckpointOptions(),</span><br><span class="line">         checkpointMetrics);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用AbstractInvokable的triggerCheckpointOnBarrier，即StreamTask的triggerCheckpointOnBarrier，triggerCheckpointOnBarrier与triggerCheckpointAsync基本一样，其中 triggerCheckpointAsync是触发 checkpoint 的源头，会向下游注入 <code>CheckpointBarrier</code>；而下游的其他任务在收到 <code>CheckpointBarrier</code> 后调用 <code>triggerCheckpointOnBarrier</code> 方法。这两个方法的具体实现有一些细微的差异，但主要的逻辑是一致的，在 <code>StreamTask.performCheckpoint()</code> 方法中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpointOnBarrier(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      CheckpointMetrics checkpointMetrics) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      if (performCheckpoint(checkpointMetaData, checkpointOptions, checkpointMetrics, false)) &#123;</span><br><span class="line">         if (isSynchronousSavepointId(checkpointMetaData.getCheckpointId())) &#123;</span><br><span class="line">            runSynchronousSavepointMailboxLoop();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (CancelTaskException e) &#123;</span><br><span class="line">      LOG.info(&quot;Operator &#123;&#125; was cancelled while performing checkpoint &#123;&#125;.&quot;,</span><br><span class="line">            getName(), checkpointMetaData.getCheckpointId());</span><br><span class="line">      throw e;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      throw new Exception(&quot;Could not perform checkpoint &quot; + checkpointMetaData.getCheckpointId() + &quot; for operator &quot; +</span><br><span class="line">         getName() + &#39;.&#39;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾performCheckpoint方法，发送Checkpoint经历三个步骤，准备发送，向下游发送Checkpoint，存储检查点快照状态。刚才的步骤是向下游发送Checkpoint，接下来看下怎么存储快照，就是StreamTask的checkpointState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void checkpointState(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      CheckpointMetrics checkpointMetrics) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 解析得到 CheckpointStorageLocation</span><br><span class="line">   CheckpointStreamFactory storage &#x3D; checkpointStorage.resolveCheckpointStorageLocation(</span><br><span class="line">         checkpointMetaData.getCheckpointId(),</span><br><span class="line">         checkpointOptions.getTargetLocation());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2. 将存储过程封装为 CheckpointingOperation，开始进行检查点存储操作</span><br><span class="line">   CheckpointingOperation checkpointingOperation &#x3D; new CheckpointingOperation(</span><br><span class="line">      this,</span><br><span class="line">      checkpointMetaData,</span><br><span class="line">      checkpointOptions,</span><br><span class="line">      storage,</span><br><span class="line">      checkpointMetrics);</span><br><span class="line"></span><br><span class="line">   checkpointingOperation.executeCheckpointing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查点快照的过程被封装为 <code>CheckpointingOperation</code>，由于每一个 <code>StreamTask</code> 可能包含多个算子，因而内部使用一个 Map 维护 <code>OperatorID -&gt; OperatorSnapshotFutures</code> 的关系。<code>CheckpointingOperation</code>中，快照操作分为两个阶段，第一阶段是同步执行的，第二阶段是异步执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static final class CheckpointingOperation &#123;</span><br><span class="line"></span><br><span class="line">   private final StreamTask&lt;?, ?&gt; owner;</span><br><span class="line"></span><br><span class="line">   private final CheckpointMetaData checkpointMetaData;</span><br><span class="line">   private final CheckpointOptions checkpointOptions;</span><br><span class="line">   private final CheckpointMetrics checkpointMetrics;</span><br><span class="line">   private final CheckpointStreamFactory storageLocation;</span><br><span class="line"></span><br><span class="line">   private final StreamOperator&lt;?&gt;[] allOperators;</span><br><span class="line"></span><br><span class="line">   private long startSyncPartNano;</span><br><span class="line">   private long startAsyncPartNano;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------</span><br><span class="line">&#x2F;&#x2F;每一个算子的快照被抽象为 OperatorSnapshotFutures，包含了 operator state 和 keyed state 的快照结果：</span><br><span class="line">   private final Map&lt;OperatorID, OperatorSnapshotFutures&gt; operatorSnapshotsInProgress;</span><br><span class="line"></span><br><span class="line">   public void executeCheckpointing() throws Exception &#123;</span><br><span class="line">      startSyncPartNano &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;1. 同步执行的部分</span><br><span class="line">         for (StreamOperator&lt;?&gt; op : allOperators) &#123;</span><br><span class="line">            checkpointStreamOperator(op);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;Finished synchronous checkpoints for checkpoint &#123;&#125; on task &#123;&#125;&quot;,</span><br><span class="line">               checkpointMetaData.getCheckpointId(), owner.getName());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         startAsyncPartNano &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">         checkpointMetrics.setSyncDurationMillis((startAsyncPartNano - startSyncPartNano) &#x2F; 1_000_000);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; we are transferring ownership over snapshotInProgressList for cleanup to the thread, active on submit</span><br><span class="line">         &#x2F;&#x2F;2. 异步执行的部分</span><br><span class="line">				&#x2F;&#x2F; checkpoint 可以配置成同步执行，也可以配置成异步执行的</span><br><span class="line">				&#x2F;&#x2F; 如果是同步执行的，在这里实际上所有的 runnable future 都是已经完成的状态</span><br><span class="line">         AsyncCheckpointRunnable asyncCheckpointRunnable &#x3D; new AsyncCheckpointRunnable(</span><br><span class="line">            owner,</span><br><span class="line">            operatorSnapshotsInProgress,</span><br><span class="line">            checkpointMetaData,</span><br><span class="line">            checkpointMetrics,</span><br><span class="line">            startAsyncPartNano);</span><br><span class="line"></span><br><span class="line">         owner.cancelables.registerCloseable(asyncCheckpointRunnable);</span><br><span class="line">         owner.asyncOperationsThreadPool.execute(asyncCheckpointRunnable);</span><br><span class="line"></span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - finished synchronous part of checkpoint &#123;&#125;. &quot; +</span><br><span class="line">                  &quot;Alignment duration: &#123;&#125; ms, snapshot duration &#123;&#125; ms&quot;,</span><br><span class="line">               owner.getName(), checkpointMetaData.getCheckpointId(),</span><br><span class="line">               checkpointMetrics.getAlignmentDurationNanos() &#x2F; 1_000_000,</span><br><span class="line">               checkpointMetrics.getSyncDurationMillis());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>每一个算子的快照被抽象为 <code>OperatorSnapshotFutures</code>，包含了 operator state 和 keyed state 的快照结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorSnapshotFutures &#123;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateManagedFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateRawFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateManagedFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateRawFuture;</span><br></pre></td></tr></table></figure>

<p>checkpointStreamOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void checkpointStreamOperator(StreamOperator&lt;?&gt; op) throws Exception &#123;</span><br><span class="line">   if (null !&#x3D; op) &#123;</span><br><span class="line">&#x2F;&#x2F; 调用 StreamOperator.snapshotState 方法进行快照</span><br><span class="line">				&#x2F;&#x2F; 返回的结果是 runnable future，可能是已经执行完了，也可能没有执行完</span><br><span class="line">      OperatorSnapshotFutures snapshotInProgress &#x3D; op.snapshotState(</span><br><span class="line">            checkpointMetaData.getCheckpointId(),</span><br><span class="line">            checkpointMetaData.getTimestamp(),</span><br><span class="line">            checkpointOptions,</span><br><span class="line">            storageLocation);</span><br><span class="line">      operatorSnapshotsInProgress.put(op.getOperatorID(), snapshotInProgress);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同步执行阶段，会依次调用每一个算子的 <code>StreamOperator.snapshotState</code>，返回结果是一个 runnable future。根据 checkpoint 配置成同步模式和异步模式的区别，这个 future 可能处于完成状态，也可能处于未完成状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">StreamOperator：</span><br><span class="line">OperatorSnapshotFutures snapshotState(</span><br><span class="line">   long checkpointId,</span><br><span class="line">   long timestamp,</span><br><span class="line">   CheckpointOptions checkpointOptions,</span><br><span class="line">   CheckpointStreamFactory storageLocation) throws Exception;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">AbstractStreamOperator：</span><br><span class="line">@Override</span><br><span class="line">	public final OperatorSnapshotFutures snapshotState(long checkpointId, long timestamp, CheckpointOptions checkpointOptions,</span><br><span class="line">			CheckpointStreamFactory factory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		KeyGroupRange keyGroupRange &#x3D; null !&#x3D; keyedStateBackend ?</span><br><span class="line">				keyedStateBackend.getKeyGroupRange() : KeyGroupRange.EMPTY_KEY_GROUP_RANGE;</span><br><span class="line"></span><br><span class="line">		OperatorSnapshotFutures snapshotInProgress &#x3D; new OperatorSnapshotFutures();</span><br><span class="line"></span><br><span class="line">		StateSnapshotContextSynchronousImpl snapshotContext &#x3D; new StateSnapshotContextSynchronousImpl(</span><br><span class="line">			checkpointId,</span><br><span class="line">			timestamp,</span><br><span class="line">			factory,</span><br><span class="line">			keyGroupRange,</span><br><span class="line">			getContainingTask().getCancelables());</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;对状态进行快照</span><br><span class="line">			snapshotState(snapshotContext);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;raw state，要在子类中自己实现 raw state 的快照写入</span><br><span class="line">			&#x2F;&#x2F;timer 是作为 raw keyed state 写入的snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());</span><br><span class="line">			snapshotInProgress.setOperatorStateRawFuture(snapshotContext.getOperatorStateStreamFuture());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写入 managed state 快照</span><br><span class="line">			if (null !&#x3D; operatorStateBackend) &#123;</span><br><span class="line">				snapshotInProgress.setOperatorStateManagedFuture(</span><br><span class="line">					operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写入 managed keyed state 快照</span><br><span class="line">			if (null !&#x3D; keyedStateBackend) &#123;</span><br><span class="line">				snapshotInProgress.setKeyedStateManagedFuture(</span><br><span class="line">					keyedStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception snapshotException) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				snapshotInProgress.cancel();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				snapshotException.addSuppressed(e);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String snapshotFailMessage &#x3D; &quot;Could not complete snapshot &quot; + checkpointId + &quot; for operator &quot; +</span><br><span class="line">				getOperatorName() + &quot;.&quot;;</span><br><span class="line"></span><br><span class="line">			if (!getContainingTask().isCanceled()) &#123;</span><br><span class="line">				LOG.info(snapshotFailMessage, snapshotException);</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				snapshotContext.closeExceptionally();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				snapshotException.addSuppressed(e);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new CheckpointException(snapshotFailMessage, CheckpointFailureReason.CHECKPOINT_DECLINED, snapshotException);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return snapshotInProgress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void snapshotState(StateSnapshotContext context) throws Exception &#123;</span><br><span class="line">		final KeyedStateBackend&lt;?&gt; keyedStateBackend &#x3D; getKeyedStateBackend();</span><br><span class="line">		&#x2F;&#x2F;TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots</span><br><span class="line">		&#x2F;&#x2F; 所有的 timer 都作为 raw keyed state 写入</span><br><span class="line">		if (keyedStateBackend instanceof AbstractKeyedStateBackend &amp;&amp;</span><br><span class="line">			((AbstractKeyedStateBackend&lt;?&gt;) keyedStateBackend).requiresLegacySynchronousTimerSnapshots()) &#123;</span><br><span class="line"></span><br><span class="line">			KeyedStateCheckpointOutputStream out;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				out &#x3D; context.getRawKeyedOperatorStateOutput();</span><br><span class="line">			&#125; catch (Exception exception) &#123;</span><br><span class="line">				throw new Exception(&quot;Could not open raw keyed operator state stream for &quot; +</span><br><span class="line">					getOperatorName() + &#39;.&#39;, exception);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				KeyGroupsList allKeyGroups &#x3D; out.getKeyGroupList();</span><br><span class="line">				for (int keyGroupIdx : allKeyGroups) &#123;</span><br><span class="line">					out.startNewKeyGroup(keyGroupIdx);</span><br><span class="line"></span><br><span class="line">					timeServiceManager.snapshotStateForKeyGroup(</span><br><span class="line">						new DataOutputViewStreamWrapper(out), keyGroupIdx);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Exception exception) &#123;</span><br><span class="line">				throw new Exception(&quot;Could not write timer service of &quot; + getOperatorName() +</span><br><span class="line">					&quot; to checkpoint state stream.&quot;, exception);</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					out.close();</span><br><span class="line">				&#125; catch (Exception closeException) &#123;</span><br><span class="line">					LOG.warn(&quot;Could not close raw keyed operator state stream for &#123;&#125;. This &quot; +</span><br><span class="line">						&quot;might have prevented deleting some state data.&quot;, getOperatorName(), closeException);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;用户也可以自己实现snapshotState，AbstractUdfStreamOperator继承AbstractStreamOperator</span><br><span class="line">public void snapshotState(StateSnapshotContext context) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;先调用父类AbstractStreamOperator方法，写入timer</span><br><span class="line">		super.snapshotState(context);</span><br><span class="line">		&#x2F;&#x2F;通过反射调用用户函数中的快照操作</span><br><span class="line">		StreamingFunctionUtils.snapshotFunctionState(context, getOperatorStateBackend(), userFunction);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	StreamingFunctionUtils类：</span><br><span class="line">public static void snapshotFunctionState(</span><br><span class="line">			StateSnapshotContext context,</span><br><span class="line">			OperatorStateBackend backend,</span><br><span class="line">			Function userFunction) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		Preconditions.checkNotNull(context);</span><br><span class="line">		Preconditions.checkNotNull(backend);</span><br><span class="line"></span><br><span class="line">		while (true) &#123;</span><br><span class="line"></span><br><span class="line">			if (trySnapshotFunctionState(context, backend, userFunction)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function</span><br><span class="line">			if (userFunction instanceof WrappingFunction) &#123;</span><br><span class="line">				userFunction &#x3D; ((WrappingFunction&lt;?&gt;) userFunction).getWrappedFunction();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private static boolean trySnapshotFunctionState(</span><br><span class="line">			StateSnapshotContext context,</span><br><span class="line">			OperatorStateBackend backend,</span><br><span class="line">			Function userFunction) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果用户函数实现了 CheckpointedFunction 接口，调用 snapshotState 创建快照</span><br><span class="line">		if (userFunction instanceof CheckpointedFunction) &#123;</span><br><span class="line">			((CheckpointedFunction) userFunction).snapshotState(context);</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果用户函数实现了 ListCheckpointed</span><br><span class="line">		if (userFunction instanceof ListCheckpointed) &#123;</span><br><span class="line">		&#x2F;&#x2F;先调用 snapshotState 方法获取当前状态</span><br><span class="line">			@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			List&lt;Serializable&gt; partitionableState &#x3D; ((ListCheckpointed&lt;Serializable&gt;) userFunction).</span><br><span class="line">					snapshotState(context.getCheckpointId(), context.getCheckpointTimestamp());</span><br><span class="line">&#x2F;&#x2F;获取后端存储的状态的引用</span><br><span class="line">			ListState&lt;Serializable&gt; listState &#x3D; backend.</span><br><span class="line">					getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME);</span><br><span class="line">&#x2F;&#x2F;清空当前后端存储的 ListState</span><br><span class="line">			listState.clear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前状态依次加入后端存储</span><br><span class="line">			if (null !&#x3D; partitionableState) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					for (Serializable statePartition : partitionableState) &#123;</span><br><span class="line">						listState.add(statePartition);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					listState.clear();</span><br><span class="line"></span><br><span class="line">					throw new Exception(&quot;Could not write partitionable state to operator &quot; +</span><br><span class="line">						&quot;state backend.&quot;, e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经看到 checkpoint 操作是如何同用户自定义函数建立关联的了，接下来我们来看看由 Flink 托管的状态是如何写入存储系统的。</p>
<p>首先来看看 operator state。<code>DefaultOperatorStateBackend</code> 将实际的工作交给 <code>DefaultOperatorStateBackendSnapshotStrategy</code> 完成。首先，会为对当前注册的所有 operator state（包含 list state 和 broadcast state）做深度拷贝，然后将实际的写入操作封装在一个异步的 FutureTask 中，这个 FutureTask 的主要任务包括： 1）打开输出流 2）写入状态元数据信息 3）写入状态 4）关闭输出流，获得状态句柄。如果不启用异步checkpoint模式，那么这个 FutureTask 在同步阶段就会立刻执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">public RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; snapshot(</span><br><span class="line">   final long checkpointId,</span><br><span class="line">   final long timestamp,</span><br><span class="line">   @Nonnull final CheckpointStreamFactory streamFactory,</span><br><span class="line">   @Nonnull final CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   if (registeredOperatorStates.isEmpty() &amp;&amp; registeredBroadcastStates.isEmpty()) &#123;</span><br><span class="line">      return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final Map&lt;String, PartitionableListState&lt;?&gt;&gt; registeredOperatorStatesDeepCopies &#x3D;</span><br><span class="line">      new HashMap&lt;&gt;(registeredOperatorStates.size());</span><br><span class="line">   final Map&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; registeredBroadcastStatesDeepCopies &#x3D;</span><br><span class="line">      new HashMap&lt;&gt;(registeredBroadcastStates.size());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得已注册的所有 list state 和 broadcast state 的深拷贝</span><br><span class="line">   ClassLoader snapshotClassLoader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">   Thread.currentThread().setContextClassLoader(userClassLoader);</span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; eagerly create deep copies of the list and the broadcast states (if any)</span><br><span class="line">      &#x2F;&#x2F; in the synchronous phase, so that we can use them in the async writing.</span><br><span class="line"></span><br><span class="line">      if (!registeredOperatorStates.isEmpty()) &#123;</span><br><span class="line">         for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry : registeredOperatorStates.entrySet()) &#123;</span><br><span class="line">            PartitionableListState&lt;?&gt; listState &#x3D; entry.getValue();</span><br><span class="line">            if (null !&#x3D; listState) &#123;</span><br><span class="line">               listState &#x3D; listState.deepCopy();</span><br><span class="line">            &#125;</span><br><span class="line">            registeredOperatorStatesDeepCopies.put(entry.getKey(), listState);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!registeredBroadcastStates.isEmpty()) &#123;</span><br><span class="line">         for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry : registeredBroadcastStates.entrySet()) &#123;</span><br><span class="line">            BackendWritableBroadcastState&lt;?, ?&gt; broadcastState &#x3D; entry.getValue();</span><br><span class="line">            if (null !&#x3D; broadcastState) &#123;</span><br><span class="line">               broadcastState &#x3D; broadcastState.deepCopy();</span><br><span class="line">            &#125;</span><br><span class="line">            registeredBroadcastStatesDeepCopies.put(entry.getKey(), broadcastState);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setContextClassLoader(snapshotClassLoader);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将主要写入操作封装为一个异步的FutureTask</span><br><span class="line">   AsyncSnapshotCallable&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; snapshotCallable &#x3D;</span><br><span class="line">      new AsyncSnapshotCallable&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected SnapshotResult&lt;OperatorStateHandle&gt; callInternal() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 创建状态输出流</span><br><span class="line">            CheckpointStreamFactory.CheckpointStateOutputStream localOut &#x3D;</span><br><span class="line">               streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE);</span><br><span class="line">            snapshotCloseableRegistry.registerCloseable(localOut);</span><br><span class="line">&#x2F;&#x2F; 收集元数据</span><br><span class="line">            &#x2F;&#x2F; get the registered operator state infos ...</span><br><span class="line">            List&lt;StateMetaInfoSnapshot&gt; operatorMetaInfoSnapshots &#x3D;</span><br><span class="line">               new ArrayList&lt;&gt;(registeredOperatorStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry :</span><br><span class="line">               registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">               operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... get the registered broadcast operator state infos ...</span><br><span class="line">            List&lt;StateMetaInfoSnapshot&gt; broadcastMetaInfoSnapshots &#x3D;</span><br><span class="line">               new ArrayList&lt;&gt;(registeredBroadcastStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry :</span><br><span class="line">               registeredBroadcastStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">               broadcastMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... write them all in the checkpoint stream ...</span><br><span class="line">            &#x2F;&#x2F; 写入元数据</span><br><span class="line">            DataOutputView dov &#x3D; new DataOutputViewStreamWrapper(localOut);</span><br><span class="line"></span><br><span class="line">            OperatorBackendSerializationProxy backendSerializationProxy &#x3D;</span><br><span class="line">               new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots);</span><br><span class="line"></span><br><span class="line">            backendSerializationProxy.write(dov);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and then go for the states ...</span><br><span class="line">&#x2F;&#x2F; 写入状态</span><br><span class="line">            &#x2F;&#x2F; we put BOTH normal and broadcast state metadata here</span><br><span class="line">            int initialMapCapacity &#x3D;</span><br><span class="line">               registeredOperatorStatesDeepCopies.size() + registeredBroadcastStatesDeepCopies.size();</span><br><span class="line">            final Map&lt;String, OperatorStateHandle.StateMetaInfo&gt; writtenStatesMetaData &#x3D;</span><br><span class="line">               new HashMap&lt;&gt;(initialMapCapacity);</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry :</span><br><span class="line">               registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">               PartitionableListState&lt;?&gt; value &#x3D; entry.getValue();</span><br><span class="line">               long[] partitionOffsets &#x3D; value.write(localOut);</span><br><span class="line">               OperatorStateHandle.Mode mode &#x3D; value.getStateMetaInfo().getAssignmentMode();</span><br><span class="line">               writtenStatesMetaData.put(</span><br><span class="line">                  entry.getKey(),</span><br><span class="line">                  new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and the broadcast states themselves ...</span><br><span class="line">            for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry :</span><br><span class="line">               registeredBroadcastStatesDeepCopies.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">               BackendWritableBroadcastState&lt;?, ?&gt; value &#x3D; entry.getValue();</span><br><span class="line">               long[] partitionOffsets &#x3D; &#123;value.write(localOut)&#125;;</span><br><span class="line">               OperatorStateHandle.Mode mode &#x3D; value.getStateMetaInfo().getAssignmentMode();</span><br><span class="line">               writtenStatesMetaData.put(</span><br><span class="line">                  entry.getKey(),</span><br><span class="line">                  new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and, finally, create the state handle.</span><br><span class="line">            OperatorStateHandle retValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">            if (snapshotCloseableRegistry.unregisterCloseable(localOut)) &#123;</span><br><span class="line">&#x2F;&#x2F;关闭输出流，获得状态句柄，后面可以用这个句柄读取状态</span><br><span class="line">               StreamStateHandle stateHandle &#x3D; localOut.closeAndGetHandle();</span><br><span class="line"></span><br><span class="line">               if (stateHandle !&#x3D; null) &#123;</span><br><span class="line">                  retValue &#x3D; new OperatorStreamStateHandle(writtenStatesMetaData, stateHandle);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               return SnapshotResult.of(retValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               throw new IOException(&quot;Stream was already unregistered.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected void cleanupProvidedResources() &#123;</span><br><span class="line">            &#x2F;&#x2F; nothing to do</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected void logAsyncSnapshotComplete(long startTime) &#123;</span><br><span class="line">            if (asynchronousSnapshots) &#123;</span><br><span class="line">               logAsyncCompleted(streamFactory, startTime);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">   final FutureTask&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; task &#x3D;</span><br><span class="line">      snapshotCallable.toAsyncSnapshotFutureTask(closeStreamOnCancelRegistry);</span><br><span class="line">&#x2F;&#x2F;如果不是异步 checkpoint 那么在这里直接运行 FutureTask，即在同步阶段就完成了状态的写入</span><br><span class="line">   if (!asynchronousSnapshots) &#123;</span><br><span class="line">      task.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keyed state 写入的基本流程与此相似，但由于 keyed state 在存储时有多种实现，包括基于堆内存和 RocksDB 的不同实现，此外基于 RocksDB 的实现还包括支持<a href="https://flink.apache.org/features/2018/01/30/incremental-checkpointing.html" target="_blank" rel="noopener">增量 checkpoint</a>，因而相比于 operator state 要更复杂一些。另外，Flink 自 1.5.0 版本还引入了一个<a href="https://issues.apache.org/jira/browse/FLINK-8360" target="_blank" rel="noopener">本地状态存储</a>的优化，支持在 TaskManager 的本地保存一份 keyed state，试图优化状态恢复的速度和网络开销。</p>
<p>具体三种 StateBackend 即MemoryStateBackend、FsStateBackend、RocksDBStateBackend对应的 OperatorStateBackend 和 KeyedStateBackend 分别为：</p>
<p><img src="/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/1.png" alt></p>
<p>所谓本地状态存储，即在存储检查点快照时，在 <code>Task</code> 所在的 TaskManager 本地文件系统中存储一份副本，这样在进行状态恢复时可以优先从本地状态进行恢复，从而减少网络数据传输的开销。本地状态存储仅针对 keyed state，我们以较为简单的 <code>HeapKeyedStateBackend</code> 为例，看看本地状态存储时如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; snapshot(</span><br><span class="line">		long checkpointId,</span><br><span class="line">		long timestamp,</span><br><span class="line">		@Nonnull CheckpointStreamFactory primaryStreamFactory,</span><br><span class="line">		@Nonnull CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		if (!hasRegisteredState()) &#123;</span><br><span class="line">			return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int numStates &#x3D; registeredKVStates.size() + registeredPQStates.size();</span><br><span class="line"></span><br><span class="line">		Preconditions.checkState(numStates &lt;&#x3D; Short.MAX_VALUE,</span><br><span class="line">			&quot;Too many states: &quot; + numStates +</span><br><span class="line">				&quot;. Currently at most &quot; + Short.MAX_VALUE + &quot; states are supported&quot;);</span><br><span class="line"></span><br><span class="line">		final List&lt;StateMetaInfoSnapshot&gt; metaInfoSnapshots &#x3D; new ArrayList&lt;&gt;(numStates);</span><br><span class="line">		final Map&lt;StateUID, Integer&gt; stateNamesToId &#x3D;</span><br><span class="line">			new HashMap&lt;&gt;(numStates);</span><br><span class="line">		final Map&lt;StateUID, StateSnapshot&gt; cowStateStableSnapshots &#x3D;</span><br><span class="line">			new HashMap&lt;&gt;(numStates);</span><br><span class="line"></span><br><span class="line">		processSnapshotMetaInfoForAllStates(</span><br><span class="line">			metaInfoSnapshots,</span><br><span class="line">			cowStateStableSnapshots,</span><br><span class="line">			stateNamesToId,</span><br><span class="line">			registeredKVStates,</span><br><span class="line">			StateMetaInfoSnapshot.BackendStateType.KEY_VALUE);</span><br><span class="line"></span><br><span class="line">		processSnapshotMetaInfoForAllStates(</span><br><span class="line">			metaInfoSnapshots,</span><br><span class="line">			cowStateStableSnapshots,</span><br><span class="line">			stateNamesToId,</span><br><span class="line">			registeredPQStates,</span><br><span class="line">			StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE);</span><br><span class="line"></span><br><span class="line">		final KeyedBackendSerializationProxy&lt;K&gt; serializationProxy &#x3D;</span><br><span class="line">			new KeyedBackendSerializationProxy&lt;&gt;(</span><br><span class="line">				&#x2F;&#x2F; TODO: this code assumes that writing a serializer is threadsafe, we should support to</span><br><span class="line">				&#x2F;&#x2F; get a serialized form already at state registration time in the future</span><br><span class="line">				getKeySerializer(),</span><br><span class="line">				metaInfoSnapshots,</span><br><span class="line">				!Objects.equals(UncompressedStreamCompressionDecorator.INSTANCE, keyGroupCompressionDecorator));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 CheckpointStreamWithResultProvider</span><br><span class="line">		final SupplierWithException&lt;CheckpointStreamWithResultProvider, Exception&gt; checkpointStreamSupplier &#x3D;</span><br><span class="line">&#x2F;&#x2F;是否启用本地存储</span><br><span class="line">			localRecoveryConfig.isLocalRecoveryEnabled() ?</span><br><span class="line"></span><br><span class="line">				() -&gt; CheckpointStreamWithResultProvider.createDuplicatingStream(</span><br><span class="line">					checkpointId,</span><br><span class="line">					CheckpointedStateScope.EXCLUSIVE,</span><br><span class="line">					primaryStreamFactory,</span><br><span class="line">					localRecoveryConfig.getLocalStateDirectoryProvider()) :</span><br><span class="line"></span><br><span class="line">				() -&gt; CheckpointStreamWithResultProvider.createSimpleStream(</span><br><span class="line">					CheckpointedStateScope.EXCLUSIVE,</span><br><span class="line">					primaryStreamFactory);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;--------------------------------------------------- this becomes the end of sync part</span><br><span class="line"></span><br><span class="line">		final AsyncSnapshotCallable&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; asyncSnapshotCallable &#x3D;</span><br><span class="line">			new AsyncSnapshotCallable&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected SnapshotResult&lt;KeyedStateHandle&gt; callInternal() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">					final CheckpointStreamWithResultProvider streamWithResultProvider &#x3D;</span><br><span class="line">						checkpointStreamSupplier.get();</span><br><span class="line"></span><br><span class="line">					snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);</span><br><span class="line"></span><br><span class="line">					final CheckpointStreamFactory.CheckpointStateOutputStream localStream &#x3D;</span><br><span class="line">						streamWithResultProvider.getCheckpointOutputStream();</span><br><span class="line"></span><br><span class="line">					final DataOutputViewStreamWrapper outView &#x3D; new DataOutputViewStreamWrapper(localStream);</span><br><span class="line">					serializationProxy.write(outView);</span><br><span class="line"></span><br><span class="line">					final long[] keyGroupRangeOffsets &#x3D; new long[keyGroupRange.getNumberOfKeyGroups()];</span><br><span class="line"></span><br><span class="line">					for (int keyGroupPos &#x3D; 0; keyGroupPos &lt; keyGroupRange.getNumberOfKeyGroups(); ++keyGroupPos) &#123;</span><br><span class="line">						int keyGroupId &#x3D; keyGroupRange.getKeyGroupId(keyGroupPos);</span><br><span class="line">						keyGroupRangeOffsets[keyGroupPos] &#x3D; localStream.getPos();</span><br><span class="line">						outView.writeInt(keyGroupId);</span><br><span class="line"></span><br><span class="line">						for (Map.Entry&lt;StateUID, StateSnapshot&gt; stateSnapshot :</span><br><span class="line">							cowStateStableSnapshots.entrySet()) &#123;</span><br><span class="line">							StateSnapshot.StateKeyGroupWriter partitionedSnapshot &#x3D;</span><br><span class="line"></span><br><span class="line">								stateSnapshot.getValue().getKeyGroupWriter();</span><br><span class="line">							try (</span><br><span class="line">								OutputStream kgCompressionOut &#x3D;</span><br><span class="line">									keyGroupCompressionDecorator.decorateWithCompression(localStream)) &#123;</span><br><span class="line">								DataOutputViewStreamWrapper kgCompressionView &#x3D;</span><br><span class="line">									new DataOutputViewStreamWrapper(kgCompressionOut);</span><br><span class="line">								kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));</span><br><span class="line">								partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);</span><br><span class="line">							&#125; &#x2F;&#x2F; this will just close the outer compression stream</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) &#123;</span><br><span class="line">						KeyGroupRangeOffsets kgOffs &#x3D; new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);</span><br><span class="line">						SnapshotResult&lt;StreamStateHandle&gt; result &#x3D;</span><br><span class="line">							streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();</span><br><span class="line">						return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(result, kgOffs);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						throw new IOException(&quot;Stream already unregistered.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				protected void cleanupProvidedResources() &#123;</span><br><span class="line">					for (StateSnapshot tableSnapshot : cowStateStableSnapshots.values()) &#123;</span><br><span class="line">						tableSnapshot.release();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				protected void logAsyncSnapshotComplete(long startTime) &#123;</span><br><span class="line">					if (snapshotStrategySynchronicityTrait.isAsynchronous()) &#123;</span><br><span class="line">						logAsyncCompleted(primaryStreamFactory, startTime);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">		final FutureTask&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; task &#x3D;</span><br><span class="line">			asyncSnapshotCallable.toAsyncSnapshotFutureTask(cancelStreamRegistry);</span><br><span class="line">		finalizeSnapshotBeforeReturnHook(task);</span><br><span class="line"></span><br><span class="line">		return task;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>所以在启用本地状态存储的情况下，会创建两个输出流，其中 <code>primaryOut</code> 对应外部存储，而 <code>secondaryOut</code> 对应本地存储。状态会输出两份。本地状态句柄会存储在 <code>TaskLocalStateStore</code> 中。</p>
<p>CheckpointStreamWithResultProvider：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static CheckpointStreamWithResultProvider createDuplicatingStream(</span><br><span class="line">   @Nonnegative long checkpointId,</span><br><span class="line">   @Nonnull CheckpointedStateScope checkpointedStateScope,</span><br><span class="line">   @Nonnull CheckpointStreamFactory primaryStreamFactory,</span><br><span class="line">   @Nonnull LocalRecoveryDirectoryProvider secondaryStreamDirProvider) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   CheckpointStreamFactory.CheckpointStateOutputStream primaryOut &#x3D;</span><br><span class="line">      primaryStreamFactory.createCheckpointStateOutputStream(checkpointedStateScope);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      File outFile &#x3D; new File(</span><br><span class="line">         secondaryStreamDirProvider.subtaskSpecificCheckpointDirectory(checkpointId),</span><br><span class="line">         String.valueOf(UUID.randomUUID()));</span><br><span class="line">      Path outPath &#x3D; new Path(outFile.toURI());</span><br><span class="line"></span><br><span class="line">      CheckpointStreamFactory.CheckpointStateOutputStream secondaryOut &#x3D;</span><br><span class="line">         new FileBasedStateOutputStream(outPath.getFileSystem(), outPath);</span><br><span class="line">&#x2F;&#x2F;有两个输出流，primary 和 secondary，secondary 对应本地存储</span><br><span class="line">      return new CheckpointStreamWithResultProvider.PrimaryAndSecondaryStream(primaryOut, secondaryOut);</span><br><span class="line">   &#125; catch (IOException secondaryEx) &#123;</span><br><span class="line">      LOG.warn(&quot;Exception when opening secondary&#x2F;local checkpoint output stream. &quot; +</span><br><span class="line">         &quot;Continue only with the primary stream.&quot;, secondaryEx);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new CheckpointStreamWithResultProvider.PrimaryStreamOnly(primaryOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而RocksDBSnapshotStrategyBase的doSnapshot分为两种实现情况，RocksIncrementalSnapshotStrategy和RocksFullSnapshotStrategy分别对应增量和全量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; snapshot(</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long timestamp,</span><br><span class="line">      @Nonnull CheckpointStreamFactory streamFactory,</span><br><span class="line">      @Nonnull CheckpointOptions checkpointOptions) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">      if (kvStateInformation.isEmpty()) &#123;</span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;Asynchronous RocksDB snapshot performed on empty keyed state at &#123;&#125;. Returning null.&quot;,</span><br><span class="line">               timestamp);</span><br><span class="line">         &#125;</span><br><span class="line">         return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return doSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method implements the concrete snapshot logic for a non-empty state.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   protected abstract RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; doSnapshot(</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long timestamp,</span><br><span class="line">      CheckpointStreamFactory streamFactory,</span><br><span class="line">      CheckpointOptions checkpointOptions) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们介绍了快照操作的第一个阶段，即同步执行的阶段。异步执行阶段被封装为 <code>AsyncCheckpointRunnable</code>，主要的操作包括 1）执行同步阶段创建的 FutureTask 2）完成后向 CheckpointCoordinator 发送 Ack 响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">protected static final class AsyncCheckpointRunnable implements Runnable, Closeable &#123;</span><br><span class="line"></span><br><span class="line">   private final StreamTask&lt;?, ?&gt; owner;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;OperatorID, OperatorSnapshotFutures&gt; operatorSnapshotsInProgress;</span><br><span class="line"></span><br><span class="line">   private final CheckpointMetaData checkpointMetaData;</span><br><span class="line">   private final CheckpointMetrics checkpointMetrics;</span><br><span class="line"></span><br><span class="line">   private final long asyncStartNanos;</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;CheckpointingOperation.AsyncCheckpointState&gt; asyncCheckpointState &#x3D; new AtomicReference&lt;&gt;(</span><br><span class="line">      CheckpointingOperation.AsyncCheckpointState.RUNNING);</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">         TaskStateSnapshot jobManagerTaskOperatorSubtaskStates &#x3D;</span><br><span class="line">            new TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line"></span><br><span class="line">         TaskStateSnapshot localTaskOperatorSubtaskStates &#x3D;</span><br><span class="line">            new TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 完成每一个 operator 的状态写入</span><br><span class="line">				&#x2F;&#x2F; 如果是同步 checkpoint，那么在此之前状态已经写入完成</span><br><span class="line">				&#x2F;&#x2F; 如果是异步 checkpoint，那么在这里才会写入状态</span><br><span class="line">         for (Map.Entry&lt;OperatorID, OperatorSnapshotFutures&gt; entry : operatorSnapshotsInProgress.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            OperatorID operatorID &#x3D; entry.getKey();</span><br><span class="line">            OperatorSnapshotFutures snapshotInProgress &#x3D; entry.getValue();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; finalize the async part of all by executing all snapshot runnables</span><br><span class="line">            OperatorSnapshotFinalizer finalizedSnapshots &#x3D;</span><br><span class="line">               new OperatorSnapshotFinalizer(snapshotInProgress);</span><br><span class="line"></span><br><span class="line">            jobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">               operatorID,</span><br><span class="line">               finalizedSnapshots.getJobManagerOwnedState());</span><br><span class="line"></span><br><span class="line">            localTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">               operatorID,</span><br><span class="line">               finalizedSnapshots.getTaskLocalState());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         final long asyncEndNanos &#x3D; System.nanoTime();</span><br><span class="line">         final long asyncDurationMillis &#x3D; (asyncEndNanos - asyncStartNanos) &#x2F; 1_000_000L;</span><br><span class="line"></span><br><span class="line">         checkpointMetrics.setAsyncDurationMillis(asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">         if (asyncCheckpointState.compareAndSet(CheckpointingOperation.AsyncCheckpointState.RUNNING,</span><br><span class="line">            CheckpointingOperation.AsyncCheckpointState.COMPLETED)) &#123;</span><br><span class="line">&#x2F;&#x2F;报告 snapshot 完成</span><br><span class="line">            reportCompletedSnapshotStates(</span><br><span class="line">               jobManagerTaskOperatorSubtaskStates,</span><br><span class="line">               localTaskOperatorSubtaskStates,</span><br><span class="line">               asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - asynchronous part of checkpoint &#123;&#125; could not be completed because it was closed before.&quot;,</span><br><span class="line">               owner.getName(),</span><br><span class="line">               checkpointMetaData.getCheckpointId());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - asynchronous part of checkpoint &#123;&#125; could not be completed.&quot;,</span><br><span class="line">               owner.getName(),</span><br><span class="line">               checkpointMetaData.getCheckpointId(),</span><br><span class="line">               e);</span><br><span class="line">         &#125;</span><br><span class="line">         handleExecutionException(e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         owner.cancelables.unregisterCloseable(this);</span><br><span class="line">         FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">private void reportCompletedSnapshotStates(</span><br><span class="line">			TaskStateSnapshot acknowledgedTaskStateSnapshot,</span><br><span class="line">			TaskStateSnapshot localTaskStateSnapshot,</span><br><span class="line">			long asyncDurationMillis) &#123;</span><br><span class="line"></span><br><span class="line">			TaskStateManager taskStateManager &#x3D; owner.getEnvironment().getTaskStateManager();</span><br><span class="line"></span><br><span class="line">			boolean hasAckState &#x3D; acknowledgedTaskStateSnapshot.hasState();</span><br><span class="line">			boolean hasLocalState &#x3D; localTaskStateSnapshot.hasState();</span><br><span class="line"></span><br><span class="line">			Preconditions.checkState(hasAckState || !hasLocalState,</span><br><span class="line">				&quot;Found cached state but no corresponding primary state is reported to the job &quot; +</span><br><span class="line">					&quot;manager. This indicates a problem.&quot;);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; we signal stateless tasks by reporting null, so that there are no attempts to assign empty state</span><br><span class="line">			&#x2F;&#x2F; to stateless tasks on restore. This enables simple job modifications that only concern</span><br><span class="line">			&#x2F;&#x2F; stateless without the need to assign them uids to match their (always empty) states.</span><br><span class="line">			taskStateManager.reportTaskStateSnapshots(</span><br><span class="line">				checkpointMetaData,</span><br><span class="line">				checkpointMetrics,</span><br><span class="line">				hasAckState ? acknowledgedTaskStateSnapshot : null,</span><br><span class="line">				hasLocalState ? localTaskStateSnapshot : null);</span><br><span class="line"></span><br><span class="line">			LOG.debug(&quot;&#123;&#125; - finished asynchronous part of checkpoint &#123;&#125;. Asynchronous duration: &#123;&#125; ms&quot;,</span><br><span class="line">				owner.getName(), checkpointMetaData.getCheckpointId(), asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">			LOG.trace(&quot;&#123;&#125; - reported the following states in snapshot for checkpoint &#123;&#125;: &#123;&#125;.&quot;,</span><br><span class="line">				owner.getName(), checkpointMetaData.getCheckpointId(), acknowledgedTaskStateSnapshot);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		TaskStateManager：</span><br><span class="line">public void reportTaskStateSnapshots(</span><br><span class="line">		@Nonnull CheckpointMetaData checkpointMetaData,</span><br><span class="line">		@Nonnull CheckpointMetrics checkpointMetrics,</span><br><span class="line">		@Nullable TaskStateSnapshot acknowledgedState,</span><br><span class="line">		@Nullable TaskStateSnapshot localState) &#123;</span><br><span class="line"></span><br><span class="line">		long checkpointId &#x3D; checkpointMetaData.getCheckpointId();</span><br><span class="line"></span><br><span class="line">		localStateStore.storeLocalState(checkpointId, localState);</span><br><span class="line">&#x2F;&#x2F;发送 ACK 响应给 CheckpointCoordinator</span><br><span class="line">		checkpointResponder.acknowledgeCheckpoint(</span><br><span class="line">			jobId,</span><br><span class="line">			executionAttemptID,</span><br><span class="line">			checkpointId,</span><br><span class="line">			checkpointMetrics,</span><br><span class="line">			acknowledgedState);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进行Checkpoint 的确认，<code>Task</code> 对 checkpoint 的响应是通过 <code>CheckpointResponder</code> 接口完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void acknowledgeCheckpoint(</span><br><span class="line">   JobID jobID,</span><br><span class="line">   ExecutionAttemptID executionAttemptID,</span><br><span class="line">   long checkpointId,</span><br><span class="line">   CheckpointMetrics checkpointMetrics,</span><br><span class="line">   TaskStateSnapshot subtaskState);</span><br></pre></td></tr></table></figure>

<p><code>RpcCheckpointResponder</code> 作为 <code>CheckpointResponder</code> 的具体实现，主要是通过 RPC 调用通知 <code>CheckpointCoordinatorGateway</code>，即通知给 <code>JobMaster</code>, <code>JobMaster</code> 调用 <code>CheckpointCoordinator.receiveAcknowledgeMessage()</code> 和 <code>CheckpointCoordinator.receiveDeclineMessage()</code> 进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(</span><br><span class="line">      JobID jobID,</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      long checkpointId,</span><br><span class="line">      CheckpointMetrics checkpointMetrics,</span><br><span class="line">      TaskStateSnapshot subtaskState) &#123;</span><br><span class="line"></span><br><span class="line">   checkpointCoordinatorGateway.acknowledgeCheckpoint(</span><br><span class="line">      jobID,</span><br><span class="line">      executionAttemptID,</span><br><span class="line">      checkpointId,</span><br><span class="line">      checkpointMetrics,</span><br><span class="line">      subtaskState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(</span><br><span class="line">      final JobID jobID,</span><br><span class="line">      final ExecutionAttemptID executionAttemptID,</span><br><span class="line">      final long checkpointId,</span><br><span class="line">      final CheckpointMetrics checkpointMetrics,</span><br><span class="line">      final TaskStateSnapshot checkpointState) &#123;</span><br><span class="line"></span><br><span class="line">   schedulerNG.acknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SchedulerBase实现SchedulerNG接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(final JobID jobID, final ExecutionAttemptID executionAttemptID, final long checkpointId, final CheckpointMetrics checkpointMetrics, final TaskStateSnapshot checkpointState) &#123;</span><br><span class="line">   mainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取CheckpointCoordinator</span><br><span class="line">   final CheckpointCoordinator checkpointCoordinator &#x3D; executionGraph.getCheckpointCoordinator();</span><br><span class="line">   &#x2F;&#x2F;Checkpoint的确定Message</span><br><span class="line">   final AcknowledgeCheckpoint ackMessage &#x3D; new AcknowledgeCheckpoint(</span><br><span class="line">      jobID,</span><br><span class="line">      executionAttemptID,</span><br><span class="line">      checkpointId,</span><br><span class="line">      checkpointMetrics,</span><br><span class="line">      checkpointState);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取发送checkpoint完成信息的TaskManager的Location</span><br><span class="line">   final String taskManagerLocationInfo &#x3D; retrieveTaskManagerLocation(executionAttemptID);</span><br><span class="line"></span><br><span class="line">   if (checkpointCoordinator !&#x3D; null) &#123;</span><br><span class="line">      ioExecutor.execute(() -&gt; &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            checkpointCoordinator.receiveAcknowledgeMessage(ackMessage, taskManagerLocationInfo);</span><br><span class="line">         &#125; catch (Throwable t) &#123;</span><br><span class="line">            log.warn(&quot;Error while processing checkpoint acknowledgement message&quot;, t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      String errorMessage &#x3D; &quot;Received AcknowledgeCheckpoint message for job &#123;&#125; with no CheckpointCoordinator&quot;;</span><br><span class="line">      if (executionGraph.getState() &#x3D;&#x3D; JobStatus.RUNNING) &#123;</span><br><span class="line">         log.error(errorMessage, jobGraph.getJobID());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         log.debug(errorMessage, jobGraph.getJobID());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator的receiveAcknowledgeMessage接收来自Task的确认消息</p>
<p>在一个 <code>Task</code> 完成 checkpoint 操作后，<code>CheckpointCoordinator</code> 接收到 Ack 响应，对 Ack 响应的处理流程主要如下：</p>
<ul>
<li><p>根据 Ack 的 checkpointID 从 <code>Map pendingCheckpoints</code> 中查找对应的 <code>PendingCheckpoint</code></p>
</li>
<li><p>若存在对应的</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>

<ul>
<li>这个</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>



没有被丢弃，调用



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint.acknowledgeTask</span><br></pre></td></tr></table></figure>



方法处理 Ack，根据处理结果的不同：

- SUCCESS：判断是否已经接受了所有需要响应的 Ack，如果是，则调用 `completePendingCheckpoint` 完成此次 checkpoint
- DUPLICATE：Ack 消息重复接收，直接忽略
- UNKNOWN：未知的 Ack 消息，清理上报的 Ack 中携带的状态句柄
- DISCARD：Checkpoint 已经被 discard，清理上报的 Ack 中携带的状态句柄</code></pre><ul>
<li>这个 <code>PendingCheckpoint</code> 已经被丢弃，抛出异常</li>
</ul>
<ul>
<li>若不存在对应的 <code>PendingCheckpoint</code>，则清理上报的 Ack 中携带的状态句柄</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message, String taskManagerLocationInfo) throws CheckpointException &#123;</span><br><span class="line">   if (shutdown || message &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!job.equals(message.getJob())) &#123;</span><br><span class="line">      LOG.error(&quot;Received wrong AcknowledgeCheckpoint message for job &#123;&#125; from &#123;&#125; : &#123;&#125;&quot;, job, taskManagerLocationInfo, message);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long checkpointId &#x3D; message.getCheckpointId();</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      &#x2F;&#x2F; we need to check inside the lock for being shutdown as well, otherwise we</span><br><span class="line">      &#x2F;&#x2F; get races and invalid error log messages</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final PendingCheckpoint checkpoint &#x3D; pendingCheckpoints.get(checkpointId);</span><br><span class="line"></span><br><span class="line">      if (checkpoint !&#x3D; null &amp;&amp; !checkpoint.isDiscarded()) &#123;</span><br><span class="line"></span><br><span class="line">         switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">               LOG.debug(&quot;Received acknowledge message for checkpoint &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               if (checkpoint.areTasksFullyAcknowledged()) &#123;</span><br><span class="line">                  completePendingCheckpoint(checkpoint);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">            case DUPLICATE:</span><br><span class="line">               LOG.debug(&quot;Received a duplicate acknowledge message for checkpoint &#123;&#125;, task &#123;&#125;, job &#123;&#125;, location &#123;&#125;.&quot;,</span><br><span class="line">                  message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">               break;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">               LOG.warn(&quot;Could not acknowledge the checkpoint &#123;&#125; for task &#123;&#125; of job &#123;&#125; at &#123;&#125;, &quot; +</span><br><span class="line">                     &quot;because the task&#39;s execution attempt id was unknown. Discarding &quot; +</span><br><span class="line">                     &quot;the state handle to avoid lingering state.&quot;, message.getCheckpointId(),</span><br><span class="line">                  message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line"></span><br><span class="line">               break;</span><br><span class="line">            case DISCARDED:</span><br><span class="line">               LOG.warn(&quot;Could not acknowledge the checkpoint &#123;&#125; for task &#123;&#125; of job &#123;&#125; at &#123;&#125;, &quot; +</span><br><span class="line">                  &quot;because the pending checkpoint had been discarded. Discarding the &quot; +</span><br><span class="line">                     &quot;state handle tp avoid lingering state.&quot;,</span><br><span class="line">                  message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (checkpoint !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; this should not happen</span><br><span class="line">         throw new IllegalStateException(</span><br><span class="line">               &quot;Received message for discarded but non-removed checkpoint &quot; + checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         boolean wasPendingCheckpoint;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; message is for an unknown checkpoint, or comes too late (checkpoint disposed)</span><br><span class="line">         if (recentPendingCheckpoints.contains(checkpointId)) &#123;</span><br><span class="line">            wasPendingCheckpoint &#x3D; true;</span><br><span class="line">            LOG.warn(&quot;Received late message for now expired checkpoint attempt &#123;&#125; from task &quot; +</span><br><span class="line">               &quot;&#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;, checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            LOG.debug(&quot;Received message for an unknown checkpoint &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">               checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">            wasPendingCheckpoint &#x3D; false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; try to discard the state so that we don&#39;t have lingering state lying around</span><br><span class="line">         discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line"></span><br><span class="line">         return wasPendingCheckpoint;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>一旦 <code>PendingCheckpoint</code> 确认所有 Ack 消息都已经接收，那么就可以完成此次 checkpoint 了，具体包括：</p>
<ul>
<li><p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint.finalizeCheckpoint()</span><br></pre></td></tr></table></figure>

<p>将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>

<p>转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpoint</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 <code>CheckpointMetadataOutputStream</code>，将所有的状态句柄信息通过 <code>CheckpointMetadataOutputStream</code> 写入到存储系统中</li>
<li>创建一个 <code>CompletedCheckpoint</code> 对象</li>
</ul>
</li>
<li><p>将</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpoint</span><br></pre></td></tr></table></figure>



<p>  保存到</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpointStore</span><br></pre></td></tr></table></figure>



<p>  中</p>
<ul>
<li><code>CompletedCheckpointStore</code> 有两种实现，分别为 <code>StandaloneCompletedCheckpointStore</code> 和 <code>ZooKeeperCompletedCheckpointStore</code></li>
<li><code>StandaloneCompletedCheckpointStore</code> 简单地将 <code>CompletedCheckpointStore</code> 存放在一个数组中</li>
<li><code>ZooKeeperCompletedCheckpointStore</code> 提供高可用实现：先将 <code>CompletedCheckpointStore</code> 写入到 <code>RetrievableStateStorageHelper</code> 中（通常是文件系统），然后将文件句柄存在 ZK 中</li>
<li>保存的 <code>CompletedCheckpointStore</code> 数量是有限的，会删除旧的快照</li>
</ul>
<ul>
<li><p>移除被越过的 <code>PendingCheckpoint</code>，因为 <code>CheckpointID</code> 是递增的，那么所有比当前完成的 <code>CheckpointID</code> 小的 <code>PendingCheckpoint</code> 都可以被丢弃了</p>
</li>
<li><p>依次调用</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution.notifyCheckpointComplete()</span><br></pre></td></tr></table></figure>



<p>  通知所有的 Task 当前 Checkpoint 已经完成</p>
<ul>
<li>通过 RPC 调用 <code>TaskExecutor.confirmCheckpoint()</code> 告知对应的 Task</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException &#123;</span><br><span class="line">   final long checkpointId &#x3D; pendingCheckpoint.getCheckpointId();</span><br><span class="line">   final CompletedCheckpoint completedCheckpoint;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; As a first step to complete the checkpoint, we register its state with the registry</span><br><span class="line">   Map&lt;OperatorID, OperatorState&gt; operatorStates &#x3D; pendingCheckpoint.getOperatorStates();</span><br><span class="line">   sharedStateRegistry.registerAll(operatorStates.values());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         completedCheckpoint &#x3D; pendingCheckpoint.finalizeCheckpoint();</span><br><span class="line">         failureManager.handleCheckpointSuccess(pendingCheckpoint.getCheckpointId());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e1) &#123;</span><br><span class="line">         &#x2F;&#x2F; abort the current pending checkpoint if we fails to finalize the pending checkpoint.</span><br><span class="line">         if (!pendingCheckpoint.isDiscarded()) &#123;</span><br><span class="line">            failPendingCheckpoint(pendingCheckpoint, CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         throw new CheckpointException(&quot;Could not finalize the pending checkpoint &quot; + checkpointId + &#39;.&#39;,</span><br><span class="line">            CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; the pending checkpoint must be discarded after the finalization</span><br><span class="line">      Preconditions.checkState(pendingCheckpoint.isDiscarded() &amp;&amp; completedCheckpoint !&#x3D; null);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         completedCheckpointStore.addCheckpoint(completedCheckpoint);</span><br><span class="line">      &#125; catch (Exception exception) &#123;</span><br><span class="line">         &#x2F;&#x2F; we failed to store the completed checkpoint. Let&#39;s clean up</span><br><span class="line">         executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                  completedCheckpoint.discardOnFailedStoring();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                  LOG.warn(&quot;Could not properly discard completed checkpoint &#123;&#125;.&quot;, completedCheckpoint.getCheckpointID(), t);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         throw new CheckpointException(&quot;Could not complete the pending checkpoint &quot; + checkpointId + &#39;.&#39;,</span><br><span class="line">            CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, exception);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      pendingCheckpoints.remove(checkpointId);</span><br><span class="line"></span><br><span class="line">      triggerQueuedRequests();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rememberRecentCheckpointId(checkpointId);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; drop those pending checkpoints that are at prior to the completed one</span><br><span class="line">   dropSubsumedCheckpoints(checkpointId);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; record the time when this was completed, to calculate</span><br><span class="line">   &#x2F;&#x2F; the &#39;min delay between checkpoints&#39;</span><br><span class="line">   lastCheckpointCompletionRelativeTime &#x3D; clock.relativeTimeMillis();</span><br><span class="line"></span><br><span class="line">   LOG.info(&quot;Completed checkpoint &#123;&#125; for job &#123;&#125; (&#123;&#125; bytes in &#123;&#125; ms).&quot;, checkpointId, job,</span><br><span class="line">      completedCheckpoint.getStateSize(), completedCheckpoint.getDuration());</span><br><span class="line"></span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">      builder.append(&quot;Checkpoint state: &quot;);</span><br><span class="line">      for (OperatorState state : completedCheckpoint.getOperatorStates().values()) &#123;</span><br><span class="line">         builder.append(state);</span><br><span class="line">         builder.append(&quot;, &quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Remove last two chars &quot;, &quot;</span><br><span class="line">      builder.setLength(builder.length() - 2);</span><br><span class="line"></span><br><span class="line">      LOG.debug(builder.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; send the &quot;notify complete&quot; call to all vertices</span><br><span class="line">   final long timestamp &#x3D; completedCheckpoint.getTimestamp();</span><br><span class="line"></span><br><span class="line">   for (ExecutionVertex ev : tasksToCommitTo) &#123;</span><br><span class="line">      Execution ee &#x3D; ev.getCurrentExecutionAttempt();</span><br><span class="line">      if (ee !&#x3D; null) &#123;</span><br><span class="line">         ee.notifyCheckpointComplete(checkpointId, timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个已经触发但还没有完成的 checkpoint，即 <code>PendingCheckpoint</code>，它是如何处理 Ack 消息的呢？在 <code>PendingCheckpoint</code> 内部维护了两个 Map，分别是：</p>
<ul>
<li><code>Map operatorStates;</code> : 已经接收到 Ack 的算子的状态句柄</li>
<li><code>Map notYetAcknowledgedTasks;</code>: 需要 Ack 但还没有接收到的 Task</li>
</ul>
<p>每当接收到一个 Ack 消息时，<code>PendingCheckpoint</code> 就从 <code>notYetAcknowledgedTasks</code> 中移除对应的 Task，并保存 Ack 携带的状态句柄保存。当 <code>notYetAcknowledgedTasks</code> 为空时，表明所有的 Ack 消息都接收到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PendingCheckpoint &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Result of the &#123;@link PendingCheckpoint#acknowledgedTasks&#125; method.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public enum TaskAcknowledgeResult &#123;</span><br><span class="line">      SUCCESS, &#x2F;&#x2F; successful acknowledge of the task</span><br><span class="line">      DUPLICATE, &#x2F;&#x2F; acknowledge message is a duplicate</span><br><span class="line">      UNKNOWN, &#x2F;&#x2F; unknown task acknowledged</span><br><span class="line">      DISCARDED &#x2F;&#x2F; pending checkpoint has been discarded</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** The PendingCheckpoint logs to the same logger as the CheckpointCoordinator. *&#x2F;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(CheckpointCoordinator.class);</span><br><span class="line"></span><br><span class="line">   private final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">   private final JobID jobId;</span><br><span class="line"></span><br><span class="line">   private final long checkpointId;</span><br><span class="line"></span><br><span class="line">   private final long checkpointTimestamp;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;OperatorID, OperatorState&gt; operatorStates;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;ExecutionAttemptID, ExecutionVertex&gt; notYetAcknowledgedTasks;</span><br><span class="line"></span><br><span class="line">   private final List&lt;MasterState&gt; masterStates;</span><br><span class="line"></span><br><span class="line">   private final Set&lt;String&gt; notYetAcknowledgedMasterStates;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Set of acknowledged tasks. *&#x2F;</span><br><span class="line">   private final Set&lt;ExecutionAttemptID&gt; acknowledgedTasks;</span><br></pre></td></tr></table></figure>

<p>其中 <code>OperatorState</code> 是算子状态句柄的一层封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorState implements CompositeStateHandle &#123;</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; -4845578005863201810L;</span><br><span class="line"></span><br><span class="line">   &#x2F;** id of the operator *&#x2F;</span><br><span class="line">   private final OperatorID operatorID;</span><br><span class="line"></span><br><span class="line">   &#x2F;** handles to non-partitioned states, subtaskindex -&gt; subtaskstate *&#x2F;</span><br><span class="line">   private final Map&lt;Integer, OperatorSubtaskState&gt; operatorSubtaskStates;</span><br><span class="line"></span><br><span class="line">   &#x2F;** parallelism of the operator when it was checkpointed *&#x2F;</span><br><span class="line">   private final int parallelism;</span><br><span class="line"></span><br><span class="line">   &#x2F;** maximum parallelism of the operator when the job was first created *&#x2F;</span><br><span class="line">   private final int maxParallelism;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorSubtaskState implements CompositeStateHandle &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(OperatorSubtaskState.class);</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; -2394696997971923995L;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot from the &#123;@link org.apache.flink.runtime.state.OperatorStateBackend&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;OperatorStateHandle&gt; managedOperatorState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot written using &#123;@link org.apache.flink.runtime.state.OperatorStateCheckpointOutputStream&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;OperatorStateHandle&gt; rawOperatorState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot from &#123;@link org.apache.flink.runtime.state.KeyedStateBackend&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;KeyedStateHandle&gt; managedKeyedState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot written using &#123;@link org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;KeyedStateHandle&gt; rawKeyedState;</span><br></pre></td></tr></table></figure>

<p>在 Task 进行 checkpoint 的过程，可能会发生异常导致 checkpoint 失败，在这种情况下会通过 <code>CheckpointResponder</code> 发出回绝的消息。当 <code>CheckpointCoordinator</code> 接收到 <code>DeclineCheckpoint</code> 消息后会移除 <code>PendingCheckpoint</code>，并尝试丢弃已经接收到的 Ack 消息中已完成的状态句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void receiveDeclineMessage(DeclineCheckpoint message, String taskManagerLocationInfo) &#123;</span><br><span class="line">   if (shutdown || message &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!job.equals(message.getJob())) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Received DeclineCheckpoint message for job &quot; +</span><br><span class="line">         message.getJob() + &quot; from &quot; + taskManagerLocationInfo + &quot; while this coordinator handles job &quot; + job);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long checkpointId &#x3D; message.getCheckpointId();</span><br><span class="line">   final String reason &#x3D; (message.getReason() !&#x3D; null ? message.getReason().getMessage() : &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   PendingCheckpoint checkpoint;</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      &#x2F;&#x2F; we need to check inside the lock for being shutdown as well, otherwise we</span><br><span class="line">      &#x2F;&#x2F; get races and invalid error log messages</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      checkpoint &#x3D; pendingCheckpoints.remove(checkpointId);</span><br><span class="line"></span><br><span class="line">      if (checkpoint !&#x3D; null &amp;&amp; !checkpoint.isDiscarded()) &#123;</span><br><span class="line">         LOG.info(&quot;Decline checkpoint &#123;&#125; by task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">            checkpointId,</span><br><span class="line">            message.getTaskExecutionId(),</span><br><span class="line">            job,</span><br><span class="line">            taskManagerLocationInfo);</span><br><span class="line">         discardCheckpoint(checkpoint, message.getReason(), message.getTaskExecutionId());</span><br><span class="line">      &#125;</span><br><span class="line">      else if (checkpoint !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; this should not happen</span><br><span class="line">         throw new IllegalStateException(</span><br><span class="line">               &quot;Received message for discarded but non-removed checkpoint &quot; + checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">         if (recentPendingCheckpoints.contains(checkpointId)) &#123;</span><br><span class="line">            &#x2F;&#x2F; message is for an unknown checkpoint, or comes too late (checkpoint disposed)</span><br><span class="line">            LOG.debug(&quot;Received another decline message for now expired checkpoint attempt &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125; : &#123;&#125;&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), job, taskManagerLocationInfo, reason);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; message is for an unknown checkpoint. might be so old that we don&#39;t even remember it any more</span><br><span class="line">            LOG.debug(&quot;Received decline message for unknown (too old?) checkpoint attempt &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125; : &#123;&#125;&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), job, taskManagerLocationInfo, reason);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Flink 作业失败重启或者从指定 SavePoint 启动时，需要将整个作业恢复到上一次成功 checkpoint 的状态。这里主要分为两个阶段：</p>
<ul>
<li><code>CheckpointCoordinator</code> 加载最近一次成功的 <code>CompletedCheckpoint</code>，并将状态重新分配到不同的 <code>Execution</code>（<code>Task</code>）中</li>
<li><code>Task</code> 启动时进行状态初始化</li>
</ul>
<p>首先，<code>JobMaster</code> 在创建 <code>ExecutionGraph</code> 后会尝试恢复状态到最近一次成功的 checkpoint，或者加载 SavePoint，最终都会调用 <code>CheckpointCoordinator.restoreLatestCheckpointedState()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">JobMaster:</span><br><span class="line">private SchedulerNG createScheduler(final JobManagerJobMetricGroup jobManagerJobMetricGroup) throws Exception &#123;</span><br><span class="line">   return schedulerNGFactory.createInstance(</span><br><span class="line">      log,</span><br><span class="line">      jobGraph,</span><br><span class="line">      backPressureStatsTracker,</span><br><span class="line">      scheduledExecutorService,</span><br><span class="line">      jobMasterConfiguration.getConfiguration(),</span><br><span class="line">      scheduler,</span><br><span class="line">      scheduledExecutorService,</span><br><span class="line">      userCodeLoader,</span><br><span class="line">      highAvailabilityServices.getCheckpointRecoveryFactory(),</span><br><span class="line">      rpcTimeout,</span><br><span class="line">      blobWriter,</span><br><span class="line">      jobManagerJobMetricGroup,</span><br><span class="line">      jobMasterConfiguration.getSlotRequestTimeout(),</span><br><span class="line">      shuffleMaster,</span><br><span class="line">      partitionTracker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SchedulerBase:</span><br><span class="line">private ExecutionGraph createAndRestoreExecutionGraph(</span><br><span class="line">		JobManagerJobMetricGroup currentJobManagerJobMetricGroup,</span><br><span class="line">		ShuffleMaster&lt;?&gt; shuffleMaster,</span><br><span class="line">		JobMasterPartitionTracker partitionTracker) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		ExecutionGraph newExecutionGraph &#x3D; createExecutionGraph(currentJobManagerJobMetricGroup, shuffleMaster, partitionTracker);</span><br><span class="line"></span><br><span class="line">		final CheckpointCoordinator checkpointCoordinator &#x3D; newExecutionGraph.getCheckpointCoordinator();</span><br><span class="line"></span><br><span class="line">		if (checkpointCoordinator !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F; check whether we find a valid checkpoint</span><br><span class="line">			if (!checkpointCoordinator.restoreLatestCheckpointedState(</span><br><span class="line">				new HashSet&lt;&gt;(newExecutionGraph.getAllVertices().values()),</span><br><span class="line">				false,</span><br><span class="line">				false)) &#123;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; check whether we can restore from a savepoint</span><br><span class="line">				tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return newExecutionGraph;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator.restoreLatestCheckpointedState()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public boolean restoreLatestCheckpointedState(</span><br><span class="line">      final Set&lt;ExecutionJobVertex&gt; tasks,</span><br><span class="line">      final boolean errorIfNoCheckpoint,</span><br><span class="line">      final boolean allowNonRestoredState) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;CheckpointCoordinator is shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; We create a new shared state registry object, so that all pending async disposal requests from previous</span><br><span class="line">      &#x2F;&#x2F; runs will go against the old object (were they can do no harm).</span><br><span class="line">      &#x2F;&#x2F; This must happen under the checkpoint lock.</span><br><span class="line">      sharedStateRegistry.close();</span><br><span class="line">      sharedStateRegistry &#x3D; sharedStateRegistryFactory.create(executor);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Recover the checkpoints, TODO this could be done only when there is a new leader, not on each recovery</span><br><span class="line">      completedCheckpointStore.recover();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Now, we re-register all (shared) states from the checkpoint store with the new registry</span><br><span class="line">      for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) &#123;</span><br><span class="line">         completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;Status of the shared state registry of job &#123;&#125; after restore: &#123;&#125;.&quot;, job, sharedStateRegistry);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Restore from the latest checkpoint</span><br><span class="line">      CompletedCheckpoint latest &#x3D; completedCheckpointStore.getLatestCheckpoint(isPreferCheckpointForRecovery);</span><br><span class="line"></span><br><span class="line">      if (latest &#x3D;&#x3D; null) &#123;</span><br><span class="line">         if (errorIfNoCheckpoint) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No completed checkpoint available&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;Resetting the master hooks.&quot;);</span><br><span class="line">            MasterHooks.reset(masterHooks.values(), LOG);</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.info(&quot;Restoring job &#123;&#125; from latest valid checkpoint: &#123;&#125;.&quot;, job, latest);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; re-assign the task states</span><br><span class="line">      final Map&lt;OperatorID, OperatorState&gt; operatorStates &#x3D; latest.getOperatorStates();</span><br><span class="line"></span><br><span class="line">      StateAssignmentOperation stateAssignmentOperation &#x3D;</span><br><span class="line">            new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState);</span><br><span class="line"></span><br><span class="line">      stateAssignmentOperation.assignStates();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; call master hooks for restore</span><br><span class="line"></span><br><span class="line">      MasterHooks.restoreMasterHooks(</span><br><span class="line">            masterHooks,</span><br><span class="line">            latest.getMasterHookStates(),</span><br><span class="line">            latest.getCheckpointID(),</span><br><span class="line">            allowNonRestoredState,</span><br><span class="line">            LOG);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; update metrics</span><br><span class="line"></span><br><span class="line">      if (statsTracker !&#x3D; null) &#123;</span><br><span class="line">         long restoreTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">         RestoredCheckpointStats restored &#x3D; new RestoredCheckpointStats(</span><br><span class="line">            latest.getCheckpointID(),</span><br><span class="line">            latest.getProperties(),</span><br><span class="line">            restoreTimestamp,</span><br><span class="line">            latest.getExternalPointer());</span><br><span class="line"></span><br><span class="line">         statsTracker.reportRestoredCheckpoint(restored);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态的分配过程被封装在 <code>StateAssignmentOperation</code> 中。在状态恢复的过程中，假如任务的并行度发生变化，那么每个子任务的状态和先前必然是不一致的，这其中就涉及到状态的平均重新分配问题，关于状态分配的细节，可以参考 Flink 团队的博文 <a href="https://flink.apache.org/features/2017/07/04/flink-rescalable-state.html#reassigning-operator-state-when-rescaling" target="_blank" rel="noopener">A Deep Dive into Rescalable State in Apache Flink</a>，里面给出了 operator state 和 keyed state 重新分配的详细介绍。</p>
<p>最终，每个 <code>Task</code> 分配的状态被封装在 <code>JobManagerTaskRestore</code> 中，并通过 <code>Execution.setInitialState()</code> 关联到 <code>Execution</code> 中。<code>JobManagerTaskRestore</code> 回作为 <code>TaskDeploymentDescriptor</code> 的一个属性下发到 <code>TaskExecutor</code> 中。</p>
<p>当 <code>TaskDeploymentDescriptor</code> 被提交给 <code>TaskExecutor</code> 之后，<code>TaskExecutor</code> 会 <code>TaskStateManager</code> 用于管理当前 <code>Task</code> 的状态，<code>TaskStateManager</code> 对象会基于分配的 <code>JobManagerTaskRestore</code> 和本地状态存储 <code>TaskLocalStateStore</code> 进行创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; submitTask(</span><br><span class="line">      TaskDeploymentDescriptor tdd,</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      Time timeout) &#123;</span><br><span class="line">......</span><br><span class="line">   &#x2F;&#x2F;本地状态存储</span><br><span class="line">      final TaskLocalStateStore localStateStore &#x3D; localStateStoresManager.localStateStoreForSubtask(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getSubtaskIndex());</span><br><span class="line">&#x2F;&#x2F;由 JobManager 分配的用于恢复的状态</span><br><span class="line">      final JobManagerTaskRestore taskRestore &#x3D; tdd.getTaskRestore();</span><br><span class="line">&#x2F;&#x2F;创建 TaskStateManager</span><br><span class="line">      final TaskStateManager taskStateManager &#x3D; new TaskStateManagerImpl(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         localStateStore,</span><br><span class="line">         taskRestore,</span><br><span class="line">         checkpointResponder);</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Task</code> 启动后，<code>StreamTask</code> 会先调用 <code>initializeState</code> 方法，这样每一个算子都会调用 <code>StreamOperator.initializeState()</code> 进行状态的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">StreamTask:</span><br><span class="line">private void initializeStateAndOpen() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   StreamOperator&lt;?&gt;[] allOperators &#x3D; operatorChain.getAllOperators();</span><br><span class="line"></span><br><span class="line">   for (StreamOperator&lt;?&gt; operator : allOperators) &#123;</span><br><span class="line">      if (null !&#x3D; operator) &#123;</span><br><span class="line">         operator.initializeState();</span><br><span class="line">         operator.open();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStreamOperator:</span><br><span class="line">public final void initializeState() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		final TypeSerializer&lt;?&gt; keySerializer &#x3D; config.getStateKeySerializer(getUserCodeClassloader());</span><br><span class="line"></span><br><span class="line">		final StreamTask&lt;?, ?&gt; containingTask &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(getContainingTask());</span><br><span class="line">		final CloseableRegistry streamTaskCloseableRegistry &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(containingTask.getCancelables());</span><br><span class="line">		final StreamTaskStateInitializer streamTaskStateManager &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(containingTask.createStreamTaskStateInitializer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 StreamOperatorStateContext，这一步会进行状态的恢复，</span><br><span class="line">		&#x2F;&#x2F;这样 operatorStateBackend 和 keyedStateBackend 就可以恢复到到最后一次 checkpoint 的状态</span><br><span class="line">		&#x2F;&#x2F;timeServiceManager 也会恢复</span><br><span class="line">		final StreamOperatorStateContext context &#x3D;</span><br><span class="line">			streamTaskStateManager.streamOperatorStateContext(</span><br><span class="line">				getOperatorID(),</span><br><span class="line">				getClass().getSimpleName(),</span><br><span class="line">				getProcessingTimeService(),</span><br><span class="line">				this,</span><br><span class="line">				keySerializer,</span><br><span class="line">				streamTaskCloseableRegistry,</span><br><span class="line">				metrics);</span><br><span class="line"></span><br><span class="line">		this.operatorStateBackend &#x3D; context.operatorStateBackend();</span><br><span class="line">		this.keyedStateBackend &#x3D; context.keyedStateBackend();</span><br><span class="line"></span><br><span class="line">		if (keyedStateBackend !&#x3D; null) &#123;</span><br><span class="line">			this.keyedStateStore &#x3D; new DefaultKeyedStateStore(keyedStateBackend, getExecutionConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		timeServiceManager &#x3D; context.internalTimerServiceManager();</span><br><span class="line"></span><br><span class="line">		CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; keyedStateInputs &#x3D; context.rawKeyedStateInputs();</span><br><span class="line">		CloseableIterable&lt;StatePartitionStreamProvider&gt; operatorStateInputs &#x3D; context.rawOperatorStateInputs();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;StateInitializationContext 对外暴露了 state backend，timer service manager 等，operator 可以借助它来进行状态初始化</span><br><span class="line">			StateInitializationContext initializationContext &#x3D; new StateInitializationContextImpl(</span><br><span class="line">				context.isRestored(), &#x2F;&#x2F; information whether we restore or start for the first time</span><br><span class="line">				operatorStateBackend, &#x2F;&#x2F; access to operator state backend</span><br><span class="line">				keyedStateStore, &#x2F;&#x2F; access to keyed state backend</span><br><span class="line">				keyedStateInputs, &#x2F;&#x2F; access to keyed state stream</span><br><span class="line">				operatorStateInputs); &#x2F;&#x2F; access to operator state stream</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进行状态初始化，在子类中实现，比如调用 UDF 的状态初始化方法</span><br><span class="line">			initializeState(initializationContext);</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			closeFromRegistry(operatorStateInputs, streamTaskCloseableRegistry);</span><br><span class="line">			closeFromRegistry(keyedStateInputs, streamTaskCloseableRegistry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">public void initializeState(StateInitializationContext context) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">AbstractUdfStreamOperator:</span><br><span class="line">public void initializeState(StateInitializationContext context) throws Exception &#123;</span><br><span class="line">		super.initializeState(context);</span><br><span class="line">		StreamingFunctionUtils.restoreFunctionState(context, userFunction);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>状态恢复的关键操作在于通过 <code>StreamTaskStateInitializer.streamOperatorStateContext()</code> 生成 <code>StreamOperatorStateContext</code>, 通过 <code>StreamOperatorStateContext</code> 可以获取 state backend，timer service manager 等：</p>
<p>streamTaskStateManager.streamOperatorStateContext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">StreamTaskStateInitializer:</span><br><span class="line">StreamOperatorStateContext streamOperatorStateContext(</span><br><span class="line">   @Nonnull OperatorID operatorID,</span><br><span class="line">   @Nonnull String operatorClassName,</span><br><span class="line">   @Nonnull ProcessingTimeService processingTimeService,</span><br><span class="line">   @Nonnull KeyContext keyContext,</span><br><span class="line">   @Nullable TypeSerializer&lt;?&gt; keySerializer,</span><br><span class="line">   @Nonnull CloseableRegistry streamTaskCloseableRegistry,</span><br><span class="line">   @Nonnull MetricGroup metricGroup) throws Exception;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> public interface StreamOperatorStateContext &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns true, the states provided by this context are restored from a checkpoint&#x2F;savepoint.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	boolean isRestored();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the operator state backend for the stream operator.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	OperatorStateBackend operatorStateBackend();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the keyed state backend for the stream operator. This method returns null for non-keyed operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	AbstractKeyedStateBackend&lt;?&gt; keyedStateBackend();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the internal timer service manager for the stream operator. This method returns null for non-keyed</span><br><span class="line">	 * operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	InternalTimeServiceManager&lt;?&gt; internalTimerServiceManager();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns an iterable to obtain input streams for previously stored operator state partitions that are assigned to</span><br><span class="line">	 * this stream operator.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	CloseableIterable&lt;StatePartitionStreamProvider&gt; rawOperatorStateInputs();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns an iterable to obtain input streams for previously stored keyed state partitions that are assigned to</span><br><span class="line">	 * this operator. This method returns null for non-keyed operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; rawKeyedStateInputs();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StreamTaskStateInitializerImpl实现了StreamTaskStateInitializer接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public StreamOperatorStateContext streamOperatorStateContext(</span><br><span class="line">   @Nonnull OperatorID operatorID,</span><br><span class="line">   @Nonnull String operatorClassName,</span><br><span class="line">   @Nonnull ProcessingTimeService processingTimeService,</span><br><span class="line">   @Nonnull KeyContext keyContext,</span><br><span class="line">   @Nullable TypeSerializer&lt;?&gt; keySerializer,</span><br><span class="line">   @Nonnull CloseableRegistry streamTaskCloseableRegistry,</span><br><span class="line">   @Nonnull MetricGroup metricGroup) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   TaskInfo taskInfo &#x3D; environment.getTaskInfo();</span><br><span class="line">   OperatorSubtaskDescriptionText operatorSubtaskDescription &#x3D;</span><br><span class="line">      new OperatorSubtaskDescriptionText(</span><br><span class="line">         operatorID,</span><br><span class="line">         operatorClassName,</span><br><span class="line">         taskInfo.getIndexOfThisSubtask(),</span><br><span class="line">         taskInfo.getNumberOfParallelSubtasks());</span><br><span class="line"></span><br><span class="line">   final String operatorIdentifierText &#x3D; operatorSubtaskDescription.toString();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先获取用于恢复状态的 PrioritizedOperatorSubtaskState</span><br><span class="line">   final PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates &#x3D;</span><br><span class="line">      taskStateManager.prioritizedOperatorState(operatorID);</span><br><span class="line"></span><br><span class="line">   AbstractKeyedStateBackend&lt;?&gt; keyedStatedBackend &#x3D; null;</span><br><span class="line">   OperatorStateBackend operatorStateBackend &#x3D; null;</span><br><span class="line">   CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; rawKeyedStateInputs &#x3D; null;</span><br><span class="line">   CloseableIterable&lt;StatePartitionStreamProvider&gt; rawOperatorStateInputs &#x3D; null;</span><br><span class="line">   InternalTimeServiceManager&lt;?&gt; timeServiceManager;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Keyed State Backend --------------</span><br><span class="line">      keyedStatedBackend &#x3D; keyedStatedBackend(</span><br><span class="line">         keySerializer,</span><br><span class="line">         operatorIdentifierText,</span><br><span class="line">         prioritizedOperatorSubtaskStates,</span><br><span class="line">         streamTaskCloseableRegistry,</span><br><span class="line">         metricGroup);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Operator State Backend --------------</span><br><span class="line">      operatorStateBackend &#x3D; operatorStateBackend(</span><br><span class="line">         operatorIdentifierText,</span><br><span class="line">         prioritizedOperatorSubtaskStates,</span><br><span class="line">         streamTaskCloseableRegistry);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Raw State Streams --------------</span><br><span class="line">      rawKeyedStateInputs &#x3D; rawKeyedStateInputs(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedRawKeyedState().iterator());</span><br><span class="line">      streamTaskCloseableRegistry.registerCloseable(rawKeyedStateInputs);</span><br><span class="line"></span><br><span class="line">      rawOperatorStateInputs &#x3D; rawOperatorStateInputs(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedRawOperatorState().iterator());</span><br><span class="line">      streamTaskCloseableRegistry.registerCloseable(rawOperatorStateInputs);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Internal Timer Service Manager --------------</span><br><span class="line">      timeServiceManager &#x3D; internalTimeServiceManager(keyedStatedBackend, keyContext, processingTimeService, rawKeyedStateInputs);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Preparing return value --------------</span><br><span class="line"></span><br><span class="line">      return new StreamOperatorStateContextImpl(</span><br><span class="line">         prioritizedOperatorSubtaskStates.isRestored(),</span><br><span class="line">         operatorStateBackend,</span><br><span class="line">         keyedStatedBackend,</span><br><span class="line">         timeServiceManager,</span><br><span class="line">         rawOperatorStateInputs,</span><br><span class="line">         rawKeyedStateInputs);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态恢复和创建创建 state backend 耦合在一起，借助 <code>BackendRestorerProcedure</code> 来完成，具体的逻辑在 <code>BackendRestorerProcedure.createAndRestore</code> 方法中。</p>
<p>以operatorStateBackend为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected OperatorStateBackend operatorStateBackend(</span><br><span class="line">   String operatorIdentifierText,</span><br><span class="line">   PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates,</span><br><span class="line">   CloseableRegistry backendCloseableRegistry) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   String logDescription &#x3D; &quot;operator state backend for &quot; + operatorIdentifierText;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Now restore processing is included in backend building&#x2F;constructing process, so we need to make sure</span><br><span class="line">   &#x2F;&#x2F; each stream constructed in restore could also be closed in case of task cancel, for example the data</span><br><span class="line">   &#x2F;&#x2F; input stream opened for serDe during restore.</span><br><span class="line">   CloseableRegistry cancelStreamRegistryForRestore &#x3D; new CloseableRegistry();</span><br><span class="line">   backendCloseableRegistry.registerCloseable(cancelStreamRegistryForRestore);</span><br><span class="line">   BackendRestorerProcedure&lt;OperatorStateBackend, OperatorStateHandle&gt; backendRestorer &#x3D;</span><br><span class="line">      new BackendRestorerProcedure&lt;&gt;(</span><br><span class="line">         (stateHandles) -&gt; stateBackend.createOperatorStateBackend(</span><br><span class="line">            environment,</span><br><span class="line">            operatorIdentifierText,</span><br><span class="line">            stateHandles,</span><br><span class="line">            cancelStreamRegistryForRestore),</span><br><span class="line">         backendCloseableRegistry,</span><br><span class="line">         logDescription);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建及恢复状态</span><br><span class="line">      return backendRestorer.createAndRestore(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedManagedOperatorState());</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      if (backendCloseableRegistry.unregisterCloseable(cancelStreamRegistryForRestore)) &#123;</span><br><span class="line">         IOUtils.closeQuietly(cancelStreamRegistryForRestore);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BackendRestorerProcedure的createAndRestore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public T createAndRestore(@Nonnull List&lt;? extends Collection&lt;S&gt;&gt; restoreOptions) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   if (restoreOptions.isEmpty()) &#123;</span><br><span class="line">      restoreOptions &#x3D; Collections.singletonList(Collections.emptyList());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int alternativeIdx &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   Exception collectedException &#x3D; null;</span><br><span class="line"></span><br><span class="line">   while (alternativeIdx &lt; restoreOptions.size()) &#123;</span><br><span class="line"></span><br><span class="line">      Collection&lt;S&gt; restoreState &#x3D; restoreOptions.get(alternativeIdx);</span><br><span class="line"></span><br><span class="line">      ++alternativeIdx;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; IMPORTANT: please be careful when modifying the log statements because they are used for validation in</span><br><span class="line">      &#x2F;&#x2F; the automatic end-to-end tests. Those tests might fail if they are not aligned with the log message!</span><br><span class="line">      if (restoreState.isEmpty()) &#123;</span><br><span class="line">         LOG.debug(&quot;Creating &#123;&#125; with empty state.&quot;, logDescription);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(&quot;Creating &#123;&#125; and restoring with state &#123;&#125; from alternative (&#123;&#125;&#x2F;&#123;&#125;).&quot;,</span><br><span class="line">               logDescription, restoreState, alternativeIdx, restoreOptions.size());</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;Creating &#123;&#125; and restoring with state from alternative (&#123;&#125;&#x2F;&#123;&#125;).&quot;,</span><br><span class="line">               logDescription, alternativeIdx, restoreOptions.size());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         return attemptCreateAndRestore(restoreState);</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">         collectedException &#x3D; ExceptionUtils.firstOrSuppressed(ex, collectedException);</span><br><span class="line"></span><br><span class="line">         LOG.warn(&quot;Exception while restoring &#123;&#125; from alternative (&#123;&#125;&#x2F;&#123;&#125;), will retry while more &quot; +</span><br><span class="line">            &quot;alternatives are available.&quot;, logDescription, alternativeIdx, restoreOptions.size(), ex);</span><br><span class="line"></span><br><span class="line">         if (backendCloseableRegistry.isClosed()) &#123;</span><br><span class="line">            throw new FlinkException(&quot;Stopping restore attempts for already cancelled task.&quot;, collectedException);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new FlinkException(&quot;Could not restore &quot; + logDescription + &quot; from any of the &quot; + restoreOptions.size() +</span><br><span class="line">      &quot; provided restore options.&quot;, collectedException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T attemptCreateAndRestore(Collection&lt;S&gt; restoreState) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create a new backend with necessary initialization.</span><br><span class="line">   &#x2F;&#x2F;创建及恢复状态</span><br><span class="line">   &#x2F;&#x2F;instanceSupplier有具体状态后端实现，就是StateBackend接口的createOperatorStateBackend方法</span><br><span class="line">   final T backendInstance &#x3D; instanceSupplier.apply(restoreState);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; register the backend with the registry to participate in task lifecycle w.r.t. cancellation.</span><br><span class="line">      backendCloseableRegistry.registerCloseable(backendInstance);</span><br><span class="line">      return backendInstance;</span><br><span class="line">   &#125; catch (Exception ex) &#123;</span><br><span class="line">      &#x2F;&#x2F; dispose the backend, e.g. to release native resources, if failed to register it into registry.</span><br><span class="line">      try &#123;</span><br><span class="line">         backendInstance.dispose();</span><br><span class="line">      &#125; catch (Exception disposeEx) &#123;</span><br><span class="line">         ex &#x3D; ExceptionUtils.firstOrSuppressed(disposeEx, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throw ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskStateManagerImpl的prioritizedOperatorState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public PrioritizedOperatorSubtaskState prioritizedOperatorState(OperatorID operatorID) &#123;</span><br><span class="line"></span><br><span class="line">   if (jobManagerTaskRestore &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return PrioritizedOperatorSubtaskState.emptyNotRestored();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;从 JobManager 获取的状态快照</span><br><span class="line">   TaskStateSnapshot jobManagerStateSnapshot &#x3D;</span><br><span class="line">      jobManagerTaskRestore.getTaskStateSnapshot();</span><br><span class="line"></span><br><span class="line">   OperatorSubtaskState jobManagerSubtaskState &#x3D;</span><br><span class="line">      jobManagerStateSnapshot.getSubtaskStateByOperatorID(operatorID);</span><br><span class="line"></span><br><span class="line">   if (jobManagerSubtaskState &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return PrioritizedOperatorSubtaskState.emptyNotRestored();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;本地状态快照作为备选</span><br><span class="line">   long restoreCheckpointId &#x3D; jobManagerTaskRestore.getRestoreCheckpointId();</span><br><span class="line"></span><br><span class="line">   TaskStateSnapshot localStateSnapshot &#x3D;</span><br><span class="line">      localStateStore.retrieveLocalState(restoreCheckpointId);</span><br><span class="line"></span><br><span class="line">   localStateStore.pruneMatchingCheckpoints((long checkpointId) -&gt; checkpointId !&#x3D; restoreCheckpointId);</span><br><span class="line"></span><br><span class="line">   List&lt;OperatorSubtaskState&gt; alternativesByPriority &#x3D; Collections.emptyList();</span><br><span class="line"></span><br><span class="line">   if (localStateSnapshot !&#x3D; null) &#123;</span><br><span class="line">      OperatorSubtaskState localSubtaskState &#x3D; localStateSnapshot.getSubtaskStateByOperatorID(operatorID);</span><br><span class="line"></span><br><span class="line">      if (localSubtaskState !&#x3D; null) &#123;</span><br><span class="line">         alternativesByPriority &#x3D; Collections.singletonList(localSubtaskState);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Operator &#123;&#125; has remote state &#123;&#125; from job manager and local state alternatives &#123;&#125; from local &quot; +</span><br><span class="line">         &quot;state store &#123;&#125;.&quot;, operatorID, jobManagerSubtaskState, alternativesByPriority, localStateStore);</span><br><span class="line">&#x2F;&#x2F;构建 PrioritizedOperatorSubtaskState</span><br><span class="line">   PrioritizedOperatorSubtaskState.Builder builder &#x3D; new PrioritizedOperatorSubtaskState.Builder(</span><br><span class="line">      jobManagerSubtaskState,</span><br><span class="line">      alternativesByPriority,</span><br><span class="line">      true);</span><br><span class="line"></span><br><span class="line">   return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了生成 <code>StreamOperatorStateContext</code>，首先要通过 <code>TaskStateManager.prioritizedOperatorState()</code> 方法获得每个 Operator 需要恢复的状态句柄；然后使用获得的状态句柄创建并还原 state backend 和 timer。这里引入了 <code>PrioritizedOperatorSubtaskState</code>, 它封装了多个备选的 OperatorSubtaskState (快照)，这些快照相互之间是可以（部分）替换的，并按照优先级排序。列表中的最后一项是包含了这个子任务的所有状态，但是优先级最低。在进行状态恢复的时候，优先从高优先级的状态句柄中读取状态。</p>
<p>PrioritizedOperatorSubtaskState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Ground truth of state, provided by job manager. *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final OperatorSubtaskState jobManagerState;</span><br><span class="line"></span><br><span class="line">   &#x2F;** (Local) alternatives to the job manager state. *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final List&lt;OperatorSubtaskState&gt; alternativesByPriority;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag if the states have been restored. *&#x2F;</span><br><span class="line">   private final boolean restored;</span><br><span class="line"></span><br><span class="line">   public Builder(</span><br><span class="line">      @Nonnull OperatorSubtaskState jobManagerState,</span><br><span class="line">      @Nonnull List&lt;OperatorSubtaskState&gt; alternativesByPriority) &#123;</span><br><span class="line">      this(jobManagerState, alternativesByPriority, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Builder(</span><br><span class="line">      @Nonnull OperatorSubtaskState jobManagerState,</span><br><span class="line">      @Nonnull List&lt;OperatorSubtaskState&gt; alternativesByPriority,</span><br><span class="line">      boolean restored) &#123;</span><br><span class="line"></span><br><span class="line">      this.jobManagerState &#x3D; jobManagerState;</span><br><span class="line">      this.alternativesByPriority &#x3D; alternativesByPriority;</span><br><span class="line">      this.restored &#x3D; restored;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public PrioritizedOperatorSubtaskState build() &#123;</span><br><span class="line">      int size &#x3D; alternativesByPriority.size();</span><br><span class="line">      List&lt;StateObjectCollection&lt;OperatorStateHandle&gt;&gt; managedOperatorAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;KeyedStateHandle&gt;&gt; managedKeyedAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;OperatorStateHandle&gt;&gt; rawOperatorAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;KeyedStateHandle&gt;&gt; rawKeyedAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按照优先级添加SubtaskState</span><br><span class="line">      for (OperatorSubtaskState subtaskState : alternativesByPriority) &#123;</span><br><span class="line"></span><br><span class="line">         if (subtaskState !&#x3D; null) &#123;</span><br><span class="line">            managedKeyedAlternatives.add(subtaskState.getManagedKeyedState());</span><br><span class="line">            rawKeyedAlternatives.add(subtaskState.getRawKeyedState());</span><br><span class="line">            managedOperatorAlternatives.add(subtaskState.getManagedOperatorState());</span><br><span class="line">            rawOperatorAlternatives.add(subtaskState.getRawOperatorState());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Key-groups should match.</span><br><span class="line">      BiFunction&lt;KeyedStateHandle, KeyedStateHandle, Boolean&gt; keyedStateApprover &#x3D;</span><br><span class="line">         (ref, alt) -&gt; ref.getKeyGroupRange().equals(alt.getKeyGroupRange());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; State meta data should match.</span><br><span class="line">      BiFunction&lt;OperatorStateHandle, OperatorStateHandle, Boolean&gt; operatorStateApprover &#x3D;</span><br><span class="line">         (ref, alt) -&gt; ref.getStateNameToPartitionOffsets().equals(alt.getStateNameToPartitionOffsets());</span><br><span class="line"></span><br><span class="line">      return new PrioritizedOperatorSubtaskState(</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getManagedKeyedState(),</span><br><span class="line">            managedKeyedAlternatives,</span><br><span class="line">            keyedStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getRawKeyedState(),</span><br><span class="line">            rawKeyedAlternatives,</span><br><span class="line">            keyedStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getManagedOperatorState(),</span><br><span class="line">            managedOperatorAlternatives,</span><br><span class="line">            operatorStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getRawOperatorState(),</span><br><span class="line">            rawOperatorAlternatives,</span><br><span class="line">            operatorStateApprover),</span><br><span class="line">         restored);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> protected &lt;T extends StateObject&gt; List&lt;StateObjectCollection&lt;T&gt;&gt; resolvePrioritizedAlternatives(</span><br><span class="line">			StateObjectCollection&lt;T&gt; jobManagerState,</span><br><span class="line">			List&lt;StateObjectCollection&lt;T&gt;&gt; alternativesByPriority,</span><br><span class="line">			BiFunction&lt;T, T, Boolean&gt; approveFun) &#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Nothing to resolve if there are no alternatives, or the ground truth has already no state, or if we can</span><br><span class="line">			&#x2F;&#x2F; assume that a rescaling happened because we find more than one handle in the JM state (this is more a sanity</span><br><span class="line">			&#x2F;&#x2F; check).</span><br><span class="line">			if (alternativesByPriority &#x3D;&#x3D; null</span><br><span class="line">				|| alternativesByPriority.isEmpty()</span><br><span class="line">				|| !jobManagerState.hasState()</span><br><span class="line">				|| jobManagerState.size() !&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">				return Collections.singletonList(jobManagerState);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; As we know size is &#x3D;&#x3D; 1</span><br><span class="line">			T reference &#x3D; jobManagerState.iterator().next();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; This will contain the end result, we initialize it with the potential max. size.</span><br><span class="line">			List&lt;StateObjectCollection&lt;T&gt;&gt; approved &#x3D;</span><br><span class="line">				new ArrayList&lt;&gt;(1 + alternativesByPriority.size());</span><br><span class="line"></span><br><span class="line">			for (StateObjectCollection&lt;T&gt; alternative : alternativesByPriority) &#123;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; We found an alternative to the JM state if it has state, we have a 1:1 relationship, and the</span><br><span class="line">				&#x2F;&#x2F; approve-function signaled true.</span><br><span class="line">				if (alternative !&#x3D; null</span><br><span class="line">					&amp;&amp; alternative.hasState()</span><br><span class="line">					&amp;&amp; alternative.size() &#x3D;&#x3D; 1</span><br><span class="line">					&amp;&amp; BooleanUtils.isTrue(approveFun.apply(reference, alternative.iterator().next()))) &#123;</span><br><span class="line"></span><br><span class="line">					approved.add(alternative);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Of course we include the ground truth as last alternative.</span><br><span class="line">			&#x2F;&#x2F; 从 JobManager 获取的状态作为最低优先级的备选</span><br><span class="line">			approved.add(jobManagerState);</span><br><span class="line">			return Collections.unmodifiableList(approved);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/" itemprop="url">Flink的Task的数据传输过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-07T19:39:38+08:00">
                2020-07-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Task的数据传输包括Task内部传输和Task之间的传输。</p>
<p>Task内部传输是 Task 内部包含的多个不同的算子之间的数据传递，通过函数调用的参数来传递数据。</p>
<p>首先，要看一下 <code>Output</code> 接口，<code>Output</code> 接口继承自 <code>Collector</code> 接口，用于接受 Operator 提交的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Output&lt;T&gt; extends Collector&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Emits a &#123;@link Watermark&#125; from an operator. This watermark is broadcast to all downstream</span><br><span class="line">    * operators.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;A watermark specifies that no element with a timestamp lower or equal to the watermark</span><br><span class="line">    * timestamp will be emitted in the future.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void emitWatermark(Watermark mark);</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Emits a record the side output identified by the given &#123;@link OutputTag&#125;.</span><br><span class="line">    *</span><br><span class="line">    * @param record The record to collect.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record);</span><br><span class="line"></span><br><span class="line">   void emitLatencyMarker(LatencyMarker latencyMarker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>OperatorChain</code> 内部还有一个 <code>WatermarkGaugeExposingOutput</code> 接口继承自 <code>Output</code>，它主要是额外提供了一个获取 watermark 值的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface WatermarkGaugeExposingOutput&lt;T&gt; extends Output&lt;T&gt; &#123;</span><br><span class="line">   Gauge&lt;Long&gt; getWatermarkGauge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说过，在OperatorChain内部创建当前节点的下游节点时，会调用 createOutputCollector 为当前节点创建 output， ExecutionConfig有一个配置项，即 objectReuse，在默认情况下会禁止对象重用。如果不允许对象重用，则不会使用 ChainingOutput，而是会使用 CopyingChainingOutput。顾名思义，它和 ChainingOutput的区别在于，它会对记录进行拷贝后传递给下游算子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">      StreamTask&lt;OUT, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      OutputTag&lt;IN&gt; outputTag,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   &#x2F;&#x2F; create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput &#x3D; createOutputCollector(</span><br><span class="line">      containingTask,</span><br><span class="line">      operatorConfig,</span><br><span class="line">      chainedConfigs,</span><br><span class="line">      userCodeClassloader,</span><br><span class="line">      streamOutputs,</span><br><span class="line">      allOperators,</span><br><span class="line">      mailboxExecutorFactory);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; now create the operator and give it the output collector to write its output to</span><br><span class="line">   OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">         operatorConfig.getStreamOperatorFactory(userCodeClassloader),</span><br><span class="line">         containingTask,</span><br><span class="line">         operatorConfig,</span><br><span class="line">         chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">   allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">   &#x2F;&#x2F;判断objectReuse</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      currentOperatorOutput &#x3D; new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      TypeSerializer&lt;IN&gt; inSerializer &#x3D; operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">      currentOperatorOutput &#x3D; new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createOutputCollector将createChainedOperator返回的Output封装为一组outputs。<code>BroadcastingOutputCollector</code> 封装了一组 <code>Output</code>, 即 <code>Output&lt;StreamRecord&lt;T&gt;&gt;[] outputs</code>, 在接收到 <code>StreamRecord</code> 时，会将消息提交到所有的 内部所有的 <code>Output</code> 中。<code>BroadcastingOutputCollector</code>主要用在当前算子有多个下游算子的情况下。与此对应的还有一个 <code>CopyingBroadcastingOutputCollector</code>。</p>
<p><code>DirectedOutput</code> 基于 <code>OutputSelector&lt;OUT&gt;[] outputSelectors</code> 选择要转发的目标 <code>Output</code>，主要是在 split/select 的情况下使用。与 <code>DirectedOutput</code> 对应的也有一个 <code>CopyingDirectedOutput</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (selectors &#x3D;&#x3D; null || selectors.isEmpty()) &#123;</span><br><span class="line">   &#x2F;&#x2F; simple path, no selector necessary</span><br><span class="line">   if (allOutputs.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return allOutputs.get(0).f0;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; send to N outputs. Note that this includes the special case</span><br><span class="line">      &#x2F;&#x2F; of sending to zero outputs</span><br><span class="line">      @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">      Output&lt;StreamRecord&lt;T&gt;&gt;[] asArray &#x3D; new Output[allOutputs.size()];</span><br><span class="line">      for (int i &#x3D; 0; i &lt; allOutputs.size(); i++) &#123;</span><br><span class="line">         asArray[i] &#x3D; allOutputs.get(i).f0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">      &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">      &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">      if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">         return new CopyingBroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">      &#125; else  &#123;</span><br><span class="line">         return new BroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">   &#x2F;&#x2F; selector present, more complex routing necessary</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">   &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">   &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      return new CopyingDirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return new DirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从之前的文章知道StreamOperator的processElement是调用StreamOperator的output的collect方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StreamMap&lt;IN, OUT&gt;</span><br><span class="line">      extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt;</span><br><span class="line">      implements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">   public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) &#123;</span><br><span class="line">      super(mapper);</span><br><span class="line">      chainingStrategy &#x3D; ChainingStrategy.ALWAYS;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">      output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以OperatorChain内部数据传递是就是调用ChainingOutput的collect，当 <code>ChainingOutput</code> 接收到当前算子提交的数据时，直接将调用下游算子的 <code>processElement</code> 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static class ChainingOutput&lt;T&gt; implements WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void collect(StreamRecord&lt;T&gt; record) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果有 OutputTag， 则要求 OutputTag 匹配才会转发记录</span><br><span class="line">      if (this.outputTag !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; we are not responsible for emitting to the main output.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pushToOperator(record);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">      if (this.outputTag &#x3D;&#x3D; null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">         &#x2F;&#x2F; we are not responsible for emitting to the side-output specified by this</span><br><span class="line">         &#x2F;&#x2F; OutputTag.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pushToOperator(record);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; we know that the given outputTag matches our OutputTag so the record</span><br><span class="line">         &#x2F;&#x2F; must be of the type that our operator expects.</span><br><span class="line">         @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">         StreamRecord&lt;T&gt; castRecord &#x3D; (StreamRecord&lt;T&gt;) record;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接调用下游算子的 processElement 方法</span><br><span class="line">         numRecordsIn.inc();</span><br><span class="line">         operator.setKeyContextElement1(castRecord);</span><br><span class="line">         operator.processElement(castRecord);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new ExceptionInChainedOperatorException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于位于 <code>OperatorChain</code> 末尾的算子，它处理过的记录需要被其它 <code>Task</code> 消费，因此它的记录需要被写入 <code>ResultPartition</code> 。因此，Flink 提供了 <code>RecordWriterOutput</code>，它也实现了 <code>WatermarkGaugeExposingOutput</code>， 但是它是通过 <code>RecordWriter</code> 输出接收到的消息记录。<code>RecordWriter</code> 是 <code>ResultPartitionWriter</code> 的一层包装，提供了将记录序列化到 buffer 中的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RecordWriterOutput&lt;?&gt; streamOutput &#x3D; createStreamOutput(</span><br><span class="line">   recordWriterDelegate.getRecordWriter(i),</span><br><span class="line">   outEdge,</span><br><span class="line">   chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">   containingTask.getEnvironment());</span><br></pre></td></tr></table></figure>

<p>task之间的数据传递调用RecordWriterOutput的collect方法，最终调用RecordWriter的emit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public RecordWriterOutput(</span><br><span class="line">      RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriter,</span><br><span class="line">      TypeSerializer&lt;OUT&gt; outSerializer,</span><br><span class="line">      OutputTag outputTag,</span><br><span class="line">      StreamStatusProvider streamStatusProvider) &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void collect(StreamRecord&lt;OUT&gt; record) &#123;</span><br><span class="line">   if (this.outputTag !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; we are not responsible for emitting to the main output.</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">   if (this.outputTag &#x3D;&#x3D; null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">      &#x2F;&#x2F; we are not responsible for emitting to the side-output specified by this</span><br><span class="line">      &#x2F;&#x2F; OutputTag.</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">   serializationDelegate.setInstance(record);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      recordWriter.emit(serializationDelegate);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task 通过 <code>RecordWriter</code> 将结果写入 <code>ResultPartition</code> 中。<code>RecordWriter</code> 是对 <code>ResultPartitionWriter</code>的一层封装，并负责将记录对象序列化到 buffer 中。先来看一下 <code>RecordWriter</code> 的成员变量和构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RecordWriter&lt;T extends IOReadableWritable&gt; implements AvailabilityProvider &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Default name for the output flush thread, if no name with a task reference is given. *&#x2F;</span><br><span class="line">   @VisibleForTesting</span><br><span class="line">   public static final String DEFAULT_OUTPUT_FLUSH_THREAD_NAME &#x3D; &quot;OutputFlusher&quot;;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(RecordWriter.class);</span><br><span class="line">&#x2F;&#x2F;底层的 ResultPartition</span><br><span class="line">   protected final ResultPartitionWriter targetPartition;</span><br><span class="line">&#x2F;&#x2F;channel的数量，即 sub-partition的数量</span><br><span class="line">   protected final int numberOfChannels;</span><br><span class="line">&#x2F;&#x2F;序列化</span><br><span class="line">   protected final RecordSerializer&lt;T&gt; serializer;</span><br><span class="line"></span><br><span class="line">   protected final Random rng &#x3D; new XORShiftRandom();</span><br><span class="line"></span><br><span class="line">   private Counter numBytesOut &#x3D; new SimpleCounter();</span><br><span class="line"></span><br><span class="line">   private Counter numBuffersOut &#x3D; new SimpleCounter();</span><br><span class="line"></span><br><span class="line">   private final boolean flushAlways;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The thread that periodically flushes the output, to give an upper latency bound. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;定时强制 flush 输出buffer</span><br><span class="line">   @Nullable</span><br><span class="line">   private final OutputFlusher outputFlusher;</span><br><span class="line"></span><br><span class="line">   &#x2F;** To avoid synchronization overhead on the critical path, best-effort error tracking is enough here.*&#x2F;</span><br><span class="line">   private Throwable flusherException;</span><br><span class="line"></span><br><span class="line">   RecordWriter(ResultPartitionWriter writer, long timeout, String taskName) &#123;</span><br><span class="line">      this.targetPartition &#x3D; writer;</span><br><span class="line">      this.numberOfChannels &#x3D; writer.getNumberOfSubpartitions();</span><br><span class="line">&#x2F;&#x2F;序列化器，用于将一条记录序列化到多个buffer中</span><br><span class="line">      this.serializer &#x3D; new SpanningRecordSerializer&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">      checkArgument(timeout &gt;&#x3D; -1);</span><br><span class="line">      this.flushAlways &#x3D; (timeout &#x3D;&#x3D; 0);</span><br><span class="line">      if (timeout &#x3D;&#x3D; -1 || timeout &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         outputFlusher &#x3D; null;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;根据超时时间创建一个定时 flush 输出 buffer 的线程</span><br><span class="line">         String threadName &#x3D; taskName &#x3D;&#x3D; null ?</span><br><span class="line">            DEFAULT_OUTPUT_FLUSH_THREAD_NAME :</span><br><span class="line">            DEFAULT_OUTPUT_FLUSH_THREAD_NAME + &quot; for &quot; + taskName;</span><br><span class="line"></span><br><span class="line">         outputFlusher &#x3D; new OutputFlusher(threadName, timeout);</span><br><span class="line">         outputFlusher.start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>  buffer的分配在task启动的时候，调用ResultPartitionWriter的setup，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void setupPartitionsAndGates(</span><br><span class="line">   ResultPartitionWriter[] producedPartitions, InputGate[] inputGates) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   for (ResultPartitionWriter partition : producedPartitions) &#123;</span><br><span class="line">      partition.setup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; InputGates must be initialized after the partitions, since during InputGate#setup</span><br><span class="line">   &#x2F;&#x2F; we are requesting partitions</span><br><span class="line">   for (InputGate gate : inputGates) &#123;</span><br><span class="line">      gate.setup();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition的setup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setup() throws IOException &#123;</span><br><span class="line">   checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in result partition setup logic: Already registered buffer pool.&quot;);</span><br><span class="line"></span><br><span class="line">   BufferPool bufferPool &#x3D; checkNotNull(bufferPoolFactory.apply(this));</span><br><span class="line">   &#x2F;&#x2F;创建一个 LocalBufferPool，请求的最少的 MemeorySegment 数量和 sub-partition 一致</span><br><span class="line">   checkArgument(bufferPool.getNumberOfRequiredMemorySegments() &gt;&#x3D; getNumberOfSubpartitions(),</span><br><span class="line">      &quot;Bug in result partition setup logic: Buffer pool has not enough guaranteed buffers for this result partition.&quot;);</span><br><span class="line"></span><br><span class="line">   this.bufferPool &#x3D; bufferPool;</span><br><span class="line">   &#x2F;&#x2F;向 ResultPartitionManager 注册</span><br><span class="line">   partitionManager.registerResultPartition(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartitionManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void registerResultPartition(ResultPartition partition) &#123;</span><br><span class="line">   synchronized (registeredPartitions) &#123;</span><br><span class="line">      checkState(!isShutdown, &quot;Result partition manager already shut down.&quot;);</span><br><span class="line"></span><br><span class="line">      ResultPartition previous &#x3D; registeredPartitions.put(partition.getPartitionId(), partition);</span><br><span class="line"></span><br><span class="line">      if (previous !&#x3D; null) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Result partition already registered.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;Registered &#123;&#125;.&quot;, partition);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Task 通过 <code>RecordWriter</code> 输出一条记录时，主要流程为：</p>
<ol>
<li><p>通过 ChannelSelector 确定写入的目标 channel</p>
</li>
<li><p>使用 RecordSerializer 对记录进行序列化</p>
</li>
<li><p>向 ResultPartition 请求 BufferBuilder，用于写入序列化结果</p>
</li>
<li><p>向 ResultPartition 添加 BufferConsumer，用于读取写入 Buffer 的数据</p>
</li>
</ol>
<p>   RecordWriter类 emit，前面调用recordWriter.emit会区分BroadcastRecordWriter类的emit和ChannelSelectorRecordWriter的emit，最终都会调用RecordWriter类 的emit</p>
<p>ChannelSelectorRecordWriter，选择channel发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final class ChannelSelectorRecordWriter&lt;T extends IOReadableWritable&gt; extends RecordWriter&lt;T&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;决定一条记录应该写入哪一个channel， 即 sub-partition</span><br><span class="line">   private final ChannelSelector&lt;T&gt; channelSelector;</span><br><span class="line">&#x2F;&#x2F;供每一个 channel 写入数据使用</span><br><span class="line">   &#x2F;** Every subpartition maintains a separate buffer builder which might be null. *&#x2F;</span><br><span class="line">   private final BufferBuilder[] bufferBuilders;</span><br><span class="line"></span><br><span class="line">   ChannelSelectorRecordWriter(</span><br><span class="line">         ResultPartitionWriter writer,</span><br><span class="line">         ChannelSelector&lt;T&gt; channelSelector,</span><br><span class="line">         long timeout,</span><br><span class="line">         String taskName) &#123;</span><br><span class="line">      super(writer, timeout, taskName);</span><br><span class="line"></span><br><span class="line">      this.channelSelector &#x3D; checkNotNull(channelSelector);</span><br><span class="line">      this.channelSelector.setup(numberOfChannels);</span><br><span class="line"></span><br><span class="line">      this.bufferBuilders &#x3D; new BufferBuilder[numberOfChannels];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void emit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">      emit(record, channelSelector.selectChannel(record));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>BroadcastRecordWriter，发送给所有channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final class BroadcastRecordWriter&lt;T extends IOReadableWritable&gt; extends RecordWriter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;供每一个 channel 写入数据使用</span><br><span class="line">   &#x2F;** The current buffer builder shared for all the channels. *&#x2F;</span><br><span class="line">   @Nullable</span><br><span class="line">   private BufferBuilder bufferBuilder;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * The flag for judging whether &#123;@link #requestNewBufferBuilder(int)&#125; and &#123;@link #flushTargetPartition(int)&#125;</span><br><span class="line">    * is triggered by &#123;@link #randomEmit(IOReadableWritable)&#125; or not.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private boolean randomTriggered;</span><br><span class="line"></span><br><span class="line">   BroadcastRecordWriter(</span><br><span class="line">         ResultPartitionWriter writer,</span><br><span class="line">         long timeout,</span><br><span class="line">         String taskName) &#123;</span><br><span class="line">      super(writer, timeout, taskName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void emit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">      broadcastEmit(record);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void broadcastEmit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">		&#x2F;&#x2F; We could actually select any target channel here because all the channels</span><br><span class="line">		&#x2F;&#x2F; are sharing the same BufferBuilder in broadcast mode.</span><br><span class="line">		emit(record, 0);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RecordWriter类 的emit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected void emit(T record, int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">      checkErroneous();</span><br><span class="line">&#x2F;&#x2F;序列化</span><br><span class="line">      serializer.serializeRecord(record);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure we don&#39;t hold onto the large intermediate serialization buffer for too long</span><br><span class="line">      &#x2F;&#x2F;将序列化结果写入buffer</span><br><span class="line">       if (copyFromSerializerToTargetChannel(targetChannel)) &#123;</span><br><span class="line">       &#x2F;&#x2F;清除序列化使用的buffer（这个是序列化时临时写入的byte[]）,减少内存占用</span><br><span class="line">        serializer.prune();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">   * @param targetChannel</span><br><span class="line"></span><br><span class="line">     * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if the intermediate serialization buffer should be pruned</span><br><span class="line">       *&#x2F;</span><br><span class="line">       protected boolean copyFromSerializerToTargetChannel(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; We should reset the initial position of the intermediate serialization buffer before</span><br><span class="line">       &#x2F;&#x2F; copying, so the serialization results can be copied to multiple target buffers.</span><br><span class="line">       serializer.reset();</span><br><span class="line"></span><br><span class="line">     boolean pruneTriggered &#x3D; false;</span><br><span class="line">     BufferBuilder bufferBuilder &#x3D; getBufferBuilder(targetChannel);</span><br><span class="line">     SerializationResult result &#x3D; serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">     while (result.isFullBuffer()) &#123;</span><br><span class="line">     &#x2F;&#x2F;buffer 写满了，调用 bufferBuilder.finish 方法</span><br><span class="line">        finishBufferBuilder(bufferBuilder);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If this was a full record, we are done. Not breaking out of the loop at this point</span><br><span class="line">        &#x2F;&#x2F; will lead to another buffer request before breaking out (that would not be a</span><br><span class="line">        &#x2F;&#x2F; problem per se, but it can lead to stalls in the pipeline).</span><br><span class="line">        if (result.isFullRecord()) &#123;</span><br><span class="line">           pruneTriggered &#x3D; true;</span><br><span class="line">           &#x2F;&#x2F;如果当前这条记录也完整输出了，清空bufferBuilder</span><br><span class="line">           emptyCurrentBufferBuilder(targetChannel);</span><br><span class="line">           break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前这条记录没有写完，申请新的 buffer 写入</span><br><span class="line">        bufferBuilder &#x3D; requestNewBufferBuilder(targetChannel);</span><br><span class="line">        result &#x3D; serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">     &#125;</span><br><span class="line">     checkState(!serializer.hasSerializedData(), &quot;All data should be written at once&quot;);</span><br><span class="line"></span><br><span class="line">     if (flushAlways) &#123;</span><br><span class="line">     &#x2F;&#x2F;强制刷新结果</span><br><span class="line">        flushTargetPartition(targetChannel);</span><br><span class="line">     &#125;</span><br><span class="line">     return pruneTriggered;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void finishBufferBuilder(BufferBuilder bufferBuilder) &#123;</span><br><span class="line">   numBytesOut.inc(bufferBuilder.finish());</span><br><span class="line">   numBuffersOut.inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChannelSelectorRecordWriter：</span><br><span class="line">public BufferBuilder getBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">   if (bufferBuilders[targetChannel] !&#x3D; null) &#123;</span><br><span class="line">      return bufferBuilders[targetChannel];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return requestNewBufferBuilder(targetChannel);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BroadcastRecordWriter：</span><br><span class="line">public BufferBuilder getBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		return bufferBuilder !&#x3D; null ? bufferBuilder : requestNewBufferBuilder(targetChannel);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>//请求新的 BufferBuilder，用于写入数据 如果当前没有可用的 buffer，会阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ChannelSelectorRecordWriter：</span><br><span class="line">public BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(bufferBuilders[targetChannel] &#x3D;&#x3D; null || bufferBuilders[targetChannel].isFinished());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从 LocalBufferPool 中请求 BufferBuilder</span><br><span class="line">		BufferBuilder bufferBuilder &#x3D; targetPartition.getBufferBuilder();</span><br><span class="line">		&#x2F;&#x2F;添加一个BufferConsumer，用于读取写入到 MemorySegment 的数据</span><br><span class="line">		targetPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(), targetChannel);</span><br><span class="line">		bufferBuilders[targetChannel] &#x3D; bufferBuilder;</span><br><span class="line">		return bufferBuilder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BroadcastRecordWriter：</span><br><span class="line">public BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(bufferBuilder &#x3D;&#x3D; null || bufferBuilder.isFinished());</span><br><span class="line"></span><br><span class="line">		BufferBuilder builder &#x3D; targetPartition.getBufferBuilder();</span><br><span class="line">		if (randomTriggered) &#123;</span><br><span class="line">			targetPartition.addBufferConsumer(builder.createBufferConsumer(), targetChannel);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try (BufferConsumer bufferConsumer &#x3D; builder.createBufferConsumer()) &#123;</span><br><span class="line">				for (int channel &#x3D; 0; channel &lt; numberOfChannels; channel++) &#123;</span><br><span class="line">					targetPartition.addBufferConsumer(bufferConsumer.copy(), channel);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bufferBuilder &#x3D; builder;</span><br><span class="line">		return builder;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>//从 LocalBufferPool 中请求 BufferBuilder调用ResultPartition的getBufferBuilder，ResultPartition实现了ResultPartitionWriter接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ResultPartition implements ResultPartitionWriter, BufferPoolOwner &#123;</span><br><span class="line"></span><br><span class="line">   protected static final Logger LOG &#x3D; LoggerFactory.getLogger(ResultPartition.class);</span><br><span class="line"></span><br><span class="line">   private final String owningTaskName;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionID partitionId;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Type of this partition. Defines the concrete subpartition implementation to use. *&#x2F;</span><br><span class="line">   protected final ResultPartitionType partitionType;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The subpartitions of this partition. At least one. *&#x2F;</span><br><span class="line">   protected final ResultSubpartition[] subpartitions;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionManager partitionManager;</span><br><span class="line"></span><br><span class="line">   public final int numTargetKeyGroups;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Runtime state --------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   private final AtomicBoolean isReleased &#x3D; new AtomicBoolean();</span><br><span class="line"></span><br><span class="line">   private BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">   private boolean isFinished;</span><br><span class="line"></span><br><span class="line">   private volatile Throwable cause;</span><br><span class="line"></span><br><span class="line">   private final FunctionWithException&lt;BufferPoolOwner, BufferPool, IOException&gt; bufferPoolFactory;</span><br></pre></td></tr></table></figure>

<p>ResultPartition.getBufferBuilder()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BufferBuilder getBufferBuilder() throws IOException, InterruptedException &#123;</span><br><span class="line">   checkInProduceState();</span><br><span class="line"></span><br><span class="line">   return bufferPool.requestBufferBuilderBlocking();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalBufferPool .requestBufferBuilderBlocking,请求MemorySegment内存资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BufferBuilder requestBufferBuilderBlocking() throws IOException, InterruptedException &#123;</span><br><span class="line">   return toBufferBuilder(requestMemorySegmentBlocking());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BufferBuilder toBufferBuilder(MemorySegment memorySegment) &#123;</span><br><span class="line">   if (memorySegment &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return new BufferBuilder(memorySegment, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private MemorySegment requestMemorySegmentBlocking() throws InterruptedException, IOException &#123;</span><br><span class="line">		MemorySegment segment;</span><br><span class="line">		while ((segment &#x3D; requestMemorySegment()) &#x3D;&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F; wait until available</span><br><span class="line">				getAvailableFuture().get();</span><br><span class="line">			&#125; catch (ExecutionException e) &#123;</span><br><span class="line">				LOG.error(&quot;The available future is completed exceptionally.&quot;, e);</span><br><span class="line">				ExceptionUtils.rethrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return segment;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition.addBufferConsumer()，向指定的 subpartition 添加一个 buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean addBufferConsumer(BufferConsumer bufferConsumer, int subpartitionIndex) throws IOException &#123;</span><br><span class="line">   checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">   ResultSubpartition subpartition;</span><br><span class="line">   try &#123;</span><br><span class="line">      checkInProduceState();</span><br><span class="line">      subpartition &#x3D; subpartitions[subpartitionIndex];</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception ex) &#123;</span><br><span class="line">      bufferConsumer.close();</span><br><span class="line">      throw ex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加 BufferConsumer，说明已经有数据生成了</span><br><span class="line">   return subpartition.add(bufferConsumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition转交给ResultSubpartition添加bufferConsumer，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResultSubpartition &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** The index of the subpartition at the parent partition. *&#x2F;</span><br><span class="line">	protected final int index;</span><br><span class="line"></span><br><span class="line">	&#x2F;** The parent partition this subpartition belongs to. *&#x2F;</span><br><span class="line">	protected final ResultPartition parent;</span><br><span class="line"></span><br><span class="line">   public abstract boolean add(BufferConsumer bufferConsumer) throws IOException;</span><br></pre></td></tr></table></figure>

<p>对于stream的任务，实现类是PipelinedSubpartition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">class PipelinedSubpartition extends ResultSubpartition &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(PipelinedSubpartition.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** All buffers of this subpartition. Access to the buffers is synchronized on this object. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;当前 subpartiion 堆积的所有的 Buffer 的队列</span><br><span class="line">   private final ArrayDeque&lt;BufferConsumer&gt; buffers &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The number of non-event buffers currently in this subpartition. *&#x2F;</span><br><span class="line">   @GuardedBy(&quot;buffers&quot;)</span><br><span class="line">   &#x2F;&#x2F;当前 subpartiion 中堆积的 buffer 的数量</span><br><span class="line">   private int buffersInBacklog;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The read view to consume this subpartition. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;用于消费写入的 Buffer</span><br><span class="line">   private PipelinedSubpartitionView readView;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether the subpartition has been finished. *&#x2F;</span><br><span class="line">   private boolean isFinished;</span><br><span class="line"></span><br><span class="line">   @GuardedBy(&quot;buffers&quot;)</span><br><span class="line">   private boolean flushRequested;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether the subpartition has been released. *&#x2F;</span><br><span class="line">   private volatile boolean isReleased;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The total number of buffers (both data and event buffers). *&#x2F;</span><br><span class="line">   private long totalNumberOfBuffers;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The total number of bytes (both data and event buffers). *&#x2F;</span><br><span class="line">   private long totalNumberOfBytes;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;index 是当前 sub-paritition 的索引</span><br><span class="line">   PipelinedSubpartition(int index, ResultPartition parent) &#123;</span><br><span class="line">      super(index, parent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean add(BufferConsumer bufferConsumer) &#123;</span><br><span class="line">      return add(bufferConsumer, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void finish() throws IOException &#123;</span><br><span class="line">      add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true);</span><br><span class="line">      LOG.debug(&quot;&#123;&#125;: Finished &#123;&#125;.&quot;, parent.getOwningTaskName(), this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加一个新的BufferConsumer</span><br><span class="line">	&#x2F;&#x2F;这个参数里的 finish 指的是整个 subpartition 都完成了</span><br><span class="line">   private boolean add(BufferConsumer bufferConsumer, boolean finish) &#123;</span><br><span class="line">      checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">      final boolean notifyDataAvailable;</span><br><span class="line">      synchronized (buffers) &#123;</span><br><span class="line">         if (isFinished || isReleased) &#123;</span><br><span class="line">            bufferConsumer.close();</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Add the bufferConsumer and update the stats</span><br><span class="line">         buffers.add(bufferConsumer);</span><br><span class="line">         updateStatistics(bufferConsumer);</span><br><span class="line">         &#x2F;&#x2F;更新 backlog 的数量，只有 buffer 才会使得 buffersInBacklog + 1，事件不会增加 buffersInBacklog</span><br><span class="line">         increaseBuffersInBacklog(bufferConsumer);</span><br><span class="line">         notifyDataAvailable &#x3D; shouldNotifyDataAvailable() || finish;</span><br><span class="line"></span><br><span class="line">         isFinished |&#x3D; finish;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (notifyDataAvailable) &#123;</span><br><span class="line">      &#x2F;&#x2F;通知数据可以被消费</span><br><span class="line">         notifyDataAvailable();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;只在第一个 buffer 为 finish 的时候才通知</span><br><span class="line">   private boolean shouldNotifyDataAvailable() &#123;</span><br><span class="line">		&#x2F;&#x2F; Notify only when we added first finished buffer.</span><br><span class="line">		return readView !&#x3D; null &amp;&amp; !flushRequested &amp;&amp; getNumberOfFinishedBuffers() &#x3D;&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知readView，有数据可用了</span><br><span class="line">	private void notifyDataAvailable() &#123;</span><br><span class="line">		if (readView !&#x3D; null) &#123;</span><br><span class="line">			readView.notifyDataAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">     public void flush() &#123;</span><br><span class="line">		final boolean notifyDataAvailable;</span><br><span class="line">		synchronized (buffers) &#123;</span><br><span class="line">			if (buffers.isEmpty()) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; if there is more then 1 buffer, we already notified the reader</span><br><span class="line">			&#x2F;&#x2F; (at the latest when adding the second buffer)</span><br><span class="line">			notifyDataAvailable &#x3D; !flushRequested &amp;&amp; buffers.size() &#x3D;&#x3D; 1 &amp;&amp; buffers.peek().isDataAvailable();</span><br><span class="line">			flushRequested &#x3D; flushRequested || buffers.size() &gt; 1 || notifyDataAvailable;</span><br><span class="line">		&#125;</span><br><span class="line">		if (notifyDataAvailable) &#123;</span><br><span class="line">			notifyDataAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在强制进行 flush 的时候，也会发出数据可用的通知。这是因为，假如产出的数据记录较少无法完整地填充一个 <code>MemorySegment</code>，那么 <code>ResultSubpartition</code> 可能会一直处于不可被消费的状态。而为了保证产出的记录能够及时被消费，就需要及时进行 flush，从而确保下游能更及时地处理数据。在 <code>RecordWriter</code> 中有一个 <code>OutputFlusher</code> 会定时触发 flush，间隔可以通过 <code>DataStream.setBufferTimeout()</code> 来控制。</p>
<p>写入的 Buffer 最终被保存在 <code>ResultSubpartition</code> 中维护的一个队列中，如果需要消费这些 Buffer，就需要依赖 <code>ResultSubpartitionView</code>。当需要消费一个 <code>ResultSubpartition</code> 的结果时，需要创建一个 <code>ResultSubpartitionView</code> 对象，并关联到 <code>ResultSubpartition</code> 中；当数据可以被消费时，会通过对应的回调接口告知 <code>ResultSubpartitionView</code></p>
<p>对于stream，PipelinedSubpartitionView实现了ResultSubpartitionView的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class PipelinedSubpartitionView implements ResultSubpartitionView &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The subpartition this view belongs to. *&#x2F;</span><br><span class="line">   private final PipelinedSubpartition parent;</span><br><span class="line"></span><br><span class="line">   private final BufferAvailabilityListener availabilityListener;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether this view has been released. *&#x2F;</span><br><span class="line">   private final AtomicBoolean isReleased;</span><br><span class="line"></span><br><span class="line">   PipelinedSubpartitionView(PipelinedSubpartition parent, BufferAvailabilityListener listener) &#123;</span><br><span class="line">      this.parent &#x3D; checkNotNull(parent);</span><br><span class="line">      this.availabilityListener &#x3D; checkNotNull(listener);</span><br><span class="line">      this.isReleased &#x3D; new AtomicBoolean();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Nullable</span><br><span class="line">   @Override</span><br><span class="line">   public BufferAndBacklog getNextBuffer() &#123;</span><br><span class="line">      return parent.pollBuffer();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void notifyDataAvailable() &#123;</span><br><span class="line">   &#x2F;&#x2F;回调接口</span><br><span class="line">      availabilityListener.notifyDataAvailable();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们已经了解了一个 Task 如何输出结果到 <code>ResultPartition</code> 中，以及如何去消费不同 <code>ResultSubpartition</code> 中的这些用于保存序列化结果的 Buffer。</p>
<p>继续看task的数据输入，availabilityListener.notifyDataAvailable()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface BufferAvailabilityListener &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Called whenever there might be new data available.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void notifyDataAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferAvailabilityListener有多种实现，如果一个 <code>InputChannel</code> 和其消费的上游 <code>ResultPartition</code> 所属 Task 都在同一个 TaskManager 中运行，那么它们之间的数据交换就在同一个 JVM 进程内不同线程之间进行，无需通过网络交换。也就是<code>LocalInputChannel</code>，LocalInputChannel继承自BufferAvailabilityListener</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInputChannel extends InputChannel implements BufferAvailabilityListener &#123;  </span><br><span class="line">   public void notifyDataAvailable() &#123;</span><br><span class="line">		notifyChannelNonEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后回调了InputChannel的notifyChannelNonEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void notifyChannelNonEmpty() &#123;</span><br><span class="line">   inputGate.notifyChannelNonEmpty(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>InputChannel</code> 和该 Task 需要消费的 <code>ResultSubpartition</code> 是一一对应的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputChannel &#123;</span><br><span class="line"></span><br><span class="line">   protected final int channelIndex;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionID partitionId;</span><br><span class="line"></span><br><span class="line">   protected final SingleInputGate inputGate;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Asynchronous error notification --------------------------------------</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;Throwable&gt; cause &#x3D; new AtomicReference&lt;Throwable&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Partition request backoff --------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** The initial backoff (in ms). *&#x2F;</span><br><span class="line">   private final int initialBackoff;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The maximum backoff (in ms). *&#x2F;</span><br><span class="line">   private final int maxBackoff;</span><br><span class="line"></span><br><span class="line">   protected final Counter numBytesIn;</span><br><span class="line"></span><br><span class="line">   protected final Counter numBuffersIn;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The current backoff (in ms). *&#x2F;</span><br><span class="line">   private int currentBackoff;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   protected void notifyChannelNonEmpty() &#123;</span><br><span class="line">      inputGate.notifyChannelNonEmpty(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再调用inputGate的notifyChannelNonEmpty，Task 的输入被抽象为 <code>InputGate</code>, 而 <code>InputGate</code> 则由 <code>InputChannel</code> 组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputGate implements PullingAsyncDataInput&lt;BufferOrEvent&gt;, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">   protected final AvailabilityHelper availabilityHelper &#x3D; new AvailabilityHelper();</span><br><span class="line"></span><br><span class="line">   public abstract int getNumberOfInputChannels();</span><br><span class="line"></span><br><span class="line">   public abstract boolean isFinished();</span><br><span class="line">阻塞调用</span><br><span class="line">   public abstract Optional&lt;BufferOrEvent&gt; getNext() throws IOException, InterruptedException;</span><br><span class="line">非阻塞调用</span><br><span class="line">   public abstract Optional&lt;BufferOrEvent&gt; pollNext() throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line">   public abstract void sendTaskEvent(TaskEvent event) throws IOException;</span><br></pre></td></tr></table></figure>

<p>InputGate的实现类是SingleInputGate，进入SingleInputGate的notifyChannelNonEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInputGate extends InputGate &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;该 InputGate 包含的所有 InputChannel</span><br><span class="line">	private final Map&lt;IntermediateResultPartitionID, InputChannel&gt; inputChannels;</span><br><span class="line"></span><br><span class="line">	&#x2F;** Channels, which notified this input gate about available data. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;InputChannel 构成的队列，这些 InputChannel 中都有有可供消费的数据</span><br><span class="line">	private final ArrayDeque&lt;InputChannel&gt; inputChannelsWithData &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;用于接收输入的缓冲池</span><br><span class="line">	private BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当一个 InputChannel 有数据时的回调</span><br><span class="line">    void notifyChannelNonEmpty(InputChannel channel) &#123;</span><br><span class="line">        queueChannel(checkNotNull(channel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将新的channel加入队列</span><br><span class="line">    private void queueChannel(InputChannel channel) &#123;</span><br><span class="line">		int availableChannels;</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;?&gt; toNotify &#x3D; null;</span><br><span class="line"></span><br><span class="line">		synchronized (inputChannelsWithData) &#123;</span><br><span class="line">		&#x2F;&#x2F;判断这个channel是否已经在队列中</span><br><span class="line">			if (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			availableChannels &#x3D; inputChannelsWithData.size();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;加入队列</span><br><span class="line">			inputChannelsWithData.add(channel);</span><br><span class="line">			enqueuedInputChannelsWithData.set(channel.getChannelIndex());</span><br><span class="line"></span><br><span class="line">			if (availableChannels &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果之前队列中没有channel，这个channel加入后，通知等待的线程</span><br><span class="line">				inputChannelsWithData.notifyAll();</span><br><span class="line">				toNotify &#x3D; availabilityHelper.getUnavailableToResetAvailable();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (toNotify !&#x3D; null) &#123;</span><br><span class="line">			toNotify.complete(null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;在task启动的setupPartitionsAndGates里调用</span><br><span class="line">@Override</span><br><span class="line">	public void setup() throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in input gate setup logic: Already registered buffer pool.&quot;);</span><br><span class="line">		&#x2F;&#x2F; assign exclusive buffers to input channels directly and use the rest for floating buffers</span><br><span class="line">		assignExclusiveSegments();</span><br><span class="line"></span><br><span class="line">		BufferPool bufferPool &#x3D; bufferPoolFactory.get();</span><br><span class="line">		setBufferPool(bufferPool);</span><br><span class="line"></span><br><span class="line">		requestPartitions();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@VisibleForTesting</span><br><span class="line">	void requestPartitions() throws IOException, InterruptedException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">		&#x2F;&#x2F;只请求一次</span><br><span class="line">			if (!requestedPartitionsFlag) &#123;</span><br><span class="line">				if (closeFuture.isDone()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Already released.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Sanity checks</span><br><span class="line">				if (numberOfInputChannels !&#x3D; inputChannels.size()) &#123;</span><br><span class="line">					throw new IllegalStateException(String.format(</span><br><span class="line">						&quot;Bug in input gate setup logic: mismatch between &quot; +</span><br><span class="line">						&quot;number of total input channels [%s] and the currently set number of input &quot; +</span><br><span class="line">						&quot;channels [%s].&quot;,</span><br><span class="line">						inputChannels.size(),</span><br><span class="line">						numberOfInputChannels));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">				&#x2F;&#x2F;每一个channel都请求对应的子分区</span><br><span class="line">					inputChannel.requestSubpartition(consumedSubpartitionIndex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			requestedPartitionsFlag &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>回调之后开启了InputChannel的消费周期，requestSubpartition，getNextBuffer，releaseAllResources</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line">abstract void releaseAllResources() throws IOException;</span><br></pre></td></tr></table></figure>

<p>在LocalInputChannel中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求消费对应的子分区</span><br><span class="line">void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   boolean retriggerRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The lock is required to request only once in the presence of retriggered requests.</span><br><span class="line">   synchronized (requestLock) &#123;</span><br><span class="line">      checkState(!isReleased, &quot;LocalInputChannel has been released already&quot;);</span><br><span class="line"></span><br><span class="line">      if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">         LOG.debug(&quot;&#123;&#125;: Requesting LOCAL subpartition &#123;&#125; of partition &#123;&#125;.&quot;,</span><br><span class="line">            this, subpartitionIndex, partitionId);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">         &#x2F;&#x2F;Local，无需网络通信，通过 ResultPartitionManager 创建一个 ResultSubpartitionView</span><br><span class="line">					&#x2F;&#x2F;LocalInputChannel 实现了 BufferAvailabilityListener</span><br><span class="line">					&#x2F;&#x2F;在有数据时会得到通知，notifyDataAvailable 会被调用，进而将当前 channel 加到 InputGate 的可用 Channel 队列中</span><br><span class="line">            ResultSubpartitionView subpartitionView &#x3D; partitionManager.createSubpartitionView(</span><br><span class="line">               partitionId, subpartitionIndex, this);</span><br><span class="line"></span><br><span class="line">            if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">               throw new IOException(&quot;Error requesting subpartition.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; make the subpartition view visible</span><br><span class="line">            this.subpartitionView &#x3D; subpartitionView;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; check if the channel was released in the meantime</span><br><span class="line">            if (isReleased) &#123;</span><br><span class="line">               subpartitionView.releaseAllResources();</span><br><span class="line">               this.subpartitionView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; catch (PartitionNotFoundException notFound) &#123;</span><br><span class="line">            if (increaseBackoff()) &#123;</span><br><span class="line">               retriggerRequest &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               throw notFound;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Do this outside of the lock scope as this might lead to a</span><br><span class="line">   &#x2F;&#x2F; deadlock with a concurrent release of the channel via the</span><br><span class="line">   &#x2F;&#x2F; input gate.</span><br><span class="line">   if (retriggerRequest) &#123;</span><br><span class="line">      inputGate.retriggerPartitionRequest(partitionId.getPartitionId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取数据，借助 ResultSubparitionView 消费 ResultSubparition 中的数据</span><br><span class="line">Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException, InterruptedException &#123;</span><br><span class="line">		checkError();</span><br><span class="line"></span><br><span class="line">		ResultSubpartitionView subpartitionView &#x3D; this.subpartitionView;</span><br><span class="line">		if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F; There is a possible race condition between writing a EndOfPartitionEvent (1) and flushing (3) the Local</span><br><span class="line">			&#x2F;&#x2F; channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush notification (4). When</span><br><span class="line">			&#x2F;&#x2F; they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue LocalInputChannel after (or</span><br><span class="line">			&#x2F;&#x2F; during) it was released during reading the EndOfPartitionEvent (2).</span><br><span class="line">			if (isReleased) &#123;</span><br><span class="line">				return Optional.empty();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; this can happen if the request for the partition was triggered asynchronously</span><br><span class="line">			&#x2F;&#x2F; by the time trigger</span><br><span class="line">			&#x2F;&#x2F; would be good to avoid that, by guaranteeing that the requestPartition() and</span><br><span class="line">			&#x2F;&#x2F; getNextBuffer() always come from the same thread</span><br><span class="line">			&#x2F;&#x2F; we could do that by letting the timer insert a special &quot;requesting channel&quot; into the input gate&#39;s queue</span><br><span class="line">			subpartitionView &#x3D; checkAndWaitForSubpartitionView();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过 ResultSubparitionView 获取</span><br><span class="line">		BufferAndBacklog next &#x3D; subpartitionView.getNextBuffer();</span><br><span class="line"></span><br><span class="line">		if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (subpartitionView.isReleased()) &#123;</span><br><span class="line">				throw new CancelTaskException(&quot;Consumed partition &quot; + subpartitionView + &quot; has been released.&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return Optional.empty();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		numBytesIn.inc(next.buffer().getSize());</span><br><span class="line">		numBuffersIn.inc();</span><br><span class="line">		return Optional.of(new BufferAndAvailability(next.buffer(), next.isMoreAvailable(), next.buffersInBacklog()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用PipelinedSubpartitionView的getNextBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   @Override</span><br><span class="line">   public BufferAndBacklog getNextBuffer() &#123;</span><br><span class="line">      return parent.pollBuffer();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">BufferAndBacklog pollBuffer() &#123;</span><br><span class="line">   synchronized (buffers) &#123;</span><br><span class="line">      Buffer buffer &#x3D; null;</span><br><span class="line"></span><br><span class="line">      if (buffers.isEmpty()) &#123;</span><br><span class="line">         flushRequested &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      while (!buffers.isEmpty()) &#123;</span><br><span class="line">         BufferConsumer bufferConsumer &#x3D; buffers.peek();</span><br><span class="line"></span><br><span class="line">         buffer &#x3D; bufferConsumer.build();</span><br><span class="line"></span><br><span class="line">         checkState(bufferConsumer.isFinished() || buffers.size() &#x3D;&#x3D; 1,</span><br><span class="line">            &quot;When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.&quot;);</span><br><span class="line"></span><br><span class="line">         if (buffers.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; turn off flushRequested flag if we drained all of the available data</span><br><span class="line">            flushRequested &#x3D; false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (bufferConsumer.isFinished()) &#123;</span><br><span class="line">            buffers.pop().close();</span><br><span class="line">            decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (buffer.readableBytes() &gt; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">         buffer.recycleBuffer();</span><br><span class="line">         buffer &#x3D; null;</span><br><span class="line">         if (!bufferConsumer.isFinished()) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (buffer &#x3D;&#x3D; null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      updateStatistics(buffer);</span><br><span class="line">      &#x2F;&#x2F; Do not report last remaining buffer on buffers as available to read (assuming it&#39;s unfinished).</span><br><span class="line">      &#x2F;&#x2F; It will be reported for reading either on flush or when the number of buffers in the queue</span><br><span class="line">      &#x2F;&#x2F; will be 2 or more.</span><br><span class="line">      return new BufferAndBacklog(</span><br><span class="line">         buffer,</span><br><span class="line">         isAvailableUnsafe(),</span><br><span class="line">         getBuffersInBacklog(),</span><br><span class="line">         nextBufferIsEventUnsafe());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已上是task内部的数据传递，再看下task之间的数据传递，涉及到网络协议</p>
<p>在Task启动的时候，会调用inputgate的setup方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void setupPartitionsAndGates(</span><br><span class="line">   ResultPartitionWriter[] producedPartitions, InputGate[] inputGates) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   for (ResultPartitionWriter partition : producedPartitions) &#123;</span><br><span class="line">      partition.setup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; InputGates must be initialized after the partitions, since during InputGate#setup</span><br><span class="line">   &#x2F;&#x2F; we are requesting partitions</span><br><span class="line">   for (InputGate gate : inputGates) &#123;</span><br><span class="line">      gate.setup();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingleInputGate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void setup() throws IOException, InterruptedException &#123;</span><br><span class="line">   checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in input gate setup logic: Already registered buffer pool.&quot;);</span><br><span class="line">   &#x2F;&#x2F; assign exclusive buffers to input channels directly and use the rest for floating buffers</span><br><span class="line">   assignExclusiveSegments();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分配 LocalBufferPool 本地缓冲池，这是所有 channel 共享的</span><br><span class="line">   BufferPool bufferPool &#x3D; bufferPoolFactory.get();</span><br><span class="line">   setBufferPool(bufferPool);</span><br><span class="line"></span><br><span class="line">   requestPartitions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void assignExclusiveSegments() throws IOException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">			for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">				if (inputChannel instanceof RemoteInputChannel) &#123;</span><br><span class="line">				&#x2F;&#x2F;RemoteInputChannel 请求独占的 buffer</span><br><span class="line">					((RemoteInputChannel) inputChannel).assignExclusiveSegments();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">void requestPartitions() throws IOException, InterruptedException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">			if (!requestedPartitionsFlag) &#123;</span><br><span class="line">				if (closeFuture.isDone()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Already released.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Sanity checks</span><br><span class="line">				if (numberOfInputChannels !&#x3D; inputChannels.size()) &#123;</span><br><span class="line">					throw new IllegalStateException(String.format(</span><br><span class="line">						&quot;Bug in input gate setup logic: mismatch between &quot; +</span><br><span class="line">						&quot;number of total input channels [%s] and the currently set number of input &quot; +</span><br><span class="line">						&quot;channels [%s].&quot;,</span><br><span class="line">						inputChannels.size(),</span><br><span class="line">						numberOfInputChannels));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">					inputChannel.requestSubpartition(consumedSubpartitionIndex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			requestedPartitionsFlag &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteInputChannel 管理可用 buffer</p>
<p>在 <code>RemoteInputChannel</code> 内部使用 <code>AvailableBufferQueue</code> 来管理所有可用的 buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分配独占的 buffer</span><br><span class="line">void assignExclusiveSegments() throws IOException &#123;</span><br><span class="line">   checkState(initialCredit &#x3D;&#x3D; 0, &quot;Bug in input channel setup logic: exclusive buffers have &quot; +</span><br><span class="line">      &quot;already been set for this input channel.&quot;);</span><br><span class="line"></span><br><span class="line">   Collection&lt;MemorySegment&gt; segments &#x3D; checkNotNull(memorySegmentProvider.requestMemorySegments());</span><br><span class="line">   checkArgument(!segments.isEmpty(), &quot;The number of exclusive buffers per channel should be larger than 0.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始的Credit</span><br><span class="line">   initialCredit &#x3D; segments.size();</span><br><span class="line">   numRequiredBuffers &#x3D; segments.size();</span><br><span class="line"></span><br><span class="line">   synchronized (bufferQueue) &#123;</span><br><span class="line">      for (MemorySegment segment : segments) &#123;</span><br><span class="line">      &#x2F;&#x2F;注意这个 NetworkBuffer 的回收器是 RemoteInputChannel 自身</span><br><span class="line">         bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AvailableBufferQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static class AvailableBufferQueue &#123;</span><br><span class="line">&#x2F;&#x2F;添加一个独占的buffer，如果当前可用的 buffer 总量超出了要求的数量，则向本地缓冲池归还一个流动的buffer</span><br><span class="line">		&#x2F;&#x2F;返回值是新增的 buffer 数量</span><br><span class="line">   int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) &#123;</span><br><span class="line">			exclusiveBuffers.add(buffer);</span><br><span class="line">			if (getAvailableBufferSize() &gt; numRequiredBuffers) &#123;</span><br><span class="line">				Buffer floatingBuffer &#x3D; floatingBuffers.poll();</span><br><span class="line">				floatingBuffer.recycleBuffer();</span><br><span class="line">				&#x2F;&#x2F;加一个，归还一个，相当于没加</span><br><span class="line">				return 0;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NetworkBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void recycleBuffer() &#123;</span><br><span class="line">&#x2F;&#x2F;最终调用deallocate</span><br><span class="line">   release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void deallocate() &#123;</span><br><span class="line">&#x2F;&#x2F;调用RemoteInputChannel 的recycle</span><br><span class="line">		recycler.recycle(memorySegment);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteInputChannel.recycle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;独占的 buffer 释放后会直接被 RemoteInputChannel 回收</span><br><span class="line">public void recycle(MemorySegment segment) &#123;</span><br><span class="line">   int numAddedBuffers;</span><br><span class="line"></span><br><span class="line">   synchronized (bufferQueue) &#123;</span><br><span class="line">      &#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">      &#x2F;&#x2F; after releaseAllResources() released all buffers (see below for details).</span><br><span class="line">      if (isReleased.get()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            &#x2F;&#x2F;如果这个 channle 已经被释放，这个 MemorySegment 会被归还给 NetworkBufferPoolmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));</span><br><span class="line">            return;</span><br><span class="line">         &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.rethrow(t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;重新加入到 AvailableBufferQueue 中</span><br><span class="line">      numAddedBuffers &#x3D; bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (numAddedBuffers &gt; 0 &amp;&amp; unannouncedCredit.getAndAdd(numAddedBuffers) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      notifyCreditAvailable();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面SingleInputGate的requestPartitions方法里会调用inputChannel.requestSubpartition请求远端子分区，在RemoteInputChannel中的实现如下，会创建一个 <code>PartitionRequestClient</code>，并通过 Netty 发送 <code>PartitionRequest</code> 请求，这时会带上当前 InputChannel 的 id 和初始的 credit 信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException &#123;</span><br><span class="line">&#x2F;&#x2F;REMOTE，需要网络通信，使用 Netty 建立网络</span><br><span class="line">&#x2F;&#x2F;通过 ConnectionManager 来建立连接：创建 PartitionRequestClient，通过 PartitionRequestClient 发起请求</span><br><span class="line">   if (partitionRequestClient &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; Create a client and request the partition</span><br><span class="line">      try &#123;</span><br><span class="line">         partitionRequestClient &#x3D; connectionManager.createPartitionRequestClient(connectionId);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">         &#x2F;&#x2F; IOExceptions indicate that we could not open a connection to the remote TaskExecutor</span><br><span class="line">         throw new PartitionConnectionException(partitionId, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求分区，通过 netty 发起请求</span><br><span class="line">      partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyConnectionManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public PartitionRequestClient createPartitionRequestClient(ConnectionID connectionId)</span><br><span class="line">      throws IOException, InterruptedException &#123;</span><br><span class="line">      &#x2F;&#x2F;这里实际上会建立和其它 Task 的 Server 的连接</span><br><span class="line">		&#x2F;&#x2F;返回的 PartitionRequestClient 中封装了 netty channel 和 channel handler</span><br><span class="line">   return partitionRequestClientFactory.createPartitionRequestClient(connectionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PartitionRequestClientFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">NettyPartitionRequestClient createPartitionRequestClient(ConnectionID connectionId) throws IOException, InterruptedException &#123;</span><br><span class="line">   Object entry;</span><br><span class="line">   NettyPartitionRequestClient client &#x3D; null;</span><br><span class="line"></span><br><span class="line">   while (client &#x3D;&#x3D; null) &#123;</span><br><span class="line">      entry &#x3D; clients.get(connectionId);</span><br><span class="line"></span><br><span class="line">      if (entry !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;连接已经建立</span><br><span class="line">         &#x2F;&#x2F; Existing channel or connecting channel</span><br><span class="line">         if (entry instanceof NettyPartitionRequestClient) &#123;</span><br><span class="line">            client &#x3D; (NettyPartitionRequestClient) entry;</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            ConnectingChannel future &#x3D; (ConnectingChannel) entry;</span><br><span class="line">            client &#x3D; future.waitForChannel();</span><br><span class="line"></span><br><span class="line">            clients.replace(connectionId, future, client);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; No channel yet. Create one, but watch out for a race.</span><br><span class="line">         &#x2F;&#x2F; We create a &quot;connecting future&quot; and atomically add it to the map.</span><br><span class="line">         &#x2F;&#x2F; Only the thread that really added it establishes the channel.</span><br><span class="line">         &#x2F;&#x2F; The others need to wait on that original establisher&#39;s future.</span><br><span class="line">         &#x2F;&#x2F; 连接创建成功后会回调 handInChannel 方法</span><br><span class="line">         ConnectingChannel connectingChannel &#x3D; new ConnectingChannel(connectionId, this);</span><br><span class="line">         Object old &#x3D; clients.putIfAbsent(connectionId, connectingChannel);</span><br><span class="line"></span><br><span class="line">         if (old &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;连接到 Netty Server</span><br><span class="line">          nettyClient.connect(connectionId.getAddress()).addListener(connectingChannel);</span><br><span class="line"></span><br><span class="line">            client &#x3D; connectingChannel.waitForChannel();</span><br><span class="line"></span><br><span class="line">            clients.replace(connectionId, connectingChannel, client);</span><br><span class="line">         &#125;</span><br><span class="line">         else if (old instanceof ConnectingChannel) &#123;</span><br><span class="line">            client &#x3D; ((ConnectingChannel) old).waitForChannel();</span><br><span class="line">            clients.replace(connectionId, old, client);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            client &#x3D; (NettyPartitionRequestClient) old;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure to increment the reference count before handing a client</span><br><span class="line">      &#x2F;&#x2F; out to ensure correct bookkeeping for channel closing.</span><br><span class="line">      if (!client.incrementReferenceCounter()) &#123;</span><br><span class="line">         destroyPartitionRequestClient(connectionId, client);</span><br><span class="line">         client &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了PartitionRequestClient之后，发送请求，调用partitionRequestClient的requestSubpartition，PartitionRequestClient接口的实现类是NettyPartitionRequestClient，进入NettyPartitionRequestClient的requestSubpartition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void requestSubpartition(</span><br><span class="line">      final ResultPartitionID partitionId,</span><br><span class="line">      final int subpartitionIndex,</span><br><span class="line">      final RemoteInputChannel inputChannel,</span><br><span class="line">      int delayMs) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   checkNotClosed();</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Requesting subpartition &#123;&#125; of partition &#123;&#125; with &#123;&#125; ms delay.&quot;,</span><br><span class="line">         subpartitionIndex, partitionId, delayMs);</span><br><span class="line">&#x2F;&#x2F;向 NetworkClientHandler 注册当前 RemoteInputChannel</span><br><span class="line">		&#x2F;&#x2F;单个 Task 所有的 RemoteInputChannel 的数据传输都通过这个 PartitionRequestClient 处理</span><br><span class="line">   clientHandler.addInputChannel(inputChannel);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PartitionRequest封装了请求的 sub-partition 的信息，当前 input channel 的 ID，以及初始 credit</span><br><span class="line">   final PartitionRequest request &#x3D; new PartitionRequest(</span><br><span class="line">         partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求的监听</span><br><span class="line">   final ChannelFutureListener listener &#x3D; new ChannelFutureListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">         if (!future.isSuccess()) &#123;</span><br><span class="line">         &#x2F;&#x2F;如果请求发送失败，要移除当前的 inputChannel</span><br><span class="line">            clientHandler.removeInputChannel(inputChannel);</span><br><span class="line">            SocketAddress remoteAddr &#x3D; future.channel().remoteAddress();</span><br><span class="line">            inputChannel.onError(</span><br><span class="line">                  new LocalTransportException(</span><br><span class="line">                     String.format(&quot;Sending the partition request to &#39;%s&#39; failed.&quot;, remoteAddr),</span><br><span class="line">                     future.channel().localAddress(), future.cause()</span><br><span class="line">                  ));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 netty 发送请求</span><br><span class="line">   if (delayMs &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      ChannelFuture f &#x3D; tcpChannel.writeAndFlush(request);</span><br><span class="line">      f.addListener(listener);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final ChannelFuture[] f &#x3D; new ChannelFuture[1];</span><br><span class="line">      tcpChannel.eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            f[0] &#x3D; tcpChannel.writeAndFlush(request);</span><br><span class="line">            f[0].addListener(listener);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, delayMs, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是生产者和消费者各自的处理流程</p>
<p>生产者端即 <code>ResultSubpartition</code> 一侧，在网络通信中对应 <code>NettyServer</code>。<code>NettyServer</code> 有两个重要的 <code>ChannelHandler</code>，即 <code>PartitionRequestServerHandler</code> 和 <code>PartitionRequestQueue</code>。其中，<code>PartitionRequestServerHandler</code> 负责处理消费端通过 <code>PartitionRequestClient</code> 发送的 <code>PartitionRequest</code> 和 <code>AddCredit</code> 等请求；<code>PartitionRequestQueue</code> 则包含了一个可以从中读取数据的 <code>NetworkSequenceViewReader</code> 队列，它会监听 Netty Channel 的可写入状态，一旦可以写入数据，就会从 <code>NetworkSequenceViewReader</code> 消费数据写入 Netty Channel。</p>
<p>消费端即 <code>RemoteInputChannel</code> 一侧，在网络通信中对应 <code>NettyClient</code></p>
<p>而<code>NettyServer</code>和<code>NettyClient</code>是在启动TaskManager的startTaskManager过程中创建的，TaskManagerServices.fromConfiguration最终调用NettyConnectionManager的start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int start() throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;初始化 Netty Client</span><br><span class="line">   client.init(nettyProtocol, bufferPool);</span><br><span class="line">&#x2F;&#x2F;初始化并启动 Netty Server</span><br><span class="line">   return server.init(nettyProtocol, bufferPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyClient：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException &#123;</span><br><span class="line">   checkState(bootstrap &#x3D;&#x3D; null, &quot;Netty client has already been initialized.&quot;);</span><br><span class="line"></span><br><span class="line">   this.protocol &#x3D; protocol;</span><br><span class="line"></span><br><span class="line">   final long start &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">   bootstrap &#x3D; new Bootstrap();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Transport-specific configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   switch (config.getTransportType()) &#123;</span><br><span class="line">      case NIO:</span><br><span class="line">         initNioBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case EPOLL:</span><br><span class="line">         initEpollBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case AUTO:</span><br><span class="line">         if (Epoll.isAvailable()) &#123;</span><br><span class="line">            initEpollBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using EPOLL.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            initNioBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using NIO.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bootstrap.option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line">   bootstrap.option(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Timeout for new connections</span><br><span class="line">   bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getClientConnectTimeoutSeconds() * 1000);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Pooled allocator for Netty&#39;s ByteBuf instances</span><br><span class="line">   bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Receive and send buffer size</span><br><span class="line">   int receiveAndSendBufferSize &#x3D; config.getSendAndReceiveBufferSize();</span><br><span class="line">   if (receiveAndSendBufferSize &gt; 0) &#123;</span><br><span class="line">      bootstrap.option(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize);</span><br><span class="line">      bootstrap.option(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      clientSSLFactory &#x3D; config.createClientSSLEngineFactory();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new IOException(&quot;Failed to initialize SSL Context for the Netty client&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">   LOG.info(&quot;Successful initialization (took &#123;&#125; ms).&quot;, duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyServer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">int init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException &#123;</span><br><span class="line">   return init(</span><br><span class="line">      nettyBufferPool,</span><br><span class="line">      sslHandlerFactory -&gt; new ServerChannelInitializer(protocol, sslHandlerFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int init(</span><br><span class="line">      NettyBufferPool nettyBufferPool,</span><br><span class="line">      Function&lt;SSLHandlerFactory, ServerChannelInitializer&gt; channelInitializer) throws IOException &#123;</span><br><span class="line">   checkState(bootstrap &#x3D;&#x3D; null, &quot;Netty server has already been initialized.&quot;);</span><br><span class="line"></span><br><span class="line">   final long start &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">   bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Transport-specific configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   switch (config.getTransportType()) &#123;</span><br><span class="line">      case NIO:</span><br><span class="line">         initNioBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case EPOLL:</span><br><span class="line">         initEpollBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case AUTO:</span><br><span class="line">         if (Epoll.isAvailable()) &#123;</span><br><span class="line">            initEpollBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using EPOLL.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            initNioBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using NIO.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Server bind address</span><br><span class="line">   bootstrap.localAddress(config.getServerAddress(), config.getServerPort());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Pooled allocators for Netty&#39;s ByteBuf instances</span><br><span class="line">   bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line">   bootstrap.childOption(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line"></span><br><span class="line">   if (config.getServerConnectBacklog() &gt; 0) &#123;</span><br><span class="line">      bootstrap.option(ChannelOption.SO_BACKLOG, config.getServerConnectBacklog());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Receive and send buffer size</span><br><span class="line">   int receiveAndSendBufferSize &#x3D; config.getSendAndReceiveBufferSize();</span><br><span class="line">   if (receiveAndSendBufferSize &gt; 0) &#123;</span><br><span class="line">      bootstrap.childOption(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize);</span><br><span class="line">      bootstrap.childOption(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Low and high water marks for flow control</span><br><span class="line">   &#x2F;&#x2F; hack around the impossibility (in the current netty version) to set both watermarks at</span><br><span class="line">   &#x2F;&#x2F; the same time:</span><br><span class="line">   final int defaultHighWaterMark &#x3D; 64 * 1024; &#x2F;&#x2F; from DefaultChannelConfig (not exposed)</span><br><span class="line">   final int newLowWaterMark &#x3D; config.getMemorySegmentSize() + 1;</span><br><span class="line">   final int newHighWaterMark &#x3D; 2 * config.getMemorySegmentSize();</span><br><span class="line">   &#x2F;&#x2F;配置水位线，确保不往网络中写入太多数据</span><br><span class="line">		&#x2F;&#x2F;当输出缓冲中的字节数超过高水位值, 则 Channel.isWritable() 会返回false</span><br><span class="line">		&#x2F;&#x2F;当输出缓存中的字节数低于低水位值, 则 Channel.isWritable() 会重新返回true</span><br><span class="line">		&#x2F;&#x2F;背压就是这么产生的</span><br><span class="line">   if (newLowWaterMark &gt; defaultHighWaterMark) &#123;</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, newHighWaterMark);</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, newLowWaterMark);</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; including (newHighWaterMark &lt; defaultLowWaterMark)</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, newLowWaterMark);</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, newHighWaterMark);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; SSL related configuration</span><br><span class="line">   final SSLHandlerFactory sslHandlerFactory;</span><br><span class="line">   try &#123;</span><br><span class="line">      sslHandlerFactory &#x3D; config.createServerSSLEngineFactory();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new IOException(&quot;Failed to initialize SSL Context for the Netty Server&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Child channel pipeline for accepted connections</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bootstrap.childHandler(channelInitializer.apply(sslHandlerFactory));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Start Server</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bindFuture &#x3D; bootstrap.bind().syncUninterruptibly();</span><br><span class="line"></span><br><span class="line">   localAddress &#x3D; (InetSocketAddress) bindFuture.channel().localAddress();</span><br><span class="line"></span><br><span class="line">   final long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">   LOG.info(&quot;Successful initialization (took &#123;&#125; ms). Listening on SocketAddress &#123;&#125;.&quot;, duration, localAddress);</span><br><span class="line"></span><br><span class="line">   return localAddress.getPort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而参数NettyProtocol类提供了 <code>NettyClient</code> 和 <code>NettyServer</code> 引导启动注册的一系列 Channel Handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public class NettyProtocol &#123;</span><br><span class="line"></span><br><span class="line">   private final NettyMessage.NettyMessageEncoder</span><br><span class="line">      messageEncoder &#x3D; new NettyMessage.NettyMessageEncoder();</span><br><span class="line"></span><br><span class="line">   private final ResultPartitionProvider partitionProvider;</span><br><span class="line">   private final TaskEventPublisher taskEventPublisher;</span><br><span class="line"></span><br><span class="line">   NettyProtocol(ResultPartitionProvider partitionProvider, TaskEventPublisher taskEventPublisher) &#123;</span><br><span class="line">      this.partitionProvider &#x3D; partitionProvider;</span><br><span class="line">      this.taskEventPublisher &#x3D; taskEventPublisher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the server channel handlers.</span><br><span class="line">    *</span><br><span class="line">    * &lt;pre&gt;</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * |                        SERVER CHANNEL PIPELINE                    |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |    +----------+----------+ (3) write  +----------------------+    |</span><br><span class="line">    * |    | Queue of queues     +-----------&gt;| Message encoder      |    |</span><br><span class="line">    * |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">    * |              &#x2F;|\                                 \|&#x2F;              |</span><br><span class="line">    * |               | (2) enqueue                       |               |</span><br><span class="line">    * |    +----------+----------+                        |               |</span><br><span class="line">    * |    | Request handler     |                        |               |</span><br><span class="line">    * |    +----------+----------+                        |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |   +-----------+-----------+                       |               |</span><br><span class="line">    * |   | Message+Frame decoder |                       |               |</span><br><span class="line">    * |   +-----------+-----------+                       |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               | (1) client request               \|&#x2F;</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * &lt;&#x2F;pre&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return channel handlers</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ChannelHandler[] getServerChannelHandlers() &#123;</span><br><span class="line">   &#x2F;&#x2F;netty server 端的 ChannelHandler</span><br><span class="line">      PartitionRequestQueue queueOfPartitionQueues &#x3D; new PartitionRequestQueue();</span><br><span class="line">      PartitionRequestServerHandler serverHandler &#x3D; new PartitionRequestServerHandler(</span><br><span class="line">         partitionProvider,</span><br><span class="line">         taskEventPublisher,</span><br><span class="line">         queueOfPartitionQueues);</span><br><span class="line"></span><br><span class="line">      return new ChannelHandler[] &#123;</span><br><span class="line">         messageEncoder,</span><br><span class="line">         new NettyMessage.NettyMessageDecoder(),</span><br><span class="line">         serverHandler,</span><br><span class="line">         queueOfPartitionQueues</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the client channel handlers.</span><br><span class="line">    *</span><br><span class="line">    * &lt;pre&gt;</span><br><span class="line">    *     +-----------+----------+            +----------------------+</span><br><span class="line">    *     | Remote input channel |            | request client       |</span><br><span class="line">    *     +-----------+----------+            +-----------+----------+</span><br><span class="line">    *                 |                                   | (1) write</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |     CLIENT CHANNEL PIPELINE       |               |</span><br><span class="line">    * |               |                                  \|&#x2F;              |</span><br><span class="line">    * |    +----------+----------+            +----------------------+    |</span><br><span class="line">    * |    | Request handler     +            | Message encoder      |    |</span><br><span class="line">    * |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">    * |              &#x2F;|\                                 \|&#x2F;              |</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |    +----------+------------+                      |               |</span><br><span class="line">    * |    | Message+Frame decoder |                      |               |</span><br><span class="line">    * |    +----------+------------+                      |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               | (3) server response              \|&#x2F; (2) client request</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * &lt;&#x2F;pre&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return channel handlers</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ChannelHandler[] getClientChannelHandlers() &#123;</span><br><span class="line">   &#x2F;&#x2F;netty client 端的 ChannelHandler</span><br><span class="line">      return new ChannelHandler[] &#123;</span><br><span class="line">         messageEncoder,</span><br><span class="line">         new NettyMessage.NettyMessageDecoder(),</span><br><span class="line">         new CreditBasedPartitionRequestClientHandler()&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeSending.png" alt></p>
<p>首先，当 <code>NettyServer</code> 接收到 <code>PartitionRequest</code> 消息后，<code>PartitionRequestServerHandler</code> 会创建一个 <code>NetworkSequenceViewReader</code> 对象，请求创建 <code>ResultSubpartitionView</code>, 并将 <code>NetworkSequenceViewReader</code> 保存在 <code>PartitionRequestQueue</code> 中。<code>PartitionRequestQueue</code> 会持有所有请求消费数据的 <code>RemoteInputChannel</code> 的 ID 和 <code>NetworkSequenceViewReader</code> 之间的映射关系。</p>
<p>我们已经知道，<code>ResultSubpartitionView</code> 用来消费 <code>ResultSubpartition</code> 中的数据，并在 <code>ResultSubpartition</code> 中有数据可用时获得提醒；<code>NetworkSequenceViewReader</code> 则相当于对 <code>ResultSubpartition</code> 的一层包装，她会按顺序为读取的每一个 buffer 分配一个序列号，并且记录了接收数据的 <code>RemoteInputChannel</code> 的 ID。在使用 Credit-based Flow Control 的情况下，<code>NetworkSequenceViewReader</code> 的具体实现对应为 <code>CreditBasedSequenceNumberingViewReader</code>。 <code>CreditBasedSequenceNumberingViewReader</code> 同时还实现了 <code>BufferAvailabilityListener</code> 接口，因而可以作为 <code>PipelinedSubpartitionView</code> 的回调对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestServerHandler extends SimpleChannelInboundHandler&lt;NettyMessage&gt; &#123;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, NettyMessage msg) throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class&lt;?&gt; msgClazz &#x3D; msg.getClass();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			&#x2F;&#x2F; Intermediate result partition requests</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			if (msgClazz &#x3D;&#x3D; PartitionRequest.class) &#123;</span><br><span class="line">			&#x2F;&#x2F;Server 端接收到 client 发送的 PartitionRequest</span><br><span class="line">				PartitionRequest request &#x3D; (PartitionRequest) msg;</span><br><span class="line"></span><br><span class="line">				LOG.debug(&quot;Read channel on &#123;&#125;: &#123;&#125;.&quot;, ctx.channel().localAddress(), request);</span><br><span class="line"></span><br><span class="line">				try &#123;</span><br><span class="line">					NetworkSequenceViewReader reader;</span><br><span class="line">					reader &#x3D; new CreditBasedSequenceNumberingViewReader(</span><br><span class="line">						request.receiverId,</span><br><span class="line">						request.credit,</span><br><span class="line">						outboundQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 ResultPartitionProvider（实际上就是 ResultPartitionManager）创建 ResultSubpartitionView</span><br><span class="line">					&#x2F;&#x2F;在有可被消费的数据产生后，PartitionRequestQueue.notifyReaderNonEmpty 会被回调，进而在 netty channelPipeline 上触发一次 fireUserEventTriggered</span><br><span class="line">					reader.requestSubpartitionView(</span><br><span class="line">						partitionProvider,</span><br><span class="line">						request.partitionId,</span><br><span class="line">						request.queueIndex);</span><br><span class="line">&#x2F;&#x2F;通知 PartitionRequestQueue 创建了一个 NetworkSequenceViewReader</span><br><span class="line">					outboundQueue.notifyReaderCreated(reader);</span><br><span class="line">				&#125; catch (PartitionNotFoundException notFound) &#123;</span><br><span class="line">					respondWithError(ctx, notFound, request.receiverId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			&#x2F;&#x2F; Task events</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			else if (msgClazz &#x3D;&#x3D; TaskEventRequest.class) &#123;</span><br><span class="line">				TaskEventRequest request &#x3D; (TaskEventRequest) msg;</span><br><span class="line"></span><br><span class="line">				if (!taskEventPublisher.publish(request.partitionId, request.event)) &#123;</span><br><span class="line">					respondWithError(ctx, new IllegalArgumentException(&quot;Task event receiver not found.&quot;), request.receiverId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; CancelPartitionRequest.class) &#123;</span><br><span class="line">				CancelPartitionRequest request &#x3D; (CancelPartitionRequest) msg;</span><br><span class="line"></span><br><span class="line">				outboundQueue.cancel(request.receiverId);</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; CloseRequest.class) &#123;</span><br><span class="line">				outboundQueue.close();</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; AddCredit.class) &#123;</span><br><span class="line">				AddCredit request &#x3D; (AddCredit) msg;</span><br><span class="line"></span><br><span class="line">				outboundQueue.addCredit(request.receiverId, request.credit);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.warn(&quot;Received unexpected client request: &#123;&#125;&quot;, msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			respondWithError(ctx, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>CreditBasedSequenceNumberingViewReader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader &#123;</span><br><span class="line"></span><br><span class="line">   private final Object requestLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应的 RemoteInputChannel 的 ID</span><br><span class="line">   private final InputChannelID receiverId;</span><br><span class="line"></span><br><span class="line">   private final PartitionRequestQueue requestQueue;</span><br><span class="line">&#x2F;&#x2F;消费 ResultSubpartition 的数据，并在 ResultSubpartition 有数据可用时获得通知</span><br><span class="line">   private volatile ResultSubpartitionView subpartitionView;</span><br><span class="line">&#x2F;&#x2F;numCreditsAvailable的值是消费端还能够容纳的buffer的数量，也就是允许生产端发送的buffer的数量</span><br><span class="line">   &#x2F;** The number of available buffers for holding data on the consumer side. *&#x2F;</span><br><span class="line">   private int numCreditsAvailable;</span><br><span class="line"> &#x2F;&#x2F;序列号，自增</span><br><span class="line">   private int sequenceNumber &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;创建一个 ResultSubpartitionView，用于读取数据，并在有数据可用时获得通知</span><br><span class="line">   CreditBasedSequenceNumberingViewReader(</span><br><span class="line">         InputChannelID receiverId,</span><br><span class="line">         int initialCredit,</span><br><span class="line">         PartitionRequestQueue requestQueue) &#123;</span><br><span class="line"></span><br><span class="line">      this.receiverId &#x3D; receiverId;</span><br><span class="line">      this.numCreditsAvailable &#x3D; initialCredit;</span><br><span class="line">      this.requestQueue &#x3D; requestQueue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void requestSubpartitionView(</span><br><span class="line">      ResultPartitionProvider partitionProvider,</span><br><span class="line">      ResultPartitionID resultPartitionId,</span><br><span class="line">      int subPartitionIndex) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      synchronized (requestLock) &#123;</span><br><span class="line">         if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; This this call can trigger a notification we have to</span><br><span class="line">            &#x2F;&#x2F; schedule a separate task at the event loop that will</span><br><span class="line">            &#x2F;&#x2F; start consuming this. Otherwise the reference to the</span><br><span class="line">            &#x2F;&#x2F; view cannot be available in getNextBuffer().</span><br><span class="line">            this.subpartitionView &#x3D; partitionProvider.createSubpartitionView(</span><br><span class="line">               resultPartitionId,</span><br><span class="line">               subPartitionIndex,</span><br><span class="line">               this);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Subpartition already requested&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;当PartitionRequestQueue的WriteAndFlushNextMessageIfPossibleListener监听到写入数据时通过writeAndFlushNextMessageIfPossible调用getNextBuffer获取数据</span><br><span class="line">   @Override</span><br><span class="line">	public BufferAndAvailability getNextBuffer() throws IOException, InterruptedException &#123;</span><br><span class="line">		BufferAndBacklog next &#x3D; subpartitionView.getNextBuffer();</span><br><span class="line">		if (next !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;序列号</span><br><span class="line">			sequenceNumber++;</span><br><span class="line"></span><br><span class="line">			if (next.buffer().isBuffer() &amp;&amp; --numCreditsAvailable &lt; 0) &#123;</span><br><span class="line">			&#x2F;&#x2F;要发送一个buffer，对应的 numCreditsAvailable 要减 1</span><br><span class="line">				throw new IllegalStateException(&quot;no credit available&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return new BufferAndAvailability(</span><br><span class="line">				next.buffer(), isAvailable(next), next.buffersInBacklog());</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;是否还可以消费数据：</span><br><span class="line">	&#x2F;&#x2F; 1. ResultSubpartition 中有更多的数据</span><br><span class="line">	&#x2F;&#x2F; 2. credit &gt; 0 或者下一条数据是事件(事件不需要消耗credit)</span><br><span class="line">	private boolean isAvailable(BufferAndBacklog bufferAndBacklog) &#123;</span><br><span class="line">		&#x2F;&#x2F; BEWARE: this must be in sync with #isAvailable()!</span><br><span class="line">		if (numCreditsAvailable &gt; 0) &#123;</span><br><span class="line">			return bufferAndBacklog.isMoreAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return bufferAndBacklog.nextBufferIsEvent();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;在 ResultSubparition 中有数据时会回调该方法</span><br><span class="line">	@Override</span><br><span class="line">	public void notifyDataAvailable() &#123;</span><br><span class="line">	&#x2F;&#x2F;告知 PartitionRequestQueue 当前 ViewReader 有数据可读</span><br><span class="line">		requestQueue.notifyReaderNonEmpty(this);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>PartitionRequestQueue</code> 负责将 <code>ResultSubparition</code> 中的数据通过网络发送给 <code>RemoteInputChannel</code>。在 <code>PartitionRequestQueue</code> 中保存了所有的 <code>NetworkSequenceViewReader</code> 和 <code>InputChannelID</code> 之间的映射关系，以及一个 <code>ArrayDeque availableReaders</code> 队列。当一个 <code>NetworkSequenceViewReader</code> 中有数据可以被消费时，就会被加入到 <code>availableReaders</code> 队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestQueue extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(PartitionRequestQueue.class);</span><br><span class="line"></span><br><span class="line">   private final ChannelFutureListener writeListener &#x3D; new WriteAndFlushNextMessageIfPossibleListener();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The readers which are already enqueued available for transferring data. *&#x2F;</span><br><span class="line">   private final ArrayDeque&lt;NetworkSequenceViewReader&gt; availableReaders &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** All the readers created for the consumers&#39; partition requests. *&#x2F;</span><br><span class="line">   private final ConcurrentMap&lt;InputChannelID, NetworkSequenceViewReader&gt; allReaders &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private boolean fatalError;</span><br><span class="line"></span><br><span class="line">   private ChannelHandlerContext ctx;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;添加新的 NetworkSequenceViewReader</span><br><span class="line">   public void notifyReaderCreated(final NetworkSequenceViewReader reader) &#123;</span><br><span class="line">		allReaders.put(reader.getReceiverId(), reader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知 NetworkSequenceViewReader 有数据可读取</span><br><span class="line">   void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) &#123;</span><br><span class="line">      &#x2F;&#x2F; The notification might come from the same thread. For the initial writes this</span><br><span class="line">      &#x2F;&#x2F; might happen before the reader has set its reference to the view, because</span><br><span class="line">      &#x2F;&#x2F; creating the queue and the initial notification happen in the same method call.</span><br><span class="line">      &#x2F;&#x2F; This can be resolved by separating the creation of the view and allowing</span><br><span class="line">      &#x2F;&#x2F; notifications.</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; TODO This could potentially have a bad performance impact as in the</span><br><span class="line">      &#x2F;&#x2F; worst case (network consumes faster than the producer) each buffer</span><br><span class="line">      &#x2F;&#x2F; will trigger a separate event loop task being scheduled.</span><br><span class="line">      &#x2F;&#x2F;触发一次用户自定义事件</span><br><span class="line">      ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(reader));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;fireUserEventTriggered最终调用userEventTriggered</span><br><span class="line">   @Override</span><br><span class="line">	public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; The user event triggered event loop callback is used for thread-safe</span><br><span class="line">		&#x2F;&#x2F; hand over of reader queues and cancelled producers.</span><br><span class="line"></span><br><span class="line">		if (msg instanceof NetworkSequenceViewReader) &#123;</span><br><span class="line">		&#x2F;&#x2F;NetworkSequenceViewReader有数据可读取，加入队列中</span><br><span class="line">			enqueueAvailableReader((NetworkSequenceViewReader) msg);</span><br><span class="line">		&#125; else if (msg.getClass() &#x3D;&#x3D; InputChannelID.class) &#123;</span><br><span class="line">			&#x2F;&#x2F; Release partition view that get a cancel request.</span><br><span class="line">			&#x2F;&#x2F; 对应的 RemoteInputChannel 请求取消消费</span><br><span class="line">			InputChannelID toCancel &#x3D; (InputChannelID) msg;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; remove reader from queue of available readers</span><br><span class="line">			availableReaders.removeIf(reader -&gt; reader.getReceiverId().equals(toCancel));</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; remove reader from queue of all readers and release its resource</span><br><span class="line">			final NetworkSequenceViewReader toRelease &#x3D; allReaders.remove(toCancel);</span><br><span class="line">			if (toRelease !&#x3D; null) &#123;</span><br><span class="line">				releaseViewReader(toRelease);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctx.fireUserEventTriggered(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;加入队列</span><br><span class="line">	private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception &#123;</span><br><span class="line">		if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) &#123;</span><br><span class="line">		&#x2F;&#x2F;已经被注册到队列中，或者暂时没有 buffer 或没有 credit 可用</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Queue an available reader for consumption. If the queue is empty,</span><br><span class="line">		&#x2F;&#x2F; we try trigger the actual write. Otherwise this will be handled by</span><br><span class="line">		&#x2F;&#x2F; the writeAndFlushNextMessageIfPossible calls.</span><br><span class="line">		boolean triggerWrite &#x3D; availableReaders.isEmpty();</span><br><span class="line">		registerAvailableReader(reader);</span><br><span class="line"></span><br><span class="line">		if (triggerWrite) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果这是队列中第一个元素，调用 writeAndFlushNextMessageIfPossible 发送数据</span><br><span class="line">			writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>PartitionRequestQueue</code> 会监听 Netty Channel 的可写入状态，当 Channel 可写入时，就会从 <code>availableReaders</code> 队列中取出 <code>NetworkSequenceViewReader</code>，读取数据并写入网络。可写入状态是 Netty 通过水位线进行控制的，<code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException &#123;</span><br><span class="line">   if (fatalError || !channel.isWritable()) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果当前不可写入，则直接返回</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The logic here is very similar to the combined input gate and local</span><br><span class="line">   &#x2F;&#x2F; input channel logic. You can think of this class acting as the input</span><br><span class="line">   &#x2F;&#x2F; gate and the consumed views as the local input channels.</span><br><span class="line"></span><br><span class="line">   BufferAndAvailability next &#x3D; null;</span><br><span class="line">   try &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F;取出一个 reader</span><br><span class="line">         NetworkSequenceViewReader reader &#x3D; pollAvailableReader();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; No queue with available data. We allow this here, because</span><br><span class="line">         &#x2F;&#x2F; of the write callbacks that are executed after each write.</span><br><span class="line">         if (reader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         next &#x3D; reader.getNextBuffer();</span><br><span class="line">         if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;没有读到数据</span><br><span class="line">            if (!reader.isReleased()) &#123;</span><br><span class="line">            &#x2F;&#x2F;还没有释放当前 reader，继续处理下一个 数据</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;出错了</span><br><span class="line">            Throwable cause &#x3D; reader.getFailureCause();</span><br><span class="line">            if (cause !&#x3D; null) &#123;</span><br><span class="line">               ErrorResponse msg &#x3D; new ErrorResponse(</span><br><span class="line">                  new ProducerFailedException(cause),</span><br><span class="line">                  reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">               ctx.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 读到了数据</span><br><span class="line">            &#x2F;&#x2F; This channel was now removed from the available reader queue.</span><br><span class="line">            &#x2F;&#x2F; We re-add it into the queue if it is still available</span><br><span class="line">            if (next.moreAvailable()) &#123;</span><br><span class="line">            &#x2F;&#x2F;这个 reader 还可以读到更多的数据，继续加入队列</span><br><span class="line">               registerAvailableReader(reader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BufferResponse msg &#x3D; new BufferResponse(</span><br><span class="line">               next.buffer(),</span><br><span class="line">               reader.getSequenceNumber(),</span><br><span class="line">               reader.getReceiverId(),</span><br><span class="line">               next.buffersInBacklog());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Write and flush and wait until this is done before</span><br><span class="line">            &#x2F;&#x2F; trying to continue with the next buffer.</span><br><span class="line">            &#x2F;&#x2F; 向 client 发送数据，发送成功之后通过 writeListener 的回调触发下一次发送</span><br><span class="line">            channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (next !&#x3D; null) &#123;</span><br><span class="line">         next.buffer().recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throw new IOException(t.getMessage(), t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继续加入队列</span><br><span class="line">private void registerAvailableReader(NetworkSequenceViewReader reader) &#123;</span><br><span class="line">		availableReaders.add(reader);</span><br><span class="line">		reader.setRegisteredAsAvailable(true);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;writeListener类</span><br><span class="line">private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (future.isSuccess()) &#123;</span><br><span class="line">				&#x2F;&#x2F;发送成功，再次尝试写入</span><br><span class="line">					writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">				&#125; else if (future.cause() !&#x3D; null) &#123;</span><br><span class="line">					handleException(future.channel(), future.cause());</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					handleException(future.channel(), new IllegalStateException(&quot;Sending cancelled by user.&quot;));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				handleException(future.channel(), t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在 Credit-based Flow Control 算法中，每发送一个 buffer 就会消耗一点 credit，在消费端有空闲 buffer 可用时会发送 <code>AddCrdit</code> 消息。在前面的PartitionRequestServerHandler类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestServerHandler extends SimpleChannelInboundHandler&lt;NettyMessage&gt; &#123;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, NettyMessage msg) throws Exception &#123;</span><br><span class="line">		...</span><br><span class="line">		 else if (msgClazz &#x3D;&#x3D; AddCredit.class) &#123;</span><br><span class="line">		 &#x2F;&#x2F;增加 credit</span><br><span class="line">			AddCredit request &#x3D; (AddCredit) msg;</span><br><span class="line">			outboundQueue.addCredit(request.receiverId, request.credit);</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PartitionRequestQueue类的addCredit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void addCredit(InputChannelID receiverId, int credit) throws Exception &#123;</span><br><span class="line">   if (fatalError) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   NetworkSequenceViewReader reader &#x3D; allReaders.get(receiverId);</span><br><span class="line">   if (reader !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;增加 credit</span><br><span class="line">      reader.addCredit(credit);</span><br><span class="line">&#x2F;&#x2F;因为增加了credit，可能可以继续处理数据，因此把 reader 加入队列</span><br><span class="line">      enqueueAvailableReader(reader);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;No reader for receiverId &#x3D; &quot; + receiverId + &quot; exists.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeReceiving.png" alt></p>
<p>而消费端即 <code>NettyClient</code>的入口为CreditBasedPartitionRequestClientHandler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter implements NetworkClientHandler &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;** Channels, which already requested partitions from the producers. *&#x2F;</span><br><span class="line">   private final ConcurrentMap&lt;InputChannelID, RemoteInputChannel&gt; inputChannels &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** Channels, which will notify the producers about unannounced credit. *&#x2F;</span><br><span class="line">   private final ArrayDeque&lt;RemoteInputChannel&gt; inputChannelsWithCredit &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;Throwable&gt; channelError &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private final ChannelFutureListener writeListener &#x3D; new WriteAndFlushNextMessageIfPossibleListener();</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F;从netty channel中接收到数据</span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;解析消息</span><br><span class="line">			decodeMsg(msg);</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void decodeMsg(Object msg) throws Throwable &#123;</span><br><span class="line">		final Class&lt;?&gt; msgClazz &#x3D; msg.getClass();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; ---- Buffer --------------------------------------------------------</span><br><span class="line">		if (msgClazz &#x3D;&#x3D; NettyMessage.BufferResponse.class) &#123;</span><br><span class="line">		&#x2F;&#x2F;正常的数据</span><br><span class="line">			NettyMessage.BufferResponse bufferOrEvent &#x3D; (NettyMessage.BufferResponse) msg;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据 ID 定位到对应的 RemoteInputChannel</span><br><span class="line">			RemoteInputChannel inputChannel &#x3D; inputChannels.get(bufferOrEvent.receiverId);</span><br><span class="line">			if (inputChannel &#x3D;&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果没有对应的 RemoteInputChannel</span><br><span class="line">				bufferOrEvent.releaseBuffer();</span><br><span class="line">&#x2F;&#x2F;取消对给定 receiverId 的订阅</span><br><span class="line">				cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line"></span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">&#x2F;&#x2F;解析消息，是buffer还是event</span><br><span class="line">			decodeBufferOrEvent(inputChannel, bufferOrEvent);</span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private void decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			ByteBuf nettyBuffer &#x3D; bufferOrEvent.getNettyBuffer();</span><br><span class="line">			final int receivedSize &#x3D; nettyBuffer.readableBytes();</span><br><span class="line">			if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">				&#x2F;&#x2F; ---- Buffer ------------------------------------------------</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Early return for empty buffers. Otherwise Netty&#39;s readBytes() throws an</span><br><span class="line">				&#x2F;&#x2F; IndexOutOfBoundsException.</span><br><span class="line">				if (receivedSize &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">            &#x2F;&#x2F;从对应的 RemoteInputChannel 中请求一个 Buffer</span><br><span class="line">				Buffer buffer &#x3D; inputChannel.requestBuffer();</span><br><span class="line">				if (buffer !&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;将接收的数据写入buffer</span><br><span class="line">					nettyBuffer.readBytes(buffer.asByteBuf(), receivedSize);</span><br><span class="line">					buffer.setCompressed(bufferOrEvent.isCompressed);</span><br><span class="line">&#x2F;&#x2F;通知对应的channel，backlog是生产者那边堆积的buffer数量</span><br><span class="line">					inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">				&#125; else if (inputChannel.isReleased()) &#123;</span><br><span class="line">					cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;No buffer available in credit-based input channel.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F; ---- Event -------------------------------------------------</span><br><span class="line">				&#x2F;&#x2F; TODO We can just keep the serialized data in the Netty buffer and release it later at the reader</span><br><span class="line">				byte[] byteArray &#x3D; new byte[receivedSize];</span><br><span class="line">				nettyBuffer.readBytes(byteArray);</span><br><span class="line"></span><br><span class="line">				MemorySegment memSeg &#x3D; MemorySegmentFactory.wrap(byteArray);</span><br><span class="line">				&#x2F;&#x2F;是一个事件，不需要从 RemoteInputChannel 中申请 buffer</span><br><span class="line">				Buffer buffer &#x3D; new NetworkBuffer(memSeg, FreeingBufferRecycler.INSTANCE, false, receivedSize);</span><br><span class="line">&#x2F;&#x2F;通知对应的channel，backlog是生产者那边堆积的buffer数量</span><br><span class="line">				inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			bufferOrEvent.releaseBuffer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>CreditBasedPartitionRequestClientHandler</code> 从网络中读取数据后交给 <code>RemoteInputChannel</code>， <code>RemoteInputChannel</code> 会将接收到的加入队列中，并根据生产端的堆积申请 floating buffer：</p>
<p>RemoteInputChannel类onBuffer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收到远程 ResultSubpartition 发送的 Buffer</span><br><span class="line">public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException &#123;</span><br><span class="line">   boolean recycleBuffer &#x3D; true;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      final boolean wasEmpty;</span><br><span class="line">      synchronized (receivedBuffers) &#123;</span><br><span class="line">         &#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">         &#x2F;&#x2F; after releaseAllResources() released all buffers from receivedBuffers</span><br><span class="line">         &#x2F;&#x2F; (see above for details).</span><br><span class="line">         if (isReleased.get()) &#123;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;序号需要匹配</span><br><span class="line">         if (expectedSequenceNumber !&#x3D; sequenceNumber) &#123;</span><br><span class="line">            onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">&#x2F;&#x2F;加入 receivedBuffers 队列中</span><br><span class="line">         wasEmpty &#x3D; receivedBuffers.isEmpty();</span><br><span class="line">         receivedBuffers.add(buffer);</span><br><span class="line">         recycleBuffer &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ++expectedSequenceNumber;</span><br><span class="line"></span><br><span class="line">      if (wasEmpty) &#123;</span><br><span class="line">      &#x2F;&#x2F;通知 InputGate，当前 channel 有新数据</span><br><span class="line">         notifyChannelNonEmpty();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (backlog &gt;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F;根据客户端的积压申请float buffer</span><br><span class="line">         onSenderBacklog(backlog);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      if (recycleBuffer) &#123;</span><br><span class="line">         buffer.recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;backlog 是发送端的堆积 的 buffer 数量，</span><br><span class="line">	&#x2F;&#x2F;如果 bufferQueue 中 buffer 的数量不足，就去须从 LocalBufferPool 中请求 floating buffer</span><br><span class="line">	&#x2F;&#x2F;在请求了新的 buffer 后，通知生产者有 credit 可用</span><br><span class="line">void onSenderBacklog(int backlog) throws IOException &#123;</span><br><span class="line">		int numRequestedBuffers &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		synchronized (bufferQueue) &#123;</span><br><span class="line">			&#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">			&#x2F;&#x2F; after releaseAllResources() released all buffers (see above for details).</span><br><span class="line">			if (isReleased.get()) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要的 buffer 数量是 backlog + initialCredit, backlog 是生产者当前的积压</span><br><span class="line">			numRequiredBuffers &#x3D; backlog + initialCredit;</span><br><span class="line">			while (bufferQueue.getAvailableBufferSize() &lt; numRequiredBuffers &amp;&amp; !isWaitingForFloatingBuffers) &#123;</span><br><span class="line">			&#x2F;&#x2F;不停地请求新的 floating buffer</span><br><span class="line">				Buffer buffer &#x3D; inputGate.getBufferPool().requestBuffer();</span><br><span class="line">				if (buffer !&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;从 buffer poll 中请求到 buffer</span><br><span class="line">					bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line">					numRequestedBuffers++;</span><br><span class="line">				&#125; else if (inputGate.getBufferProvider().addBufferListener(this)) &#123;</span><br><span class="line">				&#x2F;&#x2F; buffer pool 没有 buffer 了，加一个监听，当 LocalBufferPool 中有新的 buffer 时会回调 notifyBufferAvailable</span><br><span class="line">					&#x2F;&#x2F; If the channel has not got enough buffers, register it as listener to wait for more floating buffers.</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (numRequestedBuffers &gt; 0 &amp;&amp; unannouncedCredit.getAndAdd(numRequestedBuffers) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		&#x2F;&#x2F;请求了新的floating buffer，要更新 credit</span><br><span class="line">			notifyCreditAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"> private void notifyCreditAvailable() &#123;</span><br><span class="line">		checkState(partitionRequestClient !&#x3D; null, &quot;Tried to send task event to producer before requesting a queue.&quot;);</span><br><span class="line">&#x2F;&#x2F;通知当前 channel 有新的 credit</span><br><span class="line">		partitionRequestClient.notifyCreditAvailable(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;LocalBufferPool 的recycle回收buffer并通知有 buffer 可用</span><br><span class="line">@Override</span><br><span class="line">	public NotificationResult notifyBufferAvailable(Buffer buffer) &#123;</span><br><span class="line">		NotificationResult notificationResult &#x3D; NotificationResult.BUFFER_NOT_USED;</span><br><span class="line">		try &#123;</span><br><span class="line">			synchronized (bufferQueue) &#123;</span><br><span class="line">				checkState(isWaitingForFloatingBuffers,</span><br><span class="line">					&quot;This channel should be waiting for floating buffers.&quot;);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Important: make sure that we never add a buffer after releaseAllResources()</span><br><span class="line">				&#x2F;&#x2F; released all buffers. Following scenarios exist:</span><br><span class="line">				&#x2F;&#x2F; 1) releaseAllResources() already released buffers inside bufferQueue</span><br><span class="line">				&#x2F;&#x2F; -&gt; then isReleased is set correctly</span><br><span class="line">				&#x2F;&#x2F; 2) releaseAllResources() did not yet release buffers from bufferQueue</span><br><span class="line">				&#x2F;&#x2F; -&gt; we may or may not have set isReleased yet but will always wait for the</span><br><span class="line">				&#x2F;&#x2F; lock on bufferQueue to release buffers</span><br><span class="line">				if (isReleased.get() || bufferQueue.getAvailableBufferSize() &gt;&#x3D; numRequiredBuffers) &#123;</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; false;</span><br><span class="line">					return notificationResult;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加floating buffer</span><br><span class="line">				bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line"></span><br><span class="line">				if (bufferQueue.getAvailableBufferSize() &#x3D;&#x3D; numRequiredBuffers) &#123;</span><br><span class="line">				&#x2F;&#x2F;bufferQueue中有足够多的 buffer 了</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; false;</span><br><span class="line">					notificationResult &#x3D; NotificationResult.BUFFER_USED_NO_NEED_MORE;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F;bufferQueue 中 buffer 仍然不足</span><br><span class="line">					notificationResult &#x3D; NotificationResult.BUFFER_USED_NEED_MORE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (unannouncedCredit.getAndAdd(1) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				notifyCreditAvailable();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			setError(t);</span><br><span class="line">		&#125;</span><br><span class="line">		return notificationResult;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 <code>RemoteInputChannel</code> 申请到新的 buffer，就需要通知生产者更新 credit，这需要发送一条 <code>AddCredit</code>消息：</p>
<p>NettyPartitionRequestClient.notifyCreditAvailable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void notifyCreditAvailable(RemoteInputChannel inputChannel) &#123;</span><br><span class="line">   clientHandler.notifyCreditAvailable(inputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreditBasedPartitionRequestClientHandler.notifyCreditAvailable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public void notifyCreditAvailable(final RemoteInputChannel inputChannel) &#123;</span><br><span class="line">&#x2F;&#x2F;有新的credit触发一次自定义事件</span><br><span class="line">   ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(inputChannel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;触发自定义事件</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">		if (msg instanceof RemoteInputChannel) &#123;</span><br><span class="line">		&#x2F;&#x2F;有新的credit会触发</span><br><span class="line">			boolean triggerWrite &#x3D; inputChannelsWithCredit.isEmpty();</span><br><span class="line">         &#x2F;&#x2F;加入到队列中</span><br><span class="line">			inputChannelsWithCredit.add((RemoteInputChannel) msg);</span><br><span class="line"></span><br><span class="line">			if (triggerWrite) &#123;</span><br><span class="line">				writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctx.fireUserEventTriggered(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private void writeAndFlushNextMessageIfPossible(Channel channel) &#123;</span><br><span class="line">		if (channelError.get() !&#x3D; null || !channel.isWritable()) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">&#x2F;&#x2F;从队列中取出 RemoteInputChannel， 发送消息</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			RemoteInputChannel inputChannel &#x3D; inputChannelsWithCredit.poll();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; The input channel may be null because of the write callbacks</span><br><span class="line">			&#x2F;&#x2F; that are executed after each write.</span><br><span class="line">			if (inputChannel &#x3D;&#x3D; null) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;It is no need to notify credit for the released channel.</span><br><span class="line">			if (!inputChannel.isReleased()) &#123;</span><br><span class="line">				AddCredit msg &#x3D; new AddCredit(</span><br><span class="line">				&#x2F;&#x2F;发送 AddCredit 的消息</span><br><span class="line">					inputChannel.getPartitionId(),</span><br><span class="line">					inputChannel.getAndResetUnannouncedCredit(),</span><br><span class="line">					inputChannel.getInputChannelId());</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Write and flush and wait until this is done before</span><br><span class="line">				&#x2F;&#x2F; trying to continue with the next input channel.</span><br><span class="line">				&#x2F;&#x2F;发送成功之后通过writeListener监听继续发送</span><br><span class="line">				channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (future.isSuccess()) &#123;</span><br><span class="line">					writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">				&#125; else if (future.cause() !&#x3D; null) &#123;</span><br><span class="line">					notifyAllChannelsOfErrorAndClose(future.cause());</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					notifyAllChannelsOfErrorAndClose(new IllegalStateException(&quot;Sending cancelled by user.&quot;));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Credit-based Flow Control 的具体机制为：</p>
<ul>
<li>接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一点 credit）；</li>
<li>当发送端获得了 X 点 Credit，表明它可以向网络中发送 X 个 buffer；当接收端分配了 X 点 Credit 给发送端，表明它有 X 个空闲的 buffer 可以接收数据；</li>
<li>只有在 Credit &gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少一点</li>
<li>由于 <code>CheckpointBarrier</code>，<code>EndOfPartitionEvent</code> 等事件可以被立即处理，因而事件可以立即发送，无需使用 Credit</li>
<li>当发送端发送 buffer 的时候，它同样把当前堆积的 buffer 数量（backlog size）告知接收端；接收端根据发送端堆积的数量来申请 floating buffer</li>
</ul>
<p>这种流量控制机制可以有效地改善网络的利用率，不会因为 buffer 长时间停留在网络链路中进而导致整个所有的 Task 都无法继续处理数据，也无法进行 Checkpoint 操作。但是它的一个潜在的缺点是增加了上下游之间的通信成本（需要发送 credit 和 backlog 信息）</p>
<p>在上面几节，我们已经详细地分析了 Task 之间的数据交换机制和它们的实现原理，理解这这些实际上就已经理解了 Flink 的“反压”机制。</p>
<p>所谓“反压”，就是指在流处理系统中，下游任务的处理速度跟不上上游任务的数据生产速度。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。反压机制就是指系统能够自己检测到被阻塞的算子，然后系统自适应地降低源头或者上游的发送速率。在 Flink 中，应对“反压”是一种极其自然的方式，因为 Flink 中的数据传输机制已经提供了应对反压的措施。</p>
<p>在本地数据交换的情况下，两个 Task 实际上是同一个 JVM 中的两个线程，Task1 产生的 Buffer 直接被 Task2 使用，当 Task2 处理完之后这个 Buffer 就会被回收到本地缓冲池中。一旦 Task2 的处理速度比 Task2 产生 Buffer 的速度慢，那么缓冲池中 Buffer 渐渐地就会被耗尽，Task1 无法申请到新的 Buffer 自然就会阻塞，因而会导致 Task1 的降速。</p>
<p>在网络数据交换的情况下，如果下游 Task 的处理速度较慢，下游 Task 的接收缓冲池逐渐耗尽后就无法从网络中读取新的数据，这回导致上游 Task 无法将缓冲池中的 Buffer 发送到网络中，因此上游 Task 的缓冲池也会被耗尽，进而导致上游任务的降速。为了解决网络连接阻塞导致所有 Task 都无法处理数据的情况，Flink 还引入了 Credit-based Flow Control 算法，在上游生产者下游消费只之间通过“信用点”来协调发送速度，确保网络连接永远不会被阻塞。同时，Flink 的网络栈基于 Netty 构建，通过 Netty 的水位线机制也可以控制发送端的发送速率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/Flink%E7%9A%84Task%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/Flink%E7%9A%84Task%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" itemprop="url">Flink的Task的调度过程及生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T10:35:31+08:00">
                2020-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>回顾之前JobManager的启动过程，创建好JobManagerRunner之后，调用Dispatcher的startJobManagerRunner启动JobManager。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private JobManagerRunner startJobManagerRunner(JobManagerRunner jobManagerRunner) throws Exception &#123;</span><br><span class="line">   final JobID jobId &#x3D; jobManagerRunner.getJobID();</span><br><span class="line"></span><br><span class="line">   FutureUtils.assertNoException(</span><br><span class="line">      jobManagerRunner.getResultFuture().handleAsync(</span><br><span class="line">         (ArchivedExecutionGraph archivedExecutionGraph, Throwable throwable) -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we are still the active JobManagerRunner by checking the identity</span><br><span class="line">            final JobManagerRunner currentJobManagerRunner &#x3D; Optional.ofNullable(jobManagerRunnerFutures.get(jobId))</span><br><span class="line">               .map(future -&gt; future.getNow(null))</span><br><span class="line">               .orElse(null);</span><br><span class="line">            &#x2F;&#x2F;noinspection ObjectEquality</span><br><span class="line">            if (jobManagerRunner &#x3D;&#x3D; currentJobManagerRunner) &#123;</span><br><span class="line">               if (archivedExecutionGraph !&#x3D; null) &#123;</span><br><span class="line">                  jobReachedGloballyTerminalState(archivedExecutionGraph);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                  final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                  if (strippedThrowable instanceof JobNotFinishedException) &#123;</span><br><span class="line">                     jobNotFinished(jobId);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                     jobMasterFailed(jobId, strippedThrowable);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               log.debug(&quot;There is a newer JobManagerRunner for the job &#123;&#125;.&quot;, jobId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">         &#125;, getMainThreadExecutor()));</span><br><span class="line">&#x2F;&#x2F;启动jobManager</span><br><span class="line">   jobManagerRunner.start();</span><br><span class="line"></span><br><span class="line">   return jobManagerRunner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobManagerRunnerImpl类start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;选举leader节点</span><br><span class="line">      leaderElectionService.start(this);</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      log.error(&quot;Could not start the JobManager because the leader election service did not start.&quot;, e);</span><br><span class="line">      throw new Exception(&quot;Could not start the leader election service.&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功回调JobManagerRunnerImpl类的grantLeadership回调方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void grantLeadership(final UUID leaderSessionID) &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         log.info(&quot;JobManagerRunner already shutdown.&quot;);</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      leadershipOperation &#x3D; leadershipOperation.thenCompose(</span><br><span class="line">         (ignored) -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">               return verifyJobSchedulingStatusAndStartJobManager(leaderSessionID);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">      handleException(leadershipOperation, &quot;Could not start the job manager.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private CompletableFuture&lt;Void&gt; verifyJobSchedulingStatusAndStartJobManager(UUID leaderSessionId) &#123;</span><br><span class="line">		final CompletableFuture&lt;JobSchedulingStatus&gt; jobSchedulingStatusFuture &#x3D; getJobSchedulingStatus();</span><br><span class="line"></span><br><span class="line">		return jobSchedulingStatusFuture.thenCompose(</span><br><span class="line">			jobSchedulingStatus -&gt; &#123;</span><br><span class="line">				if (jobSchedulingStatus &#x3D;&#x3D; JobSchedulingStatus.DONE) &#123;</span><br><span class="line">					return jobAlreadyDone();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F;启动startJobMaster</span><br><span class="line">					return startJobMaster(leaderSessionId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功启动startJobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private CompletionStage&lt;Void&gt; startJobMaster(UUID leaderSessionId) &#123;</span><br><span class="line">   log.info(&quot;JobManager runner for job &#123;&#125; (&#123;&#125;) was granted leadership with session id &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">      jobGraph.getName(), jobGraph.getJobID(), leaderSessionId, jobMasterService.getAddress());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      runningJobsRegistry.setJobRunning(jobGraph.getJobID());</span><br><span class="line">   &#125; catch (IOException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(</span><br><span class="line">         new FlinkException(</span><br><span class="line">            String.format(&quot;Failed to set the job %s to running in the running jobs registry.&quot;, jobGraph.getJobID()),</span><br><span class="line">            e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; startFuture;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;使用leaderSessionId构建 JobMasterId 启动 JobMaster</span><br><span class="line">      startFuture &#x3D; jobMasterService.start(new JobMasterId(leaderSessionId));</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new FlinkException(&quot;Failed to start the JobMaster.&quot;, e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;JobMasterGateway&gt; currentLeaderGatewayFuture &#x3D; leaderGatewayFuture;</span><br><span class="line">   return startFuture.thenAcceptAsync(</span><br><span class="line">      (Acknowledge ack) -&gt; confirmLeaderSessionIdIfStillLeader(</span><br><span class="line">         leaderSessionId,</span><br><span class="line">         jobMasterService.getAddress(),</span><br><span class="line">         currentLeaderGatewayFuture),</span><br><span class="line">      executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入JobMaster类start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; start(final JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; make sure we receive RPC and async calls</span><br><span class="line">   &#x2F;&#x2F;启动RpcServer</span><br><span class="line">   start();</span><br><span class="line"></span><br><span class="line">   return callAsyncWithoutFencing(() -&gt; startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   validateRunsInMainThread();</span><br><span class="line"></span><br><span class="line">   checkNotNull(newJobMasterId, &quot;The new JobMasterId must not be null.&quot;);</span><br><span class="line"></span><br><span class="line">   if (Objects.equals(getFencingToken(), newJobMasterId)) &#123;</span><br><span class="line">      log.info(&quot;Already started the job execution with JobMasterId &#123;&#125;.&quot;, newJobMasterId);</span><br><span class="line"></span><br><span class="line">      return Acknowledge.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setNewFencingToken(newJobMasterId);</span><br><span class="line"></span><br><span class="line">   startJobMasterServices();</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Starting execution of job &#123;&#125; (&#123;&#125;) under job master id &#123;&#125;.&quot;, jobGraph.getName(), jobGraph.getJobID(), newJobMasterId);</span><br><span class="line"></span><br><span class="line">   resetAndStartScheduler();</span><br><span class="line"></span><br><span class="line">   return Acknowledge.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startJobMasterServices与ResourceManager建立连接，之后resetAndStartScheduler进入job的调度流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void resetAndStartScheduler() throws Exception &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   schedulerAssignedFuture.thenRun(this::startScheduling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startScheduling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void startScheduling() &#123;</span><br><span class="line">   checkState(jobStatusListener &#x3D;&#x3D; null);</span><br><span class="line">   &#x2F;&#x2F; register self as job status change listener</span><br><span class="line">   &#x2F;&#x2F;状态监听</span><br><span class="line">   jobStatusListener &#x3D; new JobManagerJobStatusListener();</span><br><span class="line">   schedulerNG.registerJobStatusListener(jobStatusListener);</span><br><span class="line"></span><br><span class="line">   schedulerNG.startScheduling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SchedulerBase类startScheduling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void startScheduling() &#123;</span><br><span class="line">   mainThreadExecutor.assertRunningInMainThread();</span><br><span class="line">   &#x2F;&#x2F;注册监控</span><br><span class="line">   registerJobMetrics();</span><br><span class="line">   startSchedulingInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LegacyScheduler类startSchedulingInternal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void startSchedulingInternal() &#123;</span><br><span class="line">   final ExecutionGraph executionGraph &#x3D; getExecutionGraph();</span><br><span class="line">   try &#123;</span><br><span class="line">      executionGraph.scheduleForExecution();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable t) &#123;</span><br><span class="line">      executionGraph.failGlobal(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExecutionGraph类的scheduleForExecution</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleForExecution() throws JobException &#123;</span><br><span class="line"></span><br><span class="line">   assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   if (isLegacyScheduling()) &#123;</span><br><span class="line">      LOG.info(&quot;Job recovers via failover strategy: &#123;&#125;&quot;, failoverStrategy.getStrategyName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long currentGlobalModVersion &#x3D; globalModVersion;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将job状态由CREATED转为RUNNING</span><br><span class="line">   if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</span><br><span class="line"></span><br><span class="line">      final CompletableFuture&lt;Void&gt; newSchedulingFuture &#x3D; SchedulingUtils.schedule(</span><br><span class="line">         scheduleMode,</span><br><span class="line">         getAllExecutionVertices(),</span><br><span class="line">         this);</span><br><span class="line"></span><br><span class="line">      if (state &#x3D;&#x3D; JobStatus.RUNNING &amp;&amp; currentGlobalModVersion &#x3D;&#x3D; globalModVersion) &#123;</span><br><span class="line">         schedulingFuture &#x3D; newSchedulingFuture;</span><br><span class="line">         newSchedulingFuture.whenComplete(</span><br><span class="line">            (Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">               if (throwable !&#x3D; null) &#123;</span><br><span class="line">                  final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                  if (!(strippedThrowable instanceof CancellationException)) &#123;</span><br><span class="line">                     &#x2F;&#x2F; only fail if the scheduling future was not canceled</span><br><span class="line">                     failGlobal(strippedThrowable);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         newSchedulingFuture.cancel(false);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Job may only be scheduled from state &quot; + JobStatus.CREATED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; schedule(</span><br><span class="line">      ScheduleMode scheduleMode,</span><br><span class="line">      final Iterable&lt;ExecutionVertex&gt; vertices,</span><br><span class="line">      final ExecutionGraph executionGraph) &#123;</span><br><span class="line"></span><br><span class="line">   switch (scheduleMode) &#123;</span><br><span class="line">   &#x2F;&#x2F;只运行 source，其它的子任务由source进行通知</span><br><span class="line">      case LAZY_FROM_SOURCES:</span><br><span class="line">      case LAZY_FROM_SOURCES_WITH_BATCH_SLOT_REQUEST:</span><br><span class="line">         return scheduleLazy(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;所有的子任务都立即进行调度，这是 streaming 模式采用的方式</span><br><span class="line">      case EAGER:</span><br><span class="line">         return scheduleEager(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">         throw new IllegalStateException(String.format(&quot;Schedule mode %s is invalid.&quot;, scheduleMode));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleEager调度子任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; scheduleEager(</span><br><span class="line">      final Iterable&lt;ExecutionVertex&gt; vertices,</span><br><span class="line">      final ExecutionGraph executionGraph) &#123;</span><br><span class="line"></span><br><span class="line">   executionGraph.assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   checkState(executionGraph.getState() &#x3D;&#x3D; JobStatus.RUNNING, &quot;job is not running currently&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Important: reserve all the space we need up front.</span><br><span class="line">   &#x2F;&#x2F; that way we do not have any operation that can fail between allocating the slots</span><br><span class="line">   &#x2F;&#x2F; and adding them to the list. If we had a failure in between there, that would</span><br><span class="line">   &#x2F;&#x2F; cause the slots to get lost</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; collecting all the slots may resize and fail in that operation without slots getting lost</span><br><span class="line">   final ArrayList&lt;CompletableFuture&lt;Execution&gt;&gt; allAllocationFutures &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   final SlotProviderStrategy slotProviderStrategy &#x3D; executionGraph.getSlotProviderStrategy();</span><br><span class="line">   final Set&lt;AllocationID&gt; allPreviousAllocationIds &#x3D; Collections.unmodifiableSet(</span><br><span class="line">      computePriorAllocationIdsIfRequiredByScheduling(vertices, slotProviderStrategy.asSlotProvider()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分配已slot资源</span><br><span class="line">   &#x2F;&#x2F; allocate the slots (obtain all their futures)</span><br><span class="line">   for (ExecutionVertex ev : vertices) &#123;</span><br><span class="line">      &#x2F;&#x2F; these calls are not blocking, they only return futures</span><br><span class="line">      CompletableFuture&lt;Execution&gt; allocationFuture &#x3D; ev.getCurrentExecutionAttempt().allocateResourcesForExecution(</span><br><span class="line">         slotProviderStrategy,</span><br><span class="line">         LocationPreferenceConstraint.ALL,</span><br><span class="line">         allPreviousAllocationIds);</span><br><span class="line"></span><br><span class="line">      allAllocationFutures.add(allocationFuture);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; this future is complete once all slot futures are complete.</span><br><span class="line">   &#x2F;&#x2F; the future fails once one slot future fails.</span><br><span class="line">   &#x2F;&#x2F; 等待所有需要调度的子任务都分配到资源</span><br><span class="line">   final ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture &#x3D; FutureUtils.combineAll(allAllocationFutures);</span><br><span class="line"></span><br><span class="line">   return allAllocationsFuture.thenAccept(</span><br><span class="line">      (Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</span><br><span class="line">         for (Execution execution : executionsToDeploy) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F;启动 Execution</span><br><span class="line">               execution.deploy();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">               throw new CompletionException(</span><br><span class="line">                  new FlinkException(</span><br><span class="line">                     String.format(&quot;Could not deploy execution %s.&quot;, execution),</span><br><span class="line">                     t));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F; Generate a more specific failure message for the eager scheduling</span><br><span class="line">      .exceptionally(......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Execution</code> 是 <code>ExecutionVertex</code> 的一次执行，在调度的时候会先生成对任务的描述 <code>TaskDeploymentDescription</code>， <code>TaskDeploymentDescription</code> 包含了对输入的描述 <code>InputGateDeploymentDescriptor</code>, 对输出的描述 <code>ResultPartitionDeploymentDescriptor</code>，以及保存了这个 Task 中运行的所有算子运行时信息的 <code>TaskInformation</code> 和 <code>JobInformation</code>。生成了 <code>TaskDeploymentDescription</code> 通过 RPC 调用提交给 <code>TaskExecutor</code> 执行。</p>
<p>Execution 类的deploy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void deploy() throws JobException &#123;</span><br><span class="line">   assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   final LogicalSlot slot  &#x3D; assignedResource;</span><br><span class="line"></span><br><span class="line">   checkNotNull(slot, &quot;In order to deploy the execution we first have to assign a resource via tryAssignResource.&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Check if the TaskManager died in the meantime</span><br><span class="line">   &#x2F;&#x2F; This only speeds up the response to TaskManagers failing concurrently to deployments.</span><br><span class="line">   &#x2F;&#x2F; The more general check is the rpcTimeout of the deployment call</span><br><span class="line">   if (!slot.isAlive()) &#123;</span><br><span class="line">      throw new JobException(&quot;Target slot (TaskManager) for deployment is no longer alive.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure exactly one deployment call happens from the correct state</span><br><span class="line">   &#x2F;&#x2F; note: the transition from CREATED to DEPLOYING is for testing purposes only</span><br><span class="line">   ExecutionState previous &#x3D; this.state;</span><br><span class="line">   if (previous &#x3D;&#x3D; SCHEDULED || previous &#x3D;&#x3D; CREATED) &#123;</span><br><span class="line">      if (!transitionState(previous, DEPLOYING)) &#123;</span><br><span class="line">         &#x2F;&#x2F; race condition, someone else beat us to the deploying call.</span><br><span class="line">         &#x2F;&#x2F; this should actually not happen and indicates a race somewhere else</span><br><span class="line">         throw new IllegalStateException(&quot;Cannot deploy task: Concurrent deployment call race.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; vertex may have been cancelled, or it was already scheduled</span><br><span class="line">      throw new IllegalStateException(&quot;The vertex must be in CREATED or SCHEDULED state to be deployed. Found state &quot; + previous);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (this !&#x3D; slot.getPayload()) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">         String.format(&quot;The execution %s has not been assigned to the assigned slot.&quot;, this));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; race double check, did we fail&#x2F;cancel and do we need to release the slot?</span><br><span class="line">      if (this.state !&#x3D; DEPLOYING) &#123;</span><br><span class="line">         slot.releaseSlot(new FlinkException(&quot;Actual state of execution &quot; + this + &quot; (&quot; + state + &quot;) does not match expected state DEPLOYING.&quot;));</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (LOG.isInfoEnabled()) &#123;</span><br><span class="line">         LOG.info(String.format(&quot;Deploying %s (attempt #%d) to %s&quot;, vertex.getTaskNameWithSubtaskIndex(),</span><br><span class="line">               attemptNumber, getAssignedResourceLocation()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;TaskDeploymentDescription 是对任务的描述，包含了task运行需要所以信息</span><br><span class="line">      final TaskDeploymentDescriptor deployment &#x3D; TaskDeploymentDescriptorFactory</span><br><span class="line">         .fromExecutionVertex(vertex, attemptNumber)</span><br><span class="line">         .createDeploymentDescriptor(</span><br><span class="line">            slot.getAllocationId(),</span><br><span class="line">            slot.getPhysicalSlotNumber(),</span><br><span class="line">            taskRestore,</span><br><span class="line">            producedPartitions.values());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; null taskRestore to let it be GC&#39;ed</span><br><span class="line">      taskRestore &#x3D; null;</span><br><span class="line"></span><br><span class="line">      final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">      final ComponentMainThreadExecutor jobMasterMainThreadExecutor &#x3D;</span><br><span class="line">         vertex.getExecutionGraph().getJobMasterMainThreadExecutor();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; We run the submission in the future executor so that the serialization of large TDDs does not block</span><br><span class="line">      &#x2F;&#x2F; the main thread and sync back to the main thread once submission is completed.</span><br><span class="line">      &#x2F;&#x2F;向taskManagerGateway提交job</span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; taskManagerGateway.submitTask(deployment, rpcTimeout), executor)</span><br><span class="line">         .thenCompose(Function.identity())</span><br><span class="line">         .whenCompleteAsync(</span><br><span class="line">            ......);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>taskManagerGateway最终调用TaskExecutor的submitTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; submitTask(</span><br><span class="line">      TaskDeploymentDescriptor tdd,</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      final JobID jobId &#x3D; tdd.getJobId();</span><br><span class="line">      final JobManagerConnection jobManagerConnection &#x3D; jobManagerTable.get(jobId);</span><br><span class="line"></span><br><span class="line">      if (jobManagerConnection &#x3D;&#x3D; null) &#123;</span><br><span class="line">         final String message &#x3D; &quot;Could not submit task because there is no JobManager &quot; +</span><br><span class="line">            &quot;associated for the job &quot; + jobId + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!Objects.equals(jobManagerConnection.getJobMasterId(), jobMasterId)) &#123;</span><br><span class="line">         final String message &#x3D; &quot;Rejecting the task submission because the job manager leader id &quot; +</span><br><span class="line">            jobMasterId + &quot; does not match the expected job manager leader id &quot; +</span><br><span class="line">            jobManagerConnection.getJobMasterId() + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!taskSlotTable.tryMarkSlotActive(jobId, tdd.getAllocationId())) &#123;</span><br><span class="line">         final String message &#x3D; &quot;No task slot allocated for job ID &quot; + jobId +</span><br><span class="line">            &quot; and allocation ID &quot; + tdd.getAllocationId() + &#39;.&#39;;</span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; re-integrate offloaded data:</span><br><span class="line">      try &#123;</span><br><span class="line">         tdd.loadBigData(blobCacheService.getPermanentBlobService());</span><br><span class="line">      &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not re-integrate offloaded TaskDeploymentDescriptor data.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; deserialize the pre-serialized information</span><br><span class="line">      final JobInformation jobInformation;</span><br><span class="line">      final TaskInformation taskInformation;</span><br><span class="line">      try &#123;</span><br><span class="line">         jobInformation &#x3D; tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">         taskInformation &#x3D; tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">      &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not deserialize the job or task information.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!jobId.equals(jobInformation.getJobId())) &#123;</span><br><span class="line">         throw new TaskSubmissionException(</span><br><span class="line">            &quot;Inconsistent job ID information inside TaskDeploymentDescriptor (&quot; +</span><br><span class="line">               tdd.getJobId() + &quot; vs. &quot; + jobInformation.getJobId() + &quot;)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TaskMetricGroup taskMetricGroup &#x3D; taskManagerMetricGroup.addTaskForJob(</span><br><span class="line">         jobInformation.getJobId(),</span><br><span class="line">         jobInformation.getJobName(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         taskInformation.getTaskName(),</span><br><span class="line">         tdd.getSubtaskIndex(),</span><br><span class="line">         tdd.getAttemptNumber());</span><br><span class="line"></span><br><span class="line">      InputSplitProvider inputSplitProvider &#x3D; new RpcInputSplitProvider(</span><br><span class="line">         jobManagerConnection.getJobManagerGateway(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">      TaskManagerActions taskManagerActions &#x3D; jobManagerConnection.getTaskManagerActions();</span><br><span class="line">      CheckpointResponder checkpointResponder &#x3D; jobManagerConnection.getCheckpointResponder();</span><br><span class="line">      GlobalAggregateManager aggregateManager &#x3D; jobManagerConnection.getGlobalAggregateManager();</span><br><span class="line"></span><br><span class="line">      LibraryCacheManager libraryCache &#x3D; jobManagerConnection.getLibraryCacheManager();</span><br><span class="line">      ResultPartitionConsumableNotifier resultPartitionConsumableNotifier &#x3D; jobManagerConnection.getResultPartitionConsumableNotifier();</span><br><span class="line">      PartitionProducerStateChecker partitionStateChecker &#x3D; jobManagerConnection.getPartitionStateChecker();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Task本地状态保存</span><br><span class="line">      final TaskLocalStateStore localStateStore &#x3D; localStateStoresManager.localStateStoreForSubtask(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getSubtaskIndex());</span><br><span class="line"></span><br><span class="line">      final JobManagerTaskRestore taskRestore &#x3D; tdd.getTaskRestore();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Task状态管理</span><br><span class="line">      final TaskStateManager taskStateManager &#x3D; new TaskStateManagerImpl(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         localStateStore,</span><br><span class="line">         taskRestore,</span><br><span class="line">         checkpointResponder);</span><br><span class="line"></span><br><span class="line">      MemoryManager memoryManager;</span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;task内存管理</span><br><span class="line">         memoryManager &#x3D; taskSlotTable.getTaskMemoryManager(tdd.getAllocationId());</span><br><span class="line">      &#125; catch (SlotNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not submit task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;taskmanager初始化task</span><br><span class="line">      Task task &#x3D; new Task(</span><br><span class="line">         jobInformation,</span><br><span class="line">         taskInformation,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         tdd.getSubtaskIndex(),</span><br><span class="line">         tdd.getAttemptNumber(),</span><br><span class="line">         tdd.getProducedPartitions(),</span><br><span class="line">         tdd.getInputGates(),</span><br><span class="line">         tdd.getTargetSlotNumber(),</span><br><span class="line">         memoryManager,</span><br><span class="line">         taskExecutorServices.getIOManager(),</span><br><span class="line">         taskExecutorServices.getShuffleEnvironment(),</span><br><span class="line">         taskExecutorServices.getKvStateService(),</span><br><span class="line">         taskExecutorServices.getBroadcastVariableManager(),</span><br><span class="line">         taskExecutorServices.getTaskEventDispatcher(),</span><br><span class="line">         taskStateManager,</span><br><span class="line">         taskManagerActions,</span><br><span class="line">         inputSplitProvider,</span><br><span class="line">         checkpointResponder,</span><br><span class="line">         aggregateManager,</span><br><span class="line">         blobCacheService,</span><br><span class="line">         libraryCache,</span><br><span class="line">         fileCache,</span><br><span class="line">         taskManagerConfiguration,</span><br><span class="line">         taskMetricGroup,</span><br><span class="line">         resultPartitionConsumableNotifier,</span><br><span class="line">         partitionStateChecker,</span><br><span class="line">         getRpcService().getExecutor());</span><br><span class="line"></span><br><span class="line">      taskMetricGroup.gauge(MetricNames.IS_BACKPRESSURED, task::isBackPressured);</span><br><span class="line"></span><br><span class="line">      log.info(&quot;Received task &#123;&#125;.&quot;, task.getTaskInfo().getTaskNameWithSubtasks());</span><br><span class="line"></span><br><span class="line">      boolean taskAdded;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         taskAdded &#x3D; taskSlotTable.addTask(task);</span><br><span class="line">      &#125; catch (SlotNotFoundException | SlotNotActiveException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not submit task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (taskAdded) &#123;</span><br><span class="line">      &#x2F;&#x2F;启动task</span><br><span class="line">         task.startTaskThread();</span><br><span class="line"></span><br><span class="line">         setupResultPartitionBookkeeping(</span><br><span class="line">            tdd.getJobId(),</span><br><span class="line">            tdd.getProducedPartitions(),</span><br><span class="line">            task.getTerminationFuture());</span><br><span class="line">         return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         final String message &#x3D; &quot;TaskManager already contains a task for id &quot; +</span><br><span class="line">            task.getExecutionId() + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (TaskSubmissionException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化Task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Runnable, TaskSlotPayload, TaskActions, PartitionProducerStateProvider, CheckpointListener, BackPressureSampleableTask &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * &lt;p&gt;&lt;b&gt;IMPORTANT:&lt;&#x2F;b&gt; This constructor may not start any work that would need to</span><br><span class="line">    * be undone in the case of a failing task deployment.&lt;&#x2F;p&gt;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Task(</span><br><span class="line">      JobInformation jobInformation,</span><br><span class="line">      TaskInformation taskInformation,</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      AllocationID slotAllocationId,</span><br><span class="line">      int subtaskIndex,</span><br><span class="line">      int attemptNumber,</span><br><span class="line">      Collection&lt;ResultPartitionDeploymentDescriptor&gt; resultPartitionDeploymentDescriptors,</span><br><span class="line">      Collection&lt;InputGateDeploymentDescriptor&gt; inputGateDeploymentDescriptors,</span><br><span class="line">      int targetSlotNumber,</span><br><span class="line">      MemoryManager memManager,</span><br><span class="line">      IOManager ioManager,</span><br><span class="line">      ShuffleEnvironment&lt;?, ?&gt; shuffleEnvironment,</span><br><span class="line">      KvStateService kvStateService,</span><br><span class="line">      BroadcastVariableManager bcVarManager,</span><br><span class="line">      TaskEventDispatcher taskEventDispatcher,</span><br><span class="line">      TaskStateManager taskStateManager,</span><br><span class="line">      TaskManagerActions taskManagerActions,</span><br><span class="line">      InputSplitProvider inputSplitProvider,</span><br><span class="line">      CheckpointResponder checkpointResponder,</span><br><span class="line">      GlobalAggregateManager aggregateManager,</span><br><span class="line">      BlobCacheService blobService,</span><br><span class="line">      LibraryCacheManager libraryCache,</span><br><span class="line">      FileCache fileCache,</span><br><span class="line">      TaskManagerRuntimeInfo taskManagerConfig,</span><br><span class="line">      @Nonnull TaskMetricGroup metricGroup,</span><br><span class="line">      ResultPartitionConsumableNotifier resultPartitionConsumableNotifier,</span><br><span class="line">      PartitionProducerStateChecker partitionProducerStateChecker,</span><br><span class="line">      Executor executor) &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      this.taskInfo &#x3D; new TaskInfo(</span><br><span class="line">            taskInformation.getTaskName(),</span><br><span class="line">            taskInformation.getMaxNumberOfSubtaks(),</span><br><span class="line">            subtaskIndex,</span><br><span class="line">            taskInformation.getNumberOfSubtasks(),</span><br><span class="line">            attemptNumber,</span><br><span class="line">            String.valueOf(slotAllocationId));</span><br><span class="line"></span><br><span class="line">      this.jobId &#x3D; jobInformation.getJobId();</span><br><span class="line">      this.vertexId &#x3D; taskInformation.getJobVertexId();</span><br><span class="line">      this.executionId  &#x3D; Preconditions.checkNotNull(executionAttemptID);</span><br><span class="line">      this.allocationId &#x3D; Preconditions.checkNotNull(slotAllocationId);</span><br><span class="line">      this.taskNameWithSubtask &#x3D; taskInfo.getTaskNameWithSubtasks();</span><br><span class="line">      this.jobConfiguration &#x3D; jobInformation.getJobConfiguration();</span><br><span class="line">      this.taskConfiguration &#x3D; taskInformation.getTaskConfiguration();</span><br><span class="line">      this.requiredJarFiles &#x3D; jobInformation.getRequiredJarFileBlobKeys();</span><br><span class="line">      this.requiredClasspaths &#x3D; jobInformation.getRequiredClasspathURLs();</span><br><span class="line">      this.nameOfInvokableClass &#x3D; taskInformation.getInvokableClassName();</span><br><span class="line">      this.serializedExecutionConfig &#x3D; jobInformation.getSerializedExecutionConfig();</span><br><span class="line"></span><br><span class="line">      Configuration tmConfig &#x3D; taskManagerConfig.getConfiguration();</span><br><span class="line">      this.taskCancellationInterval &#x3D; tmConfig.getLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL);</span><br><span class="line">      this.taskCancellationTimeout &#x3D; tmConfig.getLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT);</span><br><span class="line"></span><br><span class="line">      this.memoryManager &#x3D; Preconditions.checkNotNull(memManager);</span><br><span class="line">      this.ioManager &#x3D; Preconditions.checkNotNull(ioManager);</span><br><span class="line">      this.broadcastVariableManager &#x3D; Preconditions.checkNotNull(bcVarManager);</span><br><span class="line">      this.taskEventDispatcher &#x3D; Preconditions.checkNotNull(taskEventDispatcher);</span><br><span class="line">      this.taskStateManager &#x3D; Preconditions.checkNotNull(taskStateManager);</span><br><span class="line">      this.accumulatorRegistry &#x3D; new AccumulatorRegistry(jobId, executionId);</span><br><span class="line"></span><br><span class="line">      this.inputSplitProvider &#x3D; Preconditions.checkNotNull(inputSplitProvider);</span><br><span class="line">      this.checkpointResponder &#x3D; Preconditions.checkNotNull(checkpointResponder);</span><br><span class="line">      this.aggregateManager &#x3D; Preconditions.checkNotNull(aggregateManager);</span><br><span class="line">      this.taskManagerActions &#x3D; checkNotNull(taskManagerActions);</span><br><span class="line"></span><br><span class="line">      this.blobService &#x3D; Preconditions.checkNotNull(blobService);</span><br><span class="line">      this.libraryCache &#x3D; Preconditions.checkNotNull(libraryCache);</span><br><span class="line">      this.fileCache &#x3D; Preconditions.checkNotNull(fileCache);</span><br><span class="line">      this.kvStateService &#x3D; Preconditions.checkNotNull(kvStateService);</span><br><span class="line">      this.taskManagerConfig &#x3D; Preconditions.checkNotNull(taskManagerConfig);</span><br><span class="line"></span><br><span class="line">      this.metrics &#x3D; metricGroup;</span><br><span class="line"></span><br><span class="line">      this.partitionProducerStateChecker &#x3D; Preconditions.checkNotNull(partitionProducerStateChecker);</span><br><span class="line">      this.executor &#x3D; Preconditions.checkNotNull(executor);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; create the reader and writer structures</span><br><span class="line"></span><br><span class="line">      final String taskNameWithSubtaskAndId &#x3D; taskNameWithSubtask + &quot; (&quot; + executionId + &#39;)&#39;;</span><br><span class="line"></span><br><span class="line">      final ShuffleIOOwnerContext taskShuffleContext &#x3D; shuffleEnvironment</span><br><span class="line">         .createShuffleIOOwnerContext(taskNameWithSubtaskAndId, executionId, metrics.getIOMetricGroup());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; produced intermediate result partitions</span><br><span class="line">      &#x2F;&#x2F;创建ResultPartition</span><br><span class="line">      final ResultPartitionWriter[] resultPartitionWriters &#x3D; shuffleEnvironment.createResultPartitionWriters(</span><br><span class="line">         taskShuffleContext,</span><br><span class="line">         resultPartitionDeploymentDescriptors).toArray(new ResultPartitionWriter[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">      this.consumableNotifyingPartitionWriters &#x3D; ConsumableNotifyingResultPartitionWriterDecorator.decorate(</span><br><span class="line">         resultPartitionDeploymentDescriptors,</span><br><span class="line">         resultPartitionWriters,</span><br><span class="line">         this,</span><br><span class="line">         jobId,</span><br><span class="line">         resultPartitionConsumableNotifier);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; consumed intermediate result partitions</span><br><span class="line">      &#x2F;&#x2F;创建InputGate</span><br><span class="line">      final InputGate[] gates &#x3D; shuffleEnvironment.createInputGates(</span><br><span class="line">         taskShuffleContext,</span><br><span class="line">         this,</span><br><span class="line">         inputGateDeploymentDescriptors).toArray(new InputGate[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">      this.inputGates &#x3D; new InputGate[gates.length];</span><br><span class="line">      int counter &#x3D; 0;</span><br><span class="line">      for (InputGate gate : gates) &#123;</span><br><span class="line">         inputGates[counter++] &#x3D; new InputGateWithMetrics(gate, metrics.getIOMetricGroup().getNumBytesInCounter());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (shuffleEnvironment instanceof NettyShuffleEnvironment) &#123;</span><br><span class="line">         &#x2F;&#x2F;noinspection deprecation</span><br><span class="line">         ((NettyShuffleEnvironment) shuffleEnvironment)</span><br><span class="line">            .registerLegacyNetworkMetrics(metrics.getIOMetricGroup(), resultPartitionWriters, gates);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      invokableHasBeenCanceled &#x3D; new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; finally, create the executing thread, but do not start it</span><br><span class="line">      executingThread &#x3D; new Thread(TASK_THREADS_GROUP, this, taskNameWithSubtask);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>TaskSlotTable的addTask添加Task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean addTask(T task) throws SlotNotFoundException, SlotNotActiveException &#123;</span><br><span class="line">   checkRunning();</span><br><span class="line">   Preconditions.checkNotNull(task);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取该Task的slot信息</span><br><span class="line">   TaskSlot&lt;T&gt; taskSlot &#x3D; getTaskSlot(task.getAllocationId());</span><br><span class="line"></span><br><span class="line">   if (taskSlot !&#x3D; null) &#123;</span><br><span class="line">      if (taskSlot.isActive(task.getJobID(), task.getAllocationId())) &#123;</span><br><span class="line">         if (taskSlot.add(task)) &#123;</span><br><span class="line">         &#x2F;&#x2F;添加task和slot的映射</span><br><span class="line">            taskSlotMappings.put(task.getExecutionId(), new TaskSlotMapping&lt;&gt;(task, taskSlot));</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         throw new SlotNotActiveException(task.getJobID(), task.getAllocationId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new SlotNotFoundException(task.getAllocationId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>task.startTaskThread()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">public void startTaskThread() &#123;</span><br><span class="line">		executingThread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      doRun();</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      terminationFuture.complete(executionState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doRun() &#123;</span><br><span class="line">   &#x2F;&#x2F; ----------------------------</span><br><span class="line">   &#x2F;&#x2F;  Initial State transition</span><br><span class="line">   &#x2F;&#x2F; ----------------------------</span><br><span class="line">   while (true) &#123;</span><br><span class="line">      ExecutionState current &#x3D; this.executionState;</span><br><span class="line">      if (current &#x3D;&#x3D; ExecutionState.CREATED) &#123;</span><br><span class="line">      &#x2F;&#x2F;把CREATED状态转为DEPLOYING</span><br><span class="line">         if (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</span><br><span class="line">            &#x2F;&#x2F; success, we can start our work</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (current &#x3D;&#x3D; ExecutionState.FAILED) &#123;</span><br><span class="line">         &#x2F;&#x2F; we were immediately failed. tell the TaskManager that we reached our final state</span><br><span class="line">         notifyFinalState();</span><br><span class="line">         if (metrics !&#x3D; null) &#123;</span><br><span class="line">            metrics.close();</span><br><span class="line">         &#125;</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (current &#x3D;&#x3D; ExecutionState.CANCELING) &#123;</span><br><span class="line">         if (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</span><br><span class="line">            &#x2F;&#x2F; we were immediately canceled. tell the TaskManager that we reached our final state</span><br><span class="line">            notifyFinalState();</span><br><span class="line">            if (metrics !&#x3D; null) &#123;</span><br><span class="line">               metrics.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         if (metrics !&#x3D; null) &#123;</span><br><span class="line">            metrics.close();</span><br><span class="line">         &#125;</span><br><span class="line">         throw new IllegalStateException(&quot;Invalid state for beginning of operation of task &quot; + this + &#39;.&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; all resource acquisitions and registrations from here on</span><br><span class="line">   &#x2F;&#x2F; need to be undone in the end</span><br><span class="line">   Map&lt;String, Future&lt;Path&gt;&gt; distributedCacheEntries &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   AbstractInvokable invokable &#x3D; null;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; ----------------------------</span><br><span class="line">      &#x2F;&#x2F;  Task Bootstrap - We periodically</span><br><span class="line">      &#x2F;&#x2F;  check for canceling as a shortcut</span><br><span class="line">      &#x2F;&#x2F; ----------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; activate safety net for task thread</span><br><span class="line">      LOG.info(&quot;Creating FileSystem stream leak safety net for task &#123;&#125;&quot;, this);</span><br><span class="line">      FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line"></span><br><span class="line">      blobService.getPermanentBlobService().registerJob(jobId);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; first of all, get a user-code classloader</span><br><span class="line">      &#x2F;&#x2F; this may involve downloading the job&#39;s JAR files and&#x2F;or classes</span><br><span class="line">      LOG.info(&quot;Loading JAR files for task &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">      userCodeClassLoader &#x3D; createUserCodeClassloader();</span><br><span class="line">      final ExecutionConfig executionConfig &#x3D; serializedExecutionConfig.deserializeValue(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">      if (executionConfig.getTaskCancellationInterval() &gt;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; override task cancellation interval from Flink config if set in ExecutionConfig</span><br><span class="line">         taskCancellationInterval &#x3D; executionConfig.getTaskCancellationInterval();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (executionConfig.getTaskCancellationTimeout() &gt;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; override task cancellation timeout from Flink config if set in ExecutionConfig</span><br><span class="line">         taskCancellationTimeout &#x3D; executionConfig.getTaskCancellationTimeout();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F; register the task with the network stack</span><br><span class="line">      &#x2F;&#x2F; this operation may fail if the system does not have enough</span><br><span class="line">      &#x2F;&#x2F; memory to run the necessary data exchanges</span><br><span class="line">      &#x2F;&#x2F; the registration must also strictly be undone</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      LOG.info(&quot;Registering task at network: &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化ResultPartition和InputGate，注册BufferPool</span><br><span class="line">      setupPartitionsAndGates(consumableNotifyingPartitionWriters, inputGates);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将ResultPartition注册到EventDispatcher，添加接收消息事件的监听</span><br><span class="line">      for (ResultPartitionWriter partitionWriter : consumableNotifyingPartitionWriters) &#123;</span><br><span class="line">         taskEventDispatcher.registerPartition(partitionWriter.getPartitionId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件写入分布式缓存</span><br><span class="line">      &#x2F;&#x2F; next, kick off the background copying of files for the distributed cache</span><br><span class="line">      try &#123;</span><br><span class="line">         for (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; entry :</span><br><span class="line">               DistributedCache.readFileInfoFromConfig(jobConfiguration)) &#123;</span><br><span class="line">            LOG.info(&quot;Obtaining local cache file for &#39;&#123;&#125;&#39;.&quot;, entry.getKey());</span><br><span class="line">            Future&lt;Path&gt; cp &#x3D; fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);</span><br><span class="line">            distributedCacheEntries.put(entry.getKey(), cp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new Exception(</span><br><span class="line">            String.format(&quot;Exception while adding files to distributed cache of task %s (%s).&quot;, taskNameWithSubtask, executionId), e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  call the user code initialization methods</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      TaskKvStateRegistry kvStateRegistry &#x3D; kvStateService.createKvStateTaskRegistry(jobId, getJobVertexId());</span><br><span class="line"></span><br><span class="line">      Environment env &#x3D; new RuntimeEnvironment(</span><br><span class="line">         jobId,</span><br><span class="line">         vertexId,</span><br><span class="line">         executionId,</span><br><span class="line">         executionConfig,</span><br><span class="line">         taskInfo,</span><br><span class="line">         jobConfiguration,</span><br><span class="line">         taskConfiguration,</span><br><span class="line">         userCodeClassLoader,</span><br><span class="line">         memoryManager,</span><br><span class="line">         ioManager,</span><br><span class="line">         broadcastVariableManager,</span><br><span class="line">         taskStateManager,</span><br><span class="line">         aggregateManager,</span><br><span class="line">         accumulatorRegistry,</span><br><span class="line">         kvStateRegistry,</span><br><span class="line">         inputSplitProvider,</span><br><span class="line">         distributedCacheEntries,</span><br><span class="line">         consumableNotifyingPartitionWriters,</span><br><span class="line">         inputGates,</span><br><span class="line">         taskEventDispatcher,</span><br><span class="line">         checkpointResponder,</span><br><span class="line">         taskManagerConfig,</span><br><span class="line">         metrics,</span><br><span class="line">         this);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure the user code classloader is accessible thread-locally.</span><br><span class="line">      &#x2F;&#x2F; We are setting the correct context class loader before instantiating the invokable</span><br><span class="line">      &#x2F;&#x2F; so that it is available to the invokable during its entire lifetime.</span><br><span class="line">      executingThread.setContextClassLoader(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每一个 StreamNode 在添加的时候都会有一个 jobVertexClass 属性</span><br><span class="line">			&#x2F;&#x2F; 对于一个 operator chain，就是 head operator 对应的 invokableClassName，见 StreamingJobGraphGenerator.createChain</span><br><span class="line">			&#x2F;&#x2F; 通过反射创建 AbstractInvokable 对象</span><br><span class="line">			&#x2F;&#x2F; 对于 Stream 任务而言，就是 StreamTask 的子类，SourceStreamTask、OneInputStreamTask、TwoInputStreamTask 等</span><br><span class="line">      &#x2F;&#x2F; now load and instantiate the task&#39;s invokable code</span><br><span class="line">      invokable &#x3D; loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  actual task core work</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we must make strictly sure that the invokable is accessible to the cancel() call</span><br><span class="line">      &#x2F;&#x2F; by the time we switched to running.</span><br><span class="line">      this.invokable &#x3D; invokable;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; switch to the RUNNING state, if that fails, we have been canceled&#x2F;failed in the meantime</span><br><span class="line">      if (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; notify everyone that we switched to running</span><br><span class="line">      taskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure the user code classloader is accessible thread-locally</span><br><span class="line">      executingThread.setContextClassLoader(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; run the invokable</span><br><span class="line">      &#x2F;&#x2F;运行StreamTask</span><br><span class="line">      invokable.invoke();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure, we enter the catch block if the task leaves the invoke() method due</span><br><span class="line">      &#x2F;&#x2F; to the fact that it has been canceled</span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  finalization of a successful execution</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; finish the produced partitions. if this fails, we consider the execution failed.</span><br><span class="line">      for (ResultPartitionWriter partitionWriter : consumableNotifyingPartitionWriters) &#123;</span><br><span class="line">         if (partitionWriter !&#x3D; null) &#123;</span><br><span class="line">            partitionWriter.finish();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; try to mark the task as finished</span><br><span class="line">      &#x2F;&#x2F; if that fails, the task was canceled&#x2F;failed in the meantime</span><br><span class="line">      if (!transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable t) &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractInvokable的invoke调用StreamTask的invoke，<code>StreamTask</code> 完整的生命周期包括：</p>
<ul>
<li>创建状态存储后端，为 OperatorChain 中的所有算子提供状态</li>
<li>加载 OperatorChain 中的所有算子</li>
<li>所有的 operator 调用 <code>setup</code></li>
<li>task 相关的初始化操作</li>
<li>所有 operator 调用 <code>initializeState</code> 初始化状态</li>
<li>所有的 operator 调用 <code>open</code></li>
<li>runMailboxLoop 方法循环处理数据</li>
<li>所有 operator 调用 <code>close</code></li>
<li>所有 operator 调用 <code>dispose</code></li>
<li>通用的 cleanup 操作</li>
<li>task 相关的 cleanup 操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final void invoke() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      beforeInvoke();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; final check to exit early before starting to run</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; let the task do its work</span><br><span class="line">      isRunning &#x3D; true;</span><br><span class="line">      runMailboxLoop();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; if this left the run() method cleanly despite the fact that this was canceled,</span><br><span class="line">      &#x2F;&#x2F; make sure the &quot;clean shutdown&quot; is not attempted</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      afterInvoke();</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      cleanUpInvoke();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beforeInvoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void beforeInvoke() throws Exception &#123;</span><br><span class="line">   disposedOperators &#x3D; false;</span><br><span class="line">   LOG.debug(&quot;Initializing &#123;&#125;.&quot;, getName());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;准备异步线程池</span><br><span class="line">   asyncOperationsThreadPool &#x3D; Executors.newCachedThreadPool(new ExecutorThreadFactory(&quot;AsyncOperations&quot;, uncaughtExceptionHandler));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建状态存储后端</span><br><span class="line">   stateBackend &#x3D; createStateBackend();</span><br><span class="line">   checkpointStorage &#x3D; stateBackend.createCheckpointStorage(getEnvironment().getJobID());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; if the clock is not already set, then assign a default TimeServiceProvider</span><br><span class="line">   if (timerService &#x3D;&#x3D; null) &#123;</span><br><span class="line">      ThreadFactory timerThreadFactory &#x3D;</span><br><span class="line">         new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, &quot;Time Trigger for &quot; + getName());</span><br><span class="line"></span><br><span class="line">      timerService &#x3D; new SystemProcessingTimeService(</span><br><span class="line">         this::handleTimerException,</span><br><span class="line">         timerThreadFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 OperatorChain，会加载每一个 operator，并调用 setup 方法</span><br><span class="line">   operatorChain &#x3D; new OperatorChain&lt;&gt;(this, recordWriter);</span><br><span class="line">   headOperator &#x3D; operatorChain.getHeadOperator();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; task specific initialization</span><br><span class="line">   &#x2F;&#x2F; 由具体 StreamTask 子类实现初始化操作</span><br><span class="line">   init();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; save the work of reloading state, etc, if the task is already canceled</span><br><span class="line">   if (canceled) &#123;</span><br><span class="line">      throw new CancelTaskException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; -------- Invoke --------</span><br><span class="line">   LOG.debug(&quot;Invoking &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we need to make sure that any triggers scheduled in open() cannot be</span><br><span class="line">   &#x2F;&#x2F; executed before all operators are opened</span><br><span class="line">   actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; both the following operations are protected by the lock</span><br><span class="line">      &#x2F;&#x2F; so that we avoid race conditions in the case that initializeState()</span><br><span class="line">      &#x2F;&#x2F; registers a timer, that fires before the open() is called.</span><br><span class="line"></span><br><span class="line">      initializeStateAndOpen();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void initializeStateAndOpen() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   StreamOperator&lt;?&gt;[] allOperators &#x3D; operatorChain.getAllOperators();</span><br><span class="line">&#x2F;&#x2F;初始化operatorChain的所有StreamOperator状态并调用open方法</span><br><span class="line">   for (StreamOperator&lt;?&gt; operator : allOperators) &#123;</span><br><span class="line">      if (null !&#x3D; operator) &#123;</span><br><span class="line">         operator.initializeState();</span><br><span class="line">         operator.open();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beforeInvoke初始化之后进入task主流程runMailboxLoop()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void runMailboxLoop() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;进入 mailboxProcessor</span><br><span class="line">      mailboxProcessor.runMailboxLoop();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      Optional&lt;InterruptedException&gt; interruption &#x3D; ExceptionUtils.findThrowable(e, InterruptedException.class);</span><br><span class="line">      if (interruption.isPresent()) &#123;</span><br><span class="line">         if (!canceled) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            throw interruption.get();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else if (canceled) &#123;</span><br><span class="line">         LOG.warn(&quot;Error while canceling task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         throw e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MailboxProcessor类,Mailbox的结构用来保证单线程执行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void runMailboxLoop() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   final TaskMailbox localMailbox &#x3D; mailbox;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查当前运行线程是否是 mailbox 线程，只有 mailbox 线程能运行该方法</span><br><span class="line">   Preconditions.checkState(</span><br><span class="line">      localMailbox.isMailboxThread(),</span><br><span class="line">      &quot;Method must be executed by declared mailbox thread!&quot;);</span><br><span class="line"></span><br><span class="line">   assert localMailbox.getState() &#x3D;&#x3D; TaskMailbox.State.OPEN : &quot;Mailbox must be opened!&quot;;</span><br><span class="line"></span><br><span class="line">   final MailboxController defaultActionContext &#x3D; new MailboxController(this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有 mail 需要处理，这里会进行相应的处理，处理完才会进行下面的 event processing，进行 task 的 default action，也就是调用 processInput()</span><br><span class="line">   while (processMail(localMailbox)) &#123;</span><br><span class="line">      mailboxDefaultAction.runDefaultAction(defaultActionContext); &#x2F;&#x2F; lock is acquired inside default action as needed</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processMail会检测 MailBox中是否有 mail 需要处理，如果有的话，就做相应的处理，<strong>一直将全部的 mail 处理完才会返回</strong>，只要 loop 还在进行，这里就会返回 true，否则会返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private boolean processMail(TaskMailbox mailbox) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only</span><br><span class="line">   &#x2F;&#x2F; acquired after this point.</span><br><span class="line">   &#x2F;&#x2F;taskmailbox 会将 queue 中的消息移到 batch，然后从 batch queue 中依次 take；新 mail 写入 queue。从 batch take 时避免加锁</span><br><span class="line">   if (!mailbox.createBatch()) &#123;</span><br><span class="line">      &#x2F;&#x2F; We can also directly return true because all changes to #isMailboxLoopRunning must be connected to</span><br><span class="line">      &#x2F;&#x2F; mailbox.hasMail() &#x3D;&#x3D; true.</span><br><span class="line">      &#x2F;&#x2F; 消息为空时直接返回</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Take mails in a non-blockingly and execute them.</span><br><span class="line">   Optional&lt;Mail&gt; maybeMail;</span><br><span class="line">   &#x2F;&#x2F; 从 batch 获取 mail 执行，直到 batch 中的 mail 处理完</span><br><span class="line">   while (isMailboxLoopRunning() &amp;&amp; (maybeMail &#x3D; mailbox.tryTakeFromBatch()).isPresent()) &#123;</span><br><span class="line">      maybeMail.get().run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; If the default action is currently not available, we can run a blocking mailbox execution until the default</span><br><span class="line">   &#x2F;&#x2F; action becomes available again.</span><br><span class="line">   &#x2F;&#x2F;做一个状态检查，等待mail状态变为available</span><br><span class="line">   while (isDefaultActionUnavailable() &amp;&amp; isMailboxLoopRunning()) &#123;</span><br><span class="line">      mailbox.take(MIN_PRIORITY).run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return isMailboxLoopRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理完Mailbox，进入MailboxDefaultAction类的runDefaultAction，最终进入StreamTask的processInput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.mailboxProcessor &#x3D; new MailboxProcessor(this::processInput, mailbox, actionExecutor);</span><br></pre></td></tr></table></figure>

<p>对于 StreamTask 来说，event-processing 是在 processInput() 方法中实现的，调用StreamInputProcessor的processInput处理数据，StreamInputProcessor是StreamTask的成员变量，子类有StreamOneInputProcessor和StreamTwoInputProcessor，分别对应OneInputStreamTask和TwoInputStreamTask的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void processInput(MailboxDefaultAction.Controller controller) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; event 处理</span><br><span class="line">   InputStatus status &#x3D; inputProcessor.processInput();</span><br><span class="line">   &#x2F;&#x2F; 如果输入还有数据，并且 recordWriter 是可用的(之前的异步操作已经处理完成)，这里就直接返回了</span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.MORE_AVAILABLE &amp;&amp; recordWriter.isAvailable()) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.END_OF_INPUT) &#123;</span><br><span class="line">   &#x2F;&#x2F; 输入已经处理完了</span><br><span class="line">      controller.allActionsCompleted();</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 代码进行到这里说明 input 或 output 没有准备好（比如当前流中没有数据）</span><br><span class="line">   CompletableFuture&lt;?&gt; jointFuture &#x3D; getInputOutputJointFuture(status);</span><br><span class="line">   &#x2F;&#x2F; 告诉 MailBox 先暂停 loop</span><br><span class="line">   MailboxDefaultAction.Suspension suspendedDefaultAction &#x3D; controller.suspendDefaultAction();</span><br><span class="line">   &#x2F;&#x2F; 等待 future 完成后，继续 mailbox loop（等待 input 和 output 可用后，才会继续）</span><br><span class="line">   jointFuture.thenRun(suspendedDefaultAction::resume);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface StreamInputProcessor extends AvailabilityProvider, Closeable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * @return input status to estimate whether more records can be processed immediately or not.</span><br><span class="line">    * If there are no more records available at the moment and the caller should check finished</span><br><span class="line">    * state and&#x2F;or &#123;@link #getAvailableFuture()&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   InputStatus processInput() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以OneInputStreamTask看下StreamOneInputProcessor的处理过程,在调用的时候init会初始化StreamOneInputProcessor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OneInputStreamTask&lt;IN, OUT&gt; extends StreamTask&#123;</span><br><span class="line">@Override</span><br><span class="line">	public void init() throws Exception &#123;</span><br><span class="line">		StreamConfig configuration &#x3D; getConfiguration();</span><br><span class="line">		int numberOfInputs &#x3D; configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">		if (numberOfInputs &gt; 0) &#123;</span><br><span class="line">			CheckpointedInputGate inputGate &#x3D; createCheckpointedInputGate();</span><br><span class="line">			TaskIOMetricGroup taskIOMetricGroup &#x3D; getEnvironment().getMetricGroup().getIOMetricGroup();</span><br><span class="line">			taskIOMetricGroup.gauge(&quot;checkpointAlignmentTime&quot;, inputGate::getAlignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">			DataOutput&lt;IN&gt; output &#x3D; createDataOutput();</span><br><span class="line">			StreamTaskInput&lt;IN&gt; input &#x3D; createTaskInput(inputGate, output);</span><br><span class="line">			&#x2F;&#x2F;初始化StreamOneInputProcessor</span><br><span class="line">			inputProcessor &#x3D; new StreamOneInputProcessor&lt;&gt;(</span><br><span class="line">				input,</span><br><span class="line">				output,</span><br><span class="line">				getCheckpointLock(),</span><br><span class="line">				operatorChain);</span><br><span class="line">		&#125;</span><br><span class="line">		headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge);</span><br><span class="line">		&#x2F;&#x2F; wrap watermark gauge since registered metrics must be unique</span><br><span class="line">		getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge::getValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后在处理数据时调用StreamOneInputProcessor的processInput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public InputStatus processInput() throws Exception &#123;</span><br><span class="line">   InputStatus status &#x3D; input.emitNext(output);</span><br><span class="line"></span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.END_OF_INPUT) &#123;</span><br><span class="line">      synchronized (lock) &#123;</span><br><span class="line">         operatorChain.endHeadOperatorInput(1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用StreamTaskNetworkInput的emitNext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public InputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; get the stream element from the deserializer</span><br><span class="line">      &#x2F;&#x2F;反序列化</span><br><span class="line">      if (currentRecordDeserializer !&#x3D; null) &#123;</span><br><span class="line">         DeserializationResult result &#x3D; currentRecordDeserializer.getNextRecord(deserializationDelegate);</span><br><span class="line">         if (result.isBufferConsumed()) &#123;</span><br><span class="line">         &#x2F;&#x2F;如果buffer里面的数据已经被消费了，则归还buffer</span><br><span class="line">            currentRecordDeserializer.getCurrentBuffer().recycleBuffer();</span><br><span class="line">            currentRecordDeserializer &#x3D; null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (result.isFullRecord()) &#123;</span><br><span class="line">         &#x2F;&#x2F;得到了一条完整的记录</span><br><span class="line">            processElement(deserializationDelegate.getInstance(), output);</span><br><span class="line">            &#x2F;&#x2F; 处理完一条数据</span><br><span class="line">            return InputStatus.MORE_AVAILABLE;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;获取下一个 BufferOrEvent，这是个阻塞的调用</span><br><span class="line">      Optional&lt;BufferOrEvent&gt; bufferOrEvent &#x3D; checkpointedInputGate.pollNext();</span><br><span class="line">      if (bufferOrEvent.isPresent()) &#123;</span><br><span class="line">         processBufferOrEvent(bufferOrEvent.get());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         if (checkpointedInputGate.isFinished()) &#123;</span><br><span class="line">            checkState(checkpointedInputGate.getAvailableFuture().isDone(), &quot;Finished BarrierHandler should be available&quot;);</span><br><span class="line">            if (!checkpointedInputGate.isEmpty()) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;上游已结束</span><br><span class="line">            return InputStatus.END_OF_INPUT;</span><br><span class="line">         &#125;</span><br><span class="line">         return InputStatus.NOTHING_AVAILABLE;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processElement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void processElement(StreamElement recordOrMark, DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line">   if (recordOrMark.isRecord())&#123;</span><br><span class="line">   &#x2F;&#x2F;是一条正常的记录，调用 operator 的处理方法，最终会调用用户自定义的函数的处理方法</span><br><span class="line">      output.emitRecord(recordOrMark.asRecord());</span><br><span class="line">   &#125; else if (recordOrMark.isWatermark()) &#123;</span><br><span class="line">      statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel);</span><br><span class="line">   &#125; else if (recordOrMark.isLatencyMarker()) &#123;</span><br><span class="line">      output.emitLatencyMarker(recordOrMark.asLatencyMarker());</span><br><span class="line">   &#125; else if (recordOrMark.isStreamStatus()) &#123;</span><br><span class="line">      statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), lastChannel);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;Unknown type of StreamElement&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processBufferOrEvent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void processBufferOrEvent(BufferOrEvent bufferOrEvent) throws IOException &#123;</span><br><span class="line">   if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果是Buffer，要确定是哪个 channel 的，然后用对应 channel 的反序列化器解析</span><br><span class="line">					&#x2F;&#x2F;不同channel在反序列化的时候不能混淆</span><br><span class="line">      lastChannel &#x3D; bufferOrEvent.getChannelIndex();</span><br><span class="line">      checkState(lastChannel !&#x3D; StreamTaskInput.UNSPECIFIED);</span><br><span class="line">      currentRecordDeserializer &#x3D; recordDeserializers[lastChannel];</span><br><span class="line">      checkState(currentRecordDeserializer !&#x3D; null,</span><br><span class="line">         &quot;currentRecordDeserializer has already been released&quot;);</span><br><span class="line"></span><br><span class="line">      currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; Event received</span><br><span class="line">      final AbstractEvent event &#x3D; bufferOrEvent.getEvent();</span><br><span class="line">      &#x2F;&#x2F; TODO: with checkpointedInputGate.isFinished() we might not need to support any events on this level.</span><br><span class="line">      if (event.getClass() !&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">         throw new IOException(&quot;Unexpected event: &quot; + event);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; release the record deserializer immediately,</span><br><span class="line">      &#x2F;&#x2F; which is very valuable in case of bounded stream</span><br><span class="line">      releaseDeserializer(bufferOrEvent.getChannelIndex());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入StreamTaskNetworkOutput的emitRecord</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void emitRecord(StreamRecord&lt;IN&gt; record) throws Exception &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      numRecordsIn.inc();</span><br><span class="line">      operator.setKeyContextElement1(record);</span><br><span class="line">      operator.processElement(record);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 operator 的处理方法，最终会调用用户自定义的函数的处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">   output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SourceStreamTask的实现稍有不同，主要是因为有一个问题：就是 <em>SourceStreamTask</em>，会有一个兼容性的问题，因为在流的 source 端，它的 event prcessing 是来专门产生一个无限流数据，在这个处理中，并不能穿插 MailBox 中的 mail 检测，也就是说，如果只有一个 MailBox 线程处理的话，当这个线程去产生数据的话，它一直运行下去，就无法再去检测 MailBox 中是否有新的 mail 到来（在 Source 未来的版本中，可以完美兼容 MailBox 线程设计，见 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-27%3A+Refactor+Source+Interface" target="_blank" rel="noopener">FLIP-27</a>，但现在的版本还不兼容）。</p>
<p>为了兼容 Source 端，目前的解决方案是：<strong>两个线程操作，一个专门用产生无限流，另一个是 MailBox 线程（处理 Checkpoint、timer 等），这两个线程为了保证线程安全，还是使用 Checkpoint Lock 做排它锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected void processInput(MailboxDefaultAction.Controller controller) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 告诉 MailBox 先暂停 loop</span><br><span class="line">   controller.suspendDefaultAction();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Against the usual contract of this method, this implementation is not step-wise but blocking instead for</span><br><span class="line">   &#x2F;&#x2F; compatibility reasons with the current source interface (source functions run as a loop, not in steps).</span><br><span class="line">   sourceThread.setTaskDescription(getName());</span><br><span class="line">   sourceThread.start();</span><br><span class="line">   sourceThread.getCompletionFuture().whenComplete((Void ignore, Throwable sourceThreadThrowable) -&gt; &#123;</span><br><span class="line">      if (sourceThreadThrowable &#x3D;&#x3D; null || isFinished) &#123;</span><br><span class="line">      &#x2F;&#x2F; sourceThread 完成后，没有抛出异常或 task 完成的情况下</span><br><span class="line">         mailboxProcessor.allActionsCompleted();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 没有完成或者抛出异常的情况下</span><br><span class="line">         mailboxProcessor.reportThrowable(sourceThreadThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private class LegacySourceFunctionThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">		private final CompletableFuture&lt;Void&gt; completionFuture;</span><br><span class="line"></span><br><span class="line">		LegacySourceFunctionThread() &#123;</span><br><span class="line">			this.completionFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				headOperator.run(getCheckpointLock(), getStreamStatusMaintainer(), operatorChain);</span><br><span class="line">				completionFuture.complete(null);</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				&#x2F;&#x2F; Note, t can be also an InterruptedException</span><br><span class="line">				completionFuture.completeExceptionally(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void setTaskDescription(final String taskDescription) &#123;</span><br><span class="line">			setName(&quot;Legacy Source Thread - &quot; + taskDescription);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Void&gt; getCompletionFuture() &#123;</span><br><span class="line">			return completionFuture;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<p>1.<em>LegacySourceFunctionThread</em> 线程在启动时，会先通知一下 MailBox，这个就是上面说的那个状态检查，收到这个信号之后，MailBox 就会在 processMail() 中一直等待并且处理 mail，不会返回（也就是 MailBox 主线程一直在处理 mail 事件）；</p>
<p>2.<em>LegacySourceFunctionThread</em> 线程就是专门生产数据的，跟 MailBox 这两个线程都在运行。</p>
<p>那么两个线程如何保证线程安全呢？如果仔细看上面的代码就会发现，在 SourceStreamTask 中还继续使用了 getCheckpointLock()，虽然这个方法现在已经被标注了将要被废弃，但 Source 没有改造完成之前，Source 的实现还是会继续依赖 checkpoint lock。</p>
<p>数据处理完进入afterInvoke，所有 operator 调用 close，所有 operator 调用 dispose</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void afterInvoke() throws Exception &#123;</span><br><span class="line">   LOG.debug(&quot;Finished task &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure no further checkpoint and notification actions happen.</span><br><span class="line">   &#x2F;&#x2F; we make sure that no other thread is currently in the locked scope before</span><br><span class="line">   &#x2F;&#x2F; we close the operators by trying to acquire the checkpoint scope lock</span><br><span class="line">   &#x2F;&#x2F; we also need to make sure that no triggers fire concurrently with the close logic</span><br><span class="line">   &#x2F;&#x2F; at the same time, this makes sure that during any &quot;regular&quot; exit where still</span><br><span class="line">   actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; this is part of the main logic, so if this fails, the task is considered failed</span><br><span class="line">      closeAllOperators();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure no new timers can come</span><br><span class="line">      timerService.quiesce();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; let mailbox execution reject all new letters from this point</span><br><span class="line">      mailboxProcessor.prepareClose();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; only set the StreamTask to not running after all operators have been closed!</span><br><span class="line">      &#x2F;&#x2F; See FLINK-7430</span><br><span class="line">      isRunning &#x3D; false;</span><br><span class="line">   &#125;);</span><br><span class="line">   &#x2F;&#x2F; processes the remaining mails; no new mails can be enqueued</span><br><span class="line">   mailboxProcessor.drain();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure all timers finish</span><br><span class="line">   timerService.awaitPendingAfterQuiesce();</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Closed operators for task &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure all buffered data is flushed</span><br><span class="line">   operatorChain.flushOutputs();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make an attempt to dispose the operators such that failures in the dispose call</span><br><span class="line">   &#x2F;&#x2F; still let the computation fail</span><br><span class="line">   disposeAllOperators(false);</span><br><span class="line">   disposedOperators &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下beforeinvoke中OperatorChain的初始化过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public OperatorChain(</span><br><span class="line">      StreamTask&lt;OUT, OP&gt; containingTask,</span><br><span class="line">      RecordWriterDelegate&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriterDelegate) &#123;</span><br><span class="line"></span><br><span class="line">   final ClassLoader userCodeClassloader &#x3D; containingTask.getUserCodeClassLoader();</span><br><span class="line">   final StreamConfig configuration &#x3D; containingTask.getConfiguration();</span><br><span class="line"></span><br><span class="line">   StreamOperatorFactory&lt;OUT&gt; operatorFactory &#x3D; configuration.getStreamOperatorFactory(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we read the chained configs, and the order of record writer registrations by output name</span><br><span class="line">   &#x2F;&#x2F;OperatorChain 内部所有的 operator 的配置</span><br><span class="line">   Map&lt;Integer, StreamConfig&gt; chainedConfigs &#x3D; configuration.getTransitiveChainedTaskConfigsWithSelf(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create the final output stream writers</span><br><span class="line">   &#x2F;&#x2F; we iterate through all the out edges from this job vertex and create a stream output</span><br><span class="line">   &#x2F;&#x2F; 所有的输出边，这是对外输出，不包含内部 operator 之间的的数据传输</span><br><span class="line">   List&lt;StreamEdge&gt; outEdgesInOrder &#x3D; configuration.getOutEdgesInOrder(userCodeClassloader);</span><br><span class="line">   Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputMap &#x3D; new HashMap&lt;&gt;(outEdgesInOrder.size());</span><br><span class="line">   this.streamOutputs &#x3D; new RecordWriterOutput&lt;?&gt;[outEdgesInOrder.size()];</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; from here on, we need to make sure that the output writers are shut down again on failure</span><br><span class="line">   boolean success &#x3D; false;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建对外输出的 RecordWriterOutput</span><br><span class="line">      for (int i &#x3D; 0; i &lt; outEdgesInOrder.size(); i++) &#123;</span><br><span class="line">         StreamEdge outEdge &#x3D; outEdgesInOrder.get(i);</span><br><span class="line"></span><br><span class="line">         RecordWriterOutput&lt;?&gt; streamOutput &#x3D; createStreamOutput(</span><br><span class="line">            recordWriterDelegate.getRecordWriter(i),</span><br><span class="line">            outEdge,</span><br><span class="line">            chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">            containingTask.getEnvironment());</span><br><span class="line"></span><br><span class="line">         this.streamOutputs[i] &#x3D; streamOutput;</span><br><span class="line">         streamOutputMap.put(outEdge, streamOutput);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we create the chain of operators and grab the collector that leads into the chain</span><br><span class="line">      &#x2F;&#x2F;这里会递归调用，为 OperatorChain 内部的所有的 Operator 都创建 output</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOps &#x3D; new ArrayList&lt;&gt;(chainedConfigs.size());</span><br><span class="line">      this.chainEntryPoint &#x3D; createOutputCollector(</span><br><span class="line">         containingTask,</span><br><span class="line">         configuration,</span><br><span class="line">         chainedConfigs,</span><br><span class="line">         userCodeClassloader,</span><br><span class="line">         streamOutputMap,</span><br><span class="line">         allOps,</span><br><span class="line">         containingTask.getMailboxExecutorFactory());</span><br><span class="line"></span><br><span class="line">      if (operatorFactory !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;chainEntryPoint 是 headOperator 的 output</span><br><span class="line">         WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; output &#x3D; getChainEntryPoint();</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;创建headOperator</span><br><span class="line">         headOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">               operatorFactory,</span><br><span class="line">               containingTask,</span><br><span class="line">               configuration,</span><br><span class="line">               output);</span><br><span class="line"></span><br><span class="line">         headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, output.getWatermarkGauge());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         headOperator &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; add head operator to end of chain</span><br><span class="line">      allOps.add(headOperator);</span><br><span class="line"></span><br><span class="line">      this.allOperators &#x3D; allOps.toArray(new StreamOperator&lt;?&gt;[allOps.size()]);</span><br><span class="line"></span><br><span class="line">      success &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      &#x2F;&#x2F; make sure we clean up after ourselves in case of a failure after acquiring</span><br><span class="line">      &#x2F;&#x2F; the first resources</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">         for (RecordWriterOutput&lt;?&gt; output : this.streamOutputs) &#123;</span><br><span class="line">            if (output !&#x3D; null) &#123;</span><br><span class="line">               output.close();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WatermarkAssignerOperatorFactory类的createStreamOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public StreamOperator createStreamOperator(StreamTask containingTask, StreamConfig config, Output output) &#123;</span><br><span class="line">   WatermarkGenerator watermarkGenerator &#x3D; generatedWatermarkGenerator.newInstance(containingTask.getUserCodeClassLoader());</span><br><span class="line">   WatermarkAssignerOperator operator &#x3D; new WatermarkAssignerOperator(rowtimeFieldIndex, watermarkGenerator, idleTimeout);</span><br><span class="line">   &#x2F;&#x2F;调用headoperator的setup</span><br><span class="line">   operator.setup(containingTask, config, output);</span><br><span class="line">   return operator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createStreamOutput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private RecordWriterOutput&lt;OUT&gt; createStreamOutput(</span><br><span class="line">      RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriter,</span><br><span class="line">      StreamEdge edge,</span><br><span class="line">      StreamConfig upStreamConfig,</span><br><span class="line">      Environment taskEnvironment) &#123;</span><br><span class="line">   OutputTag sideOutputTag &#x3D; edge.getOutputTag(); &#x2F;&#x2F; OutputTag, return null if not sideOutput</span><br><span class="line"></span><br><span class="line">   TypeSerializer outSerializer &#x3D; null;</span><br><span class="line"></span><br><span class="line">   if (edge.getOutputTag() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; side output</span><br><span class="line">      &#x2F;&#x2F;拿到side output的反序列化器</span><br><span class="line">      outSerializer &#x3D; upStreamConfig.getTypeSerializerSideOut(</span><br><span class="line">            edge.getOutputTag(), taskEnvironment.getUserClassLoader());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; main output</span><br><span class="line">      &#x2F;&#x2F;拿到main output的反序列化器</span><br><span class="line">      outSerializer &#x3D; upStreamConfig.getTypeSerializerOut(taskEnvironment.getUserClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new RecordWriterOutput&lt;&gt;(recordWriter, outSerializer, sideOutputTag, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createOutputCollector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; createOutputCollector(</span><br><span class="line">      StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   List&lt;Tuple2&lt;WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;, StreamEdge&gt;&gt; allOutputs &#x3D; new ArrayList&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create collectors for the network outputs</span><br><span class="line">   for (StreamEdge outputEdge : operatorConfig.getNonChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      RecordWriterOutput&lt;T&gt; output &#x3D; (RecordWriterOutput&lt;T&gt;) streamOutputs.get(outputEdge);</span><br><span class="line"></span><br><span class="line">      allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Create collectors for the chained outputs</span><br><span class="line">   &#x2F;&#x2F; OperatorChain 内部 Operator 之间的边</span><br><span class="line">   for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">      int outputId &#x3D; outputEdge.getTargetId();</span><br><span class="line">      StreamConfig chainedOpConfig &#x3D; chainedConfigs.get(outputId);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;创建当前节点的下游节点，并返回当前节点的 output</span><br><span class="line">	&#x2F;&#x2F;createChainedOperator 在创建 operator 的时候，会调用 createOutputCollector 为 operator 创建 output</span><br><span class="line">	&#x2F;&#x2F;所以会形成递归调用关系，所有的 operator 以及它们的 output 都会被创建出来</span><br><span class="line">      WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; output &#x3D; createChainedOperator(</span><br><span class="line">         containingTask,</span><br><span class="line">         chainedOpConfig,</span><br><span class="line">         chainedConfigs,</span><br><span class="line">         userCodeClassloader,</span><br><span class="line">         streamOutputs,</span><br><span class="line">         allOperators,</span><br><span class="line">         outputEdge.getOutputTag(),</span><br><span class="line">         mailboxExecutorFactory);</span><br><span class="line">      allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; if there are multiple outputs, or the outputs are directed, we need to</span><br><span class="line">   &#x2F;&#x2F; wrap them as one output</span><br><span class="line"></span><br><span class="line">   List&lt;OutputSelector&lt;T&gt;&gt; selectors &#x3D; operatorConfig.getOutputSelectors(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   if (selectors &#x3D;&#x3D; null || selectors.isEmpty()) &#123;</span><br><span class="line">      &#x2F;&#x2F; simple path, no selector necessary</span><br><span class="line">      &#x2F;&#x2F;只有一个输出</span><br><span class="line">      if (allOutputs.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">         return allOutputs.get(0).f0;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">      &#x2F;&#x2F;不止有一个输出，需要使用 BroadcastingOutputCollector 进行封装</span><br><span class="line">         &#x2F;&#x2F; send to N outputs. Note that this includes the special case</span><br><span class="line">         &#x2F;&#x2F; of sending to zero outputs</span><br><span class="line">         @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">         Output&lt;StreamRecord&lt;T&gt;&gt;[] asArray &#x3D; new Output[allOutputs.size()];</span><br><span class="line">         for (int i &#x3D; 0; i &lt; allOutputs.size(); i++) &#123;</span><br><span class="line">            asArray[i] &#x3D; allOutputs.get(i).f0;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">         &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">         &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">         if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">            return new CopyingBroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">         &#125; else  &#123;</span><br><span class="line">            return new BroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; selector present, more complex routing necessary</span><br><span class="line">     &#x2F;&#x2F; 存在 selector，用 DirectedOutput 进行封装</span><br><span class="line">      &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">      &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">      &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">      if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">         return new CopyingDirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return new DirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createChainedOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">      StreamTask&lt;OUT, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      OutputTag&lt;IN&gt; outputTag,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   &#x2F;&#x2F; create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">   &#x2F;&#x2F; 为当前 Operator 创建 output</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput &#x3D; createOutputCollector(</span><br><span class="line">      containingTask,</span><br><span class="line">      operatorConfig,</span><br><span class="line">      chainedConfigs,</span><br><span class="line">      userCodeClassloader,</span><br><span class="line">      streamOutputs,</span><br><span class="line">      allOperators,</span><br><span class="line">      mailboxExecutorFactory);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; now create the operator and give it the output collector to write its output to</span><br><span class="line">   &#x2F;&#x2F;从 StreamConfig 中取出当前 Operator并调用setup</span><br><span class="line">   OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">         operatorConfig.getStreamOperatorFactory(userCodeClassloader),</span><br><span class="line">         containingTask,</span><br><span class="line">         operatorConfig,</span><br><span class="line">         chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">   allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;这里是在为当前 operator 前向的 operator 创建 output</span><br><span class="line">		&#x2F;&#x2F;所以当前 operator 被传递给前一个 operator 的 output，这样前一个 operator 的输出就可以直接调用当前 operator</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      currentOperatorOutput &#x3D; new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      TypeSerializer&lt;IN&gt; inSerializer &#x3D; operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">      currentOperatorOutput &#x3D; new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; wrap watermark gauges since registered metrics must be unique</span><br><span class="line">   chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, currentOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">   chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, chainedOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line"></span><br><span class="line">   return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/JobManager%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/22/JobManager%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" itemprop="url">JobManager启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-22T14:57:17+08:00">
                2020-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由MiniClusterClient客户端提交至MiniCluster的submitJob，submitJob将jobGraph提交到flink集群的Dispatcher，由Dispatcher生成jobmanager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;JobSudispatcherbmissionResult&gt; submitJob(JobGraph jobGraph) &#123;</span><br><span class="line">&#x2F;&#x2F;获取dispatcher地址</span><br><span class="line">   final CompletableFuture&lt;DispatcherGateway&gt; dispatcherGatewayFuture &#x3D; getDispatcherGatewayFuture();</span><br><span class="line">   final CompletableFuture&lt;InetSocketAddress&gt; blobServerAddressFuture &#x3D; createBlobServerAddress(dispatcherGatewayFuture);</span><br><span class="line">   &#x2F;&#x2F;上传jar包至Dispatcher</span><br><span class="line">   final CompletableFuture&lt;Void&gt; jarUploadFuture &#x3D; uploadAndSetJobFiles(blobServerAddressFuture, jobGraph);</span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; acknowledgeCompletableFuture &#x3D; jarUploadFuture</span><br><span class="line">      .thenCombine(</span><br><span class="line">         dispatcherGatewayFuture,</span><br><span class="line">         &#x2F;&#x2F;向dispatcher提交jobGraph</span><br><span class="line">         (Void ack, DispatcherGateway dispatcherGateway) -&gt; dispatcherGateway.submitJob(jobGraph, rpcTimeout))</span><br><span class="line">      .thenCompose(Function.identity());</span><br><span class="line">   return acknowledgeCompletableFuture.thenApply(</span><br><span class="line">      (Acknowledge ignored) -&gt; new JobSubmissionResult(jobGraph.getJobID()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatcher类submit方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; submitJob(JobGraph jobGraph, Time timeout) &#123;</span><br><span class="line">   log.info(&quot;Received JobGraph submission &#123;&#125; (&#123;&#125;).&quot;, jobGraph.getJobID(), jobGraph.getName());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;重复提交的job抛出异常</span><br><span class="line">      if (isDuplicateJob(jobGraph.getJobID())) &#123;</span><br><span class="line">         return FutureUtils.completedExceptionally(</span><br><span class="line">            new DuplicateJobSubmissionException(jobGraph.getJobID()));</span><br><span class="line">            &#x2F;&#x2F;不完整的job抛出异常</span><br><span class="line">      &#125; else if (isPartialResourceConfigured(jobGraph)) &#123;</span><br><span class="line">         return FutureUtils.completedExceptionally(</span><br><span class="line">            new JobSubmissionException(jobGraph.getJobID(), &quot;Currently jobs is not supported if parts of the vertices have &quot; +</span><br><span class="line">                  &quot;resources configured. The limitation will be removed in future versions.&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return internalSubmitJob(jobGraph);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (FlinkException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入Dispatcher类internalSubmitJob方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;Acknowledge&gt; internalSubmitJob(JobGraph jobGraph) &#123;</span><br><span class="line">   log.info(&quot;Submitting job &#123;&#125; (&#123;&#125;).&quot;, jobGraph.getJobID(), jobGraph.getName());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;终止老的JobManager并提交新的job</span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; persistAndRunFuture &#x3D; waitForTerminatingJobManager(jobGraph.getJobID(), jobGraph, this::persistAndRunJob)</span><br><span class="line">      .thenApply(ignored -&gt; Acknowledge.get());</span><br><span class="line"></span><br><span class="line">   return persistAndRunFuture.handleAsync((acknowledge, throwable) -&gt; &#123;</span><br><span class="line">      if (throwable !&#x3D; null) &#123;</span><br><span class="line">         cleanUpJobData(jobGraph.getJobID(), true);</span><br><span class="line"></span><br><span class="line">         final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line">         log.error(&quot;Failed to submit job &#123;&#125;.&quot;, jobGraph.getJobID(), strippedThrowable);</span><br><span class="line">         throw new CompletionException(</span><br><span class="line">            new JobSubmissionException(jobGraph.getJobID(), &quot;Failed to submit job.&quot;, strippedThrowable));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return acknowledge;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;, getRpcService().getExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下waitForTerminatingJobManager方法，就是终止相同jobId的JobManager并启动新的jobmanager，通过执行action.apply(jobGraph)，action方法是persistAndRunJob</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;Void&gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, FunctionWithException&lt;JobGraph, CompletableFuture&lt;Void&gt;, ?&gt; action) &#123;</span><br><span class="line">   final CompletableFuture&lt;Void&gt; jobManagerTerminationFuture &#x3D; getJobTerminationFuture(jobId)</span><br><span class="line">      .exceptionally((Throwable throwable) -&gt; &#123;</span><br><span class="line">         throw new CompletionException(</span><br><span class="line">            new DispatcherException(</span><br><span class="line">               String.format(&quot;Termination of previous JobManager for job %s failed. Cannot submit job under the same job id.&quot;, jobId),</span><br><span class="line">               throwable)); &#125;);</span><br><span class="line"></span><br><span class="line">   return jobManagerTerminationFuture.thenComposeAsync(</span><br><span class="line">      FunctionUtils.uncheckedFunction((ignored) -&gt; &#123;</span><br><span class="line">         jobManagerTerminationFutures.remove(jobId);</span><br><span class="line">         return action.apply(jobGraph);</span><br><span class="line">      &#125;),</span><br><span class="line">      getMainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下过程大概是提交job之后，创建JobManager，在JobManager中创建JobMaster，在JobMaster中创建Scheduler等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;Void&gt; persistAndRunJob(JobGraph jobGraph) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;保存jobGraph</span><br><span class="line">		jobGraphWriter.putJobGraph(jobGraph);</span><br><span class="line"></span><br><span class="line">		final CompletableFuture&lt;Void&gt; runJobFuture &#x3D; runJob(jobGraph);</span><br><span class="line"></span><br><span class="line">		return runJobFuture.whenComplete(BiConsumerWithException.unchecked((Object ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">			if (throwable !&#x3D; null) &#123;</span><br><span class="line">				jobGraphWriter.removeJobGraph(jobGraph.getJobID());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private CompletableFuture&lt;Void&gt; runJob(JobGraph jobGraph) &#123;</span><br><span class="line">		&#x2F;&#x2F;这里创建JobManager</span><br><span class="line">		final CompletableFuture&lt;JobManagerRunner&gt; jobManagerRunnerFuture &#x3D; createJobManagerRunner(jobGraph);</span><br><span class="line"></span><br><span class="line">		jobManagerRunnerFutures.put(jobGraph.getJobID(), jobManagerRunnerFuture);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建成功启动JobManager</span><br><span class="line">		return jobManagerRunnerFuture</span><br><span class="line">			.thenApply(FunctionUtils.uncheckedFunction(this::startJobManagerRunner))</span><br><span class="line">			.thenApply(FunctionUtils.nullFn())</span><br><span class="line">			......</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private CompletableFuture&lt;JobManagerRunner&gt; createJobManagerRunner(JobGraph jobGraph) &#123;</span><br><span class="line">		final RpcService rpcService &#x3D; getRpcService();</span><br><span class="line"></span><br><span class="line">		return CompletableFuture.supplyAsync(</span><br><span class="line">			CheckedSupplier.unchecked(() -&gt;</span><br><span class="line">			&#x2F;&#x2F;DefaultJobManagerRunnerFactory工厂类创建JobManager</span><br><span class="line">				jobManagerRunnerFactory.createJobManagerRunner(</span><br><span class="line">					jobGraph,</span><br><span class="line">					......),</span><br><span class="line">			rpcService.getExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public enum DefaultJobManagerRunnerFactory implements JobManagerRunnerFactory &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	@Override</span><br><span class="line">	public JobManagerRunner createJobManagerRunner(</span><br><span class="line">			JobGraph jobGraph,</span><br><span class="line">			......) throws Exception &#123;</span><br><span class="line">			</span><br><span class="line">&#x2F;&#x2F;DefaultJobMasterServiceFactory工厂类用来创建JobMaster</span><br><span class="line">		final JobMasterServiceFactory jobMasterFactory &#x3D; new DefaultJobMasterServiceFactory(</span><br><span class="line">			......);</span><br><span class="line"></span><br><span class="line">		return new JobManagerRunnerImpl(</span><br><span class="line">			jobGraph,</span><br><span class="line">			......);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JobManagerRunnerImpl创建jobMaster</span><br><span class="line">public JobManagerRunnerImpl(</span><br><span class="line">			final JobGraph jobGraph,</span><br><span class="line">			......) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; libraries and class loader first</span><br><span class="line">			try &#123;</span><br><span class="line">				libraryCacheManager.registerJob(</span><br><span class="line">						jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(), jobGraph.getClasspaths());</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				throw new Exception(&quot;Cannot set up the user code libraries: &quot; + e.getMessage(), e);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			final ClassLoader userCodeLoader &#x3D; libraryCacheManager.getClassLoader(jobGraph.getJobID());</span><br><span class="line">			if (userCodeLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new Exception(&quot;The user code class loader could not be initialized.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; high availability services next</span><br><span class="line">			this.runningJobsRegistry &#x3D; haServices.getRunningJobsRegistry();</span><br><span class="line">			&#x2F;&#x2F;获取HA选举服务</span><br><span class="line">			this.leaderElectionService &#x3D; haServices.getJobManagerLeaderElectionService(jobGraph.getJobID());</span><br><span class="line"></span><br><span class="line">			this.leaderGatewayFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; now start the JobManager，调用JobMaster的构造函数</span><br><span class="line">			this.jobMasterService &#x3D; jobMasterFactory.createJobMasterService(jobGraph, this, userCodeLoader);</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public JobMaster createJobMasterService(</span><br><span class="line">			JobGraph jobGraph,</span><br><span class="line">			OnCompletionActions jobCompletionActions,</span><br><span class="line">			ClassLoader userCodeClassloader) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		return new JobMaster(</span><br><span class="line">			rpcService,</span><br><span class="line">			jobMasterConfiguration,</span><br><span class="line">			ResourceID.generate(),</span><br><span class="line">			jobGraph,</span><br><span class="line">			haServices,</span><br><span class="line">			slotPoolFactory,</span><br><span class="line">			schedulerFactory,</span><br><span class="line">			jobManagerSharedServices,</span><br><span class="line">			heartbeatServices,</span><br><span class="line">			jobManagerJobMetricGroupFactory,</span><br><span class="line">			jobCompletionActions,</span><br><span class="line">			fatalErrorHandler,</span><br><span class="line">			userCodeClassloader,</span><br><span class="line">			schedulerNGFactory,</span><br><span class="line">			shuffleMaster,</span><br><span class="line">			lookup -&gt; new JobMasterPartitionTrackerImpl(</span><br><span class="line">				jobGraph.getJobID(),</span><br><span class="line">				shuffleMaster,</span><br><span class="line">				lookup</span><br><span class="line">			));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;进入JobMaster类构造函数</span><br><span class="line">	public JobMaster(</span><br><span class="line">			......</span><br><span class="line">			JobGraph jobGraph,</span><br><span class="line">			......) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		resourceManagerLeaderRetriever &#x3D; highAvailabilityServices.getResourceManagerLeaderRetriever();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建SlotPool，用来给job申请和分配slot资源</span><br><span class="line">		this.slotPool &#x3D; checkNotNull(slotPoolFactory).createSlotPool(jobGraph.getJobID());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Scheduler，SchedulerImpl类用来使用slotSelectionStrategy把task分配给slot</span><br><span class="line">		this.scheduler &#x3D; checkNotNull(schedulerFactory).createScheduler(slotPool);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来保存已连接的TaskManager</span><br><span class="line">		this.registeredTaskManagers &#x3D; new HashMap&lt;&gt;(4);</span><br><span class="line">		this.partitionTracker &#x3D; checkNotNull(partitionTrackerFactory)</span><br><span class="line">			.create(resourceID -&gt; &#123;</span><br><span class="line">				Tuple2&lt;TaskManagerLocation, TaskExecutorGateway&gt; taskManagerInfo &#x3D; registeredTaskManagers.get(resourceID);</span><br><span class="line">				if (taskManagerInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">					return Optional.empty();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				return Optional.of(taskManagerInfo.f1);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		this.backPressureStatsTracker &#x3D; checkNotNull(jobManagerSharedServices.getBackPressureStatsTracker());</span><br><span class="line"></span><br><span class="line">		this.shuffleMaster &#x3D; checkNotNull(shuffleMaster);</span><br><span class="line"></span><br><span class="line">		this.jobManagerJobMetricGroup &#x3D; jobMetricGroupFactory.create(jobGraph);</span><br><span class="line">		&#x2F;&#x2F;创建flink job的调度类，通过DefaultSchedulerFactory工厂类的createInstance创建实例</span><br><span class="line">		this.schedulerNG &#x3D; createScheduler(jobManagerJobMetricGroup);</span><br><span class="line">		this.jobStatusListener &#x3D; null;</span><br><span class="line"></span><br><span class="line">		this.resourceManagerConnection &#x3D; null;</span><br><span class="line">		this.establishedResourceManagerConnection &#x3D; null;</span><br><span class="line"></span><br><span class="line">		this.accumulators &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">		this.taskManagerHeartbeatManager &#x3D; NoOpHeartbeatManager.getInstance();</span><br><span class="line">		this.resourceManagerHeartbeatManager &#x3D; NoOpHeartbeatManager.getInstance();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>schedulerNG用于调度提交的job，管理调度策略，slot分配策略，生成ExecutionGraph，根据savapoint及checkpoint启动等。</p>
<p>创建好JobManagerRunner之后，回到Dispatcher的runJob方法，调用startJobManagerRunner启动JobManager。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private JobManagerRunner startJobManagerRunner(JobManagerRunner jobManagerRunner) throws Exception &#123;</span><br><span class="line">   final JobID jobId &#x3D; jobManagerRunner.getJobID();</span><br><span class="line"></span><br><span class="line">   FutureUtils.assertNoException(</span><br><span class="line">      jobManagerRunner.getResultFuture().handleAsync(</span><br><span class="line">         (ArchivedExecutionGraph archivedExecutionGraph, Throwable throwable) -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we are still the active JobManagerRunner by checking the identity</span><br><span class="line">            final JobManagerRunner currentJobManagerRunner &#x3D; Optional.ofNullable(jobManagerRunnerFutures.get(jobId))</span><br><span class="line">               .map(future -&gt; future.getNow(null))</span><br><span class="line">               .orElse(null);</span><br><span class="line">            &#x2F;&#x2F;noinspection ObjectEquality</span><br><span class="line">            if (jobManagerRunner &#x3D;&#x3D; currentJobManagerRunner) &#123;</span><br><span class="line">               if (archivedExecutionGraph !&#x3D; null) &#123;</span><br><span class="line">                  jobReachedGloballyTerminalState(archivedExecutionGraph);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                  final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                  if (strippedThrowable instanceof JobNotFinishedException) &#123;</span><br><span class="line">                     jobNotFinished(jobId);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                     jobMasterFailed(jobId, strippedThrowable);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               log.debug(&quot;There is a newer JobManagerRunner for the job &#123;&#125;.&quot;, jobId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">         &#125;, getMainThreadExecutor()));</span><br><span class="line">&#x2F;&#x2F;启动jobManager</span><br><span class="line">   jobManagerRunner.start();</span><br><span class="line"></span><br><span class="line">   return jobManagerRunner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobManagerRunnerImpl类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;选举leader节点</span><br><span class="line">      leaderElectionService.start(this);</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      log.error(&quot;Could not start the JobManager because the leader election service did not start.&quot;, e);</span><br><span class="line">      throw new Exception(&quot;Could not start the leader election service.&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功回调JobManagerRunnerImpl类的grantLeadership回调方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void grantLeadership(final UUID leaderSessionID) &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         log.info(&quot;JobManagerRunner already shutdown.&quot;);</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      leadershipOperation &#x3D; leadershipOperation.thenCompose(</span><br><span class="line">         (ignored) -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">               return verifyJobSchedulingStatusAndStartJobManager(leaderSessionID);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">      handleException(leadershipOperation, &quot;Could not start the job manager.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private CompletableFuture&lt;Void&gt; verifyJobSchedulingStatusAndStartJobManager(UUID leaderSessionId) &#123;</span><br><span class="line">		final CompletableFuture&lt;JobSchedulingStatus&gt; jobSchedulingStatusFuture &#x3D; getJobSchedulingStatus();</span><br><span class="line"></span><br><span class="line">		return jobSchedulingStatusFuture.thenCompose(</span><br><span class="line">			jobSchedulingStatus -&gt; &#123;</span><br><span class="line">				if (jobSchedulingStatus &#x3D;&#x3D; JobSchedulingStatus.DONE) &#123;</span><br><span class="line">					return jobAlreadyDone();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F;启动startJobMaster</span><br><span class="line">					return startJobMaster(leaderSessionId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功启动startJobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private CompletionStage&lt;Void&gt; startJobMaster(UUID leaderSessionId) &#123;</span><br><span class="line">   log.info(&quot;JobManager runner for job &#123;&#125; (&#123;&#125;) was granted leadership with session id &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">      jobGraph.getName(), jobGraph.getJobID(), leaderSessionId, jobMasterService.getAddress());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      runningJobsRegistry.setJobRunning(jobGraph.getJobID());</span><br><span class="line">   &#125; catch (IOException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(</span><br><span class="line">         new FlinkException(</span><br><span class="line">            String.format(&quot;Failed to set the job %s to running in the running jobs registry.&quot;, jobGraph.getJobID()),</span><br><span class="line">            e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; startFuture;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;使用leaderSessionId构建 JobMasterId 启动 JobMaster</span><br><span class="line">      startFuture &#x3D; jobMasterService.start(new JobMasterId(leaderSessionId));</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new FlinkException(&quot;Failed to start the JobMaster.&quot;, e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;JobMasterGateway&gt; currentLeaderGatewayFuture &#x3D; leaderGatewayFuture;</span><br><span class="line">   return startFuture.thenAcceptAsync(</span><br><span class="line">      (Acknowledge ack) -&gt; confirmLeaderSessionIdIfStillLeader(</span><br><span class="line">         leaderSessionId,</span><br><span class="line">         jobMasterService.getAddress(),</span><br><span class="line">         currentLeaderGatewayFuture),</span><br><span class="line">      executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入JobMaster类start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; start(final JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; make sure we receive RPC and async calls</span><br><span class="line">   &#x2F;&#x2F;启动RpcServer</span><br><span class="line">   start();</span><br><span class="line"></span><br><span class="line">   return callAsyncWithoutFencing(() -&gt; startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   validateRunsInMainThread();</span><br><span class="line"></span><br><span class="line">   checkNotNull(newJobMasterId, &quot;The new JobMasterId must not be null.&quot;);</span><br><span class="line"></span><br><span class="line">   if (Objects.equals(getFencingToken(), newJobMasterId)) &#123;</span><br><span class="line">      log.info(&quot;Already started the job execution with JobMasterId &#123;&#125;.&quot;, newJobMasterId);</span><br><span class="line"></span><br><span class="line">      return Acknowledge.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setNewFencingToken(newJobMasterId);</span><br><span class="line"></span><br><span class="line">   startJobMasterServices();</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Starting execution of job &#123;&#125; (&#123;&#125;) under job master id &#123;&#125;.&quot;, jobGraph.getName(), jobGraph.getJobID(), newJobMasterId);</span><br><span class="line"></span><br><span class="line">   resetAndStartScheduler();</span><br><span class="line"></span><br><span class="line">   return Acknowledge.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JobMaster</code> 启动后会和 <code>ResourceManager</code> 建立连接，连接被封装为 <code>ResourceManagerConnection</code>。一旦连接建立之后，<code>JobMaster</code> 就可以通过 RPC 调用和 <code>ResourceManager</code> 进行通信了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void startJobMasterServices() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;启动心跳服务</span><br><span class="line">   startHeartbeatServices();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; start the slot pool make sure the slot pool now accepts messages for this leader</span><br><span class="line">   &#x2F;&#x2F;启动slotPool及scheduler</span><br><span class="line">   slotPool.start(getFencingToken(), getAddress(), getMainThreadExecutor());</span><br><span class="line">   scheduler.start(getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;TODO: Remove once the ZooKeeperLeaderRetrieval returns the stored address upon start</span><br><span class="line">   &#x2F;&#x2F; try to reconnect to previously known leader</span><br><span class="line">   reconnectToResourceManager(new FlinkException(&quot;Starting JobMaster component.&quot;));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; job is ready to go, try to establish connection with resource manager</span><br><span class="line">   &#x2F;&#x2F;   - activate leader retrieval for the resource manager</span><br><span class="line">   &#x2F;&#x2F;   - on notification of the leader, the connection will be established and</span><br><span class="line">   &#x2F;&#x2F;     the slot pool will start requesting slots</span><br><span class="line">   &#x2F;&#x2F;如果previously known leader连接失败，则等待ResourceManagerLeader选举，然后调用reconnectToResourceManager</span><br><span class="line">   resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用connectToResourceManager将连接封装为ResourceManagerConnection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void connectToResourceManager() &#123;</span><br><span class="line">   assert(resourceManagerAddress !&#x3D; null);</span><br><span class="line">   assert(resourceManagerConnection &#x3D;&#x3D; null);</span><br><span class="line">   assert(establishedResourceManagerConnection &#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Connecting to ResourceManager &#123;&#125;&quot;, resourceManagerAddress);</span><br><span class="line"></span><br><span class="line">   resourceManagerConnection &#x3D; new ResourceManagerConnection(</span><br><span class="line">      log,</span><br><span class="line">      jobGraph.getJobID(),</span><br><span class="line">      resourceId,</span><br><span class="line">      getAddress(),</span><br><span class="line">      getFencingToken(),</span><br><span class="line">      resourceManagerAddress.getAddress(),</span><br><span class="line">      resourceManagerAddress.getResourceManagerId(),</span><br><span class="line">      scheduledExecutorService);</span><br><span class="line"></span><br><span class="line">   resourceManagerConnection.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resourceManagerConnection启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">   checkState(!closed, &quot;The RPC connection is already closed&quot;);</span><br><span class="line">   checkState(!isConnected() &amp;&amp; pendingRegistration &#x3D;&#x3D; null, &quot;The RPC connection is already started&quot;);</span><br><span class="line"></span><br><span class="line">   final RetryingRegistration&lt;F, G, S&gt; newRegistration &#x3D; createNewRegistration();</span><br><span class="line"></span><br><span class="line">   if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">      newRegistration.startRegistration();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; concurrent start operation</span><br><span class="line">      newRegistration.cancel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createNewRegistration创建与ResourceManager的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private RetryingRegistration&lt;F, G, S&gt; createNewRegistration() &#123;</span><br><span class="line">   RetryingRegistration&lt;F, G, S&gt; newRegistration &#x3D; checkNotNull(generateRegistration());</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;Tuple2&lt;G, S&gt;&gt; future &#x3D; newRegistration.getFuture();</span><br><span class="line"></span><br><span class="line">   future.whenCompleteAsync(</span><br><span class="line">      (Tuple2&lt;G, S&gt; result, Throwable failure) -&gt; &#123;</span><br><span class="line">         if (failure !&#x3D; null) &#123;</span><br><span class="line">            if (failure instanceof CancellationException) &#123;</span><br><span class="line">               &#x2F;&#x2F; we ignore cancellation exceptions because they originate from cancelling</span><br><span class="line">               &#x2F;&#x2F; the RetryingRegistration</span><br><span class="line">               log.debug(&quot;Retrying registration towards &#123;&#125; was cancelled.&quot;, targetAddress);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; this future should only ever fail if there is a bug, not if the registration is declined</span><br><span class="line">               onRegistrationFailure(failure);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            targetGateway &#x3D; result.f0;</span><br><span class="line">            onRegistrationSuccess(result.f1);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, executor);</span><br><span class="line"></span><br><span class="line">   return newRegistration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功后回调onRegistrationSuccess建立连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void onRegistrationSuccess(final JobMasterRegistrationSuccess success) &#123;</span><br><span class="line">   runAsync(() -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; filter out outdated connections</span><br><span class="line">      &#x2F;&#x2F;noinspection ObjectEquality</span><br><span class="line">      if (this &#x3D;&#x3D; resourceManagerConnection) &#123;</span><br><span class="line">         establishResourceManagerConnection(success);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立的连接封装为EstablishedResourceManagerConnection类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void establishResourceManagerConnection(final JobMasterRegistrationSuccess success) &#123;</span><br><span class="line">   final ResourceManagerId resourceManagerId &#x3D; success.getResourceManagerId();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; verify the response with current connection</span><br><span class="line">   if (resourceManagerConnection !&#x3D; null</span><br><span class="line">         &amp;&amp; Objects.equals(resourceManagerConnection.getTargetLeaderId(), resourceManagerId)) &#123;</span><br><span class="line"></span><br><span class="line">      log.info(&quot;JobManager successfully registered at ResourceManager, leader id: &#123;&#125;.&quot;, resourceManagerId);</span><br><span class="line"></span><br><span class="line">      final ResourceManagerGateway resourceManagerGateway &#x3D; resourceManagerConnection.getTargetGateway();</span><br><span class="line"></span><br><span class="line">      final ResourceID resourceManagerResourceId &#x3D; success.getResourceManagerResourceId();</span><br><span class="line"></span><br><span class="line">      establishedResourceManagerConnection &#x3D; new EstablishedResourceManagerConnection(</span><br><span class="line">         resourceManagerGateway,</span><br><span class="line">         resourceManagerResourceId);</span><br><span class="line"></span><br><span class="line">      slotPool.connectToResourceManager(resourceManagerGateway);</span><br><span class="line"></span><br><span class="line">      resourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget&lt;Void&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void receiveHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">            resourceManagerGateway.heartbeatFromJobManager(resourceID);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void requestHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">            &#x2F;&#x2F; request heartbeat will never be called on the job manager side</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      log.debug(&quot;Ignoring resource manager connection to &#123;&#125; because it&#39;s duplicated or outdated.&quot;, resourceManagerId);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好newRegistration之后启动，newRegistration.startRegistration()向ResourceManager注册JobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void startRegistration() &#123;</span><br><span class="line">   if (canceled) &#123;</span><br><span class="line">      &#x2F;&#x2F; we already got canceled</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; trigger resolution of the target address to a callable gateway</span><br><span class="line">      final CompletableFuture&lt;G&gt; rpcGatewayFuture;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取ResourceManagerGateway地址</span><br><span class="line">      if (FencedRpcGateway.class.isAssignableFrom(targetType)) &#123;</span><br><span class="line">         rpcGatewayFuture &#x3D; (CompletableFuture&lt;G&gt;) rpcService.connect(</span><br><span class="line">            targetAddress,</span><br><span class="line">            fencingToken,</span><br><span class="line">            targetType.asSubclass(FencedRpcGateway.class));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         rpcGatewayFuture &#x3D; rpcService.connect(targetAddress, targetType);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; upon success, start the registration attempts</span><br><span class="line">      &#x2F;&#x2F;获取ResourceManagerGateway成功之后向ResourceManager注册</span><br><span class="line">      CompletableFuture&lt;Void&gt; rpcGatewayAcceptFuture &#x3D; rpcGatewayFuture.thenAcceptAsync(</span><br><span class="line">         (G rpcGateway) -&gt; &#123;</span><br><span class="line">            log.info(&quot;Resolved &#123;&#125; address, beginning registration&quot;, targetName);</span><br><span class="line">            register(rpcGateway, 1, retryingRegistrationConfiguration.getInitialRegistrationTimeoutMillis());</span><br><span class="line">         &#125;,</span><br><span class="line">         rpcService.getExecutor());</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void register(final G gateway, final int attempt, final long timeoutMillis) &#123;</span><br><span class="line">   &#x2F;&#x2F; eager check for canceling to avoid some unnecessary work</span><br><span class="line">   if (canceled) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      log.info(&quot;Registration at &#123;&#125; attempt &#123;&#125; (timeout&#x3D;&#123;&#125;ms)&quot;, targetName, attempt, timeoutMillis);</span><br><span class="line">      &#x2F;&#x2F;开始注册</span><br><span class="line">      CompletableFuture&lt;RegistrationResponse&gt; registrationFuture &#x3D; invokeRegistration(gateway, fencingToken, timeoutMillis);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; if the registration was successful, let the TaskExecutor know</span><br><span class="line">      CompletableFuture&lt;Void&gt; registrationAcceptFuture &#x3D; registrationFuture.thenAcceptAsync(</span><br><span class="line">         (RegistrationResponse result) -&gt; &#123;</span><br><span class="line">            if (!isCanceled()) &#123;</span><br><span class="line">               if (result instanceof RegistrationResponse.Success) &#123;</span><br><span class="line">                  &#x2F;&#x2F; registration successful!</span><br><span class="line">                  S success &#x3D; (S) result;</span><br><span class="line">                  completionFuture.complete(Tuple2.of(gateway, success));</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                  &#x2F;&#x2F; registration refused or unknown</span><br><span class="line">                  if (result instanceof RegistrationResponse.Decline) &#123;</span><br><span class="line">                     RegistrationResponse.Decline decline &#x3D; (RegistrationResponse.Decline) result;</span><br><span class="line">                     log.info(&quot;Registration at &#123;&#125; was declined: &#123;&#125;&quot;, targetName, decline.getReason());</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                     log.error(&quot;Received unknown response to registration attempt: &#123;&#125;&quot;, result);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  log.info(&quot;Pausing and re-attempting registration in &#123;&#125; ms&quot;, retryingRegistrationConfiguration.getRefusedDelayMillis());</span><br><span class="line">                  registerLater(gateway, 1, retryingRegistrationConfiguration.getInitialRegistrationTimeoutMillis(), retryingRegistrationConfiguration.getRefusedDelayMillis());</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         rpcService.getExecutor());</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobMaster的invokeRegistration，调用ResourceManagerGateway的注册方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</span><br><span class="line">            ResourceManagerGateway gateway, ResourceManagerId fencingToken, long timeoutMillis) &#123;</span><br><span class="line">         Time timeout &#x3D; Time.milliseconds(timeoutMillis);</span><br><span class="line"></span><br><span class="line">         return gateway.registerJobManager(</span><br><span class="line">            jobMasterId,</span><br><span class="line">            jobManagerResourceID,</span><br><span class="line">            jobManagerRpcAddress,</span><br><span class="line">            jobID,</span><br><span class="line">            timeout);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceManager注册JobManager的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;RegistrationResponse&gt; registerJobManager(</span><br><span class="line">      final JobMasterId jobMasterId,</span><br><span class="line">      final ResourceID jobManagerResourceId,</span><br><span class="line">      final String jobManagerAddress,</span><br><span class="line">      final JobID jobId,</span><br><span class="line">      final Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   checkNotNull(jobMasterId);</span><br><span class="line">   checkNotNull(jobManagerResourceId);</span><br><span class="line">   checkNotNull(jobManagerAddress);</span><br><span class="line">   checkNotNull(jobId);</span><br><span class="line"></span><br><span class="line">   if (!jobLeaderIdService.containsJob(jobId)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         jobLeaderIdService.addJob(jobId);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         ResourceManagerException exception &#x3D; new ResourceManagerException(&quot;Could not add the job &quot; +</span><br><span class="line">            jobId + &quot; to the job id leader service.&quot;, e);</span><br><span class="line"></span><br><span class="line">            onFatalError(exception);</span><br><span class="line"></span><br><span class="line">         log.error(&quot;Could not add job &#123;&#125; to job leader id service.&quot;, jobId, e);</span><br><span class="line">         return FutureUtils.completedExceptionally(exception);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Registering job manager &#123;&#125;@&#123;&#125; for job &#123;&#125;.&quot;, jobMasterId, jobManagerAddress, jobId);</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;JobMasterId&gt; jobMasterIdFuture;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      jobMasterIdFuture &#x3D; jobLeaderIdService.getLeaderId(jobId);</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      &#x2F;&#x2F; we cannot check the job leader id so let&#39;s fail</span><br><span class="line">      &#x2F;&#x2F; TODO: Maybe it&#39;s also ok to skip this check in case that we cannot check the leader id</span><br><span class="line">      ResourceManagerException exception &#x3D; new ResourceManagerException(&quot;Cannot obtain the &quot; +</span><br><span class="line">         &quot;job leader id future to verify the correct job leader.&quot;, e);</span><br><span class="line"></span><br><span class="line">         onFatalError(exception);</span><br><span class="line"></span><br><span class="line">      log.debug(&quot;Could not obtain the job leader id future to verify the correct job leader.&quot;);</span><br><span class="line">      return FutureUtils.completedExceptionally(exception);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;JobMasterGateway&gt; jobMasterGatewayFuture &#x3D; getRpcService().connect(jobManagerAddress, jobMasterId, JobMasterGateway.class);</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;RegistrationResponse&gt; registrationResponseFuture &#x3D; jobMasterGatewayFuture.thenCombineAsync(</span><br><span class="line">      jobMasterIdFuture,</span><br><span class="line">      (JobMasterGateway jobMasterGateway, JobMasterId leadingJobMasterId) -&gt; &#123;</span><br><span class="line">         if (Objects.equals(leadingJobMasterId, jobMasterId)) &#123;</span><br><span class="line">            return registerJobMasterInternal(</span><br><span class="line">               jobMasterGateway,</span><br><span class="line">               jobId,</span><br><span class="line">               jobManagerAddress,</span><br><span class="line">               jobManagerResourceId);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            final String declineMessage &#x3D; String.format(</span><br><span class="line">               &quot;The leading JobMaster id %s did not match the received JobMaster id %s. &quot; +</span><br><span class="line">               &quot;This indicates that a JobMaster leader change has happened.&quot;,</span><br><span class="line">               leadingJobMasterId,</span><br><span class="line">               jobMasterId);</span><br><span class="line">            log.debug(declineMessage);</span><br><span class="line">            return new RegistrationResponse.Decline(declineMessage);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; handle exceptions which might have occurred in one of the futures inputs of combine</span><br><span class="line">   return registrationResponseFuture.handleAsync(</span><br><span class="line">      (RegistrationResponse registrationResponse, Throwable throwable) -&gt; &#123;</span><br><span class="line">         if (throwable !&#x3D; null) &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(&quot;Registration of job manager &#123;&#125;@&#123;&#125; failed.&quot;, jobMasterId, jobManagerAddress, throwable);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               log.info(&quot;Registration of job manager &#123;&#125;@&#123;&#125; failed.&quot;, jobMasterId, jobManagerAddress);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return new RegistrationResponse.Decline(throwable.getMessage());</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            return registrationResponse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      getRpcService().getExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private RegistrationResponse registerJobMasterInternal(</span><br><span class="line">   final JobMasterGateway jobMasterGateway,</span><br><span class="line">   JobID jobId,</span><br><span class="line">   String jobManagerAddress,</span><br><span class="line">   ResourceID jobManagerResourceId) &#123;</span><br><span class="line">   if (jobManagerRegistrations.containsKey(jobId)) &#123;</span><br><span class="line">      JobManagerRegistration oldJobManagerRegistration &#x3D; jobManagerRegistrations.get(jobId);</span><br><span class="line"></span><br><span class="line">      if (Objects.equals(oldJobManagerRegistration.getJobMasterId(), jobMasterGateway.getFencingToken())) &#123;</span><br><span class="line">         &#x2F;&#x2F; same registration</span><br><span class="line">         log.debug(&quot;Job manager &#123;&#125;@&#123;&#125; was already registered.&quot;, jobMasterGateway.getFencingToken(), jobManagerAddress);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; tell old job manager that he is no longer the job leader</span><br><span class="line">         disconnectJobManager(</span><br><span class="line">            oldJobManagerRegistration.getJobID(),</span><br><span class="line">            new Exception(&quot;New job leader for job &quot; + jobId + &quot; found.&quot;));</span><br><span class="line"></span><br><span class="line">         JobManagerRegistration jobManagerRegistration &#x3D; new JobManagerRegistration(</span><br><span class="line">            jobId,</span><br><span class="line">            jobManagerResourceId,</span><br><span class="line">            jobMasterGateway);</span><br><span class="line">         jobManagerRegistrations.put(jobId, jobManagerRegistration);</span><br><span class="line">         jmResourceIdRegistrations.put(jobManagerResourceId, jobManagerRegistration);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; new registration for the job</span><br><span class="line">      JobManagerRegistration jobManagerRegistration &#x3D; new JobManagerRegistration(</span><br><span class="line">         jobId,</span><br><span class="line">         jobManagerResourceId,</span><br><span class="line">         jobMasterGateway);</span><br><span class="line">      jobManagerRegistrations.put(jobId, jobManagerRegistration);</span><br><span class="line">      jmResourceIdRegistrations.put(jobManagerResourceId, jobManagerRegistration);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Registered job manager &#123;&#125;@&#123;&#125; for job &#123;&#125;.&quot;, jobMasterGateway.getFencingToken(), jobManagerAddress, jobId);</span><br><span class="line"></span><br><span class="line">   jobManagerHeartbeatManager.monitorTarget(jobManagerResourceId, new HeartbeatTarget&lt;Void&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void receiveHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">         &#x2F;&#x2F; the ResourceManager will always send heartbeat requests to the JobManager</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void requestHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">         jobMasterGateway.heartbeatFromResourceManager(resourceID);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   return new JobMasterRegistrationSuccess(</span><br><span class="line">      getFencingToken(),</span><br><span class="line">      resourceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成JobManagerRegistration，之后就可以和ResourceManager通信了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/TaskManager%E4%B8%8EJobManager%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/22/TaskManager%E4%B8%8EJobManager%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/" itemprop="url">TaskManager与JobManager建立连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-22T14:55:15+08:00">
                2020-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>回顾之前的流程，TaskExecutor启动成功之后会调用回调函数onStart，建立一系列连接。其中JobLeaderListenerImp 监听JobManager的启动和leader选举，完成之后回调JobLeaderService的onRegistrationSuccess回调函数。onRegistrationSuccess调用JobLeaderListener的jobManagerGainedLeadership回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStart() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      startTaskExecutorServices();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      final TaskManagerException exception &#x3D; new TaskManagerException(String.format(&quot;Could not start the TaskExecutor %s&quot;, getAddress()), e);</span><br><span class="line">      onFatalError(exception);</span><br><span class="line">      throw exception;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   startRegistrationTimeout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void startTaskExecutorServices() throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; start by connecting to the ResourceManager</span><br><span class="line">			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; tell the task slot table who&#39;s responsible for the task slot actions</span><br><span class="line">			taskSlotTable.start(new SlotActionsImpl(), getMainThreadExecutor());</span><br><span class="line">	</span><br><span class="line">			&#x2F;&#x2F; start the job leader service</span><br><span class="line">			jobLeaderService.start(getAddress(), getRpcService(), haServices, new JobLeaderListenerImpl());</span><br><span class="line">	</span><br><span class="line">			fileCache &#x3D; new FileCache(taskManagerConfiguration.getTmpDirectories(), blobCacheService.getPermanentBlobService());</span><br><span class="line"> 	&#125; catch (Exception e) &#123;</span><br><span class="line">			handleStartTaskExecutorServicesException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>除了TaskExecutor启动的时候建立连接，在有新的job申请slot资源的时候也会建立连接。回顾slot资源管理的过程，在TaskExecutor的requestSlot中会注册新的job，通过JobLeaderService的addJob，由highAvailabilityServices选取该job的JobManager的Leader节点，并启动JobManagerLeaderListener主节点的监听JobManagerLeaderListener。选取成功会回调JobManagerLeaderListener的notifyLeaderAddress函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void notifyLeaderAddress(final @Nullable String leaderAddress, final @Nullable UUID leaderId) &#123;</span><br><span class="line">   if (stopped) &#123;</span><br><span class="line">      LOG.debug(&quot;&#123;&#125;&#39;s leader retrieval listener reported a new leader for job &#123;&#125;. &quot; +</span><br><span class="line">         &quot;However, the service is no longer running.&quot;, JobLeaderService.class.getSimpleName(), jobId);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final JobMasterId jobMasterId &#x3D; JobMasterId.fromUuidOrNull(leaderId);</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;New leader information for job &#123;&#125;. Address: &#123;&#125;, leader id: &#123;&#125;.&quot;,</span><br><span class="line">         jobId, leaderAddress, jobMasterId);</span><br><span class="line"></span><br><span class="line">      if (leaderAddress &#x3D;&#x3D; null || leaderAddress.isEmpty()) &#123;</span><br><span class="line">         &#x2F;&#x2F; the leader lost leadership but there is no other leader yet.</span><br><span class="line">         if (rpcConnection !&#x3D; null) &#123;</span><br><span class="line">            rpcConnection.close();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         jobLeaderListener.jobManagerLostLeadership(jobId, currentJobMasterId);</span><br><span class="line"></span><br><span class="line">         currentJobMasterId &#x3D; jobMasterId;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         currentJobMasterId &#x3D; jobMasterId;</span><br><span class="line"></span><br><span class="line">         if (rpcConnection !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we are already trying to connect to this leader</span><br><span class="line">            if (!Objects.equals(jobMasterId, rpcConnection.getTargetLeaderId())) &#123;</span><br><span class="line">               rpcConnection.close();</span><br><span class="line"></span><br><span class="line">               rpcConnection &#x3D; new JobManagerRegisteredRpcConnection(</span><br><span class="line">                  LOG,</span><br><span class="line">                  leaderAddress,</span><br><span class="line">                  jobMasterId,</span><br><span class="line">                  rpcService.getExecutor());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            rpcConnection &#x3D; new JobManagerRegisteredRpcConnection(</span><br><span class="line">               LOG,</span><br><span class="line">               leaderAddress,</span><br><span class="line">               jobMasterId,</span><br><span class="line">               rpcService.getExecutor());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; double check for a concurrent stop operation</span><br><span class="line">         if (stopped) &#123;</span><br><span class="line">            rpcConnection.close();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.info(&quot;Try to register at job manager &#123;&#125; with leader id &#123;&#125;.&quot;, leaderAddress, leaderId);</span><br><span class="line">            rpcConnection.start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notifyLeaderAddress会初始化JobManagerRegisteredRpcConnection，即JobManager主节点与TaskExecutor的连接类。连接成功会调用onRegistrationSuccess回调方法，同样会调用jobManagerGainedLeadership回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private final class JobManagerRegisteredRpcConnection extends RegisteredRpcConnection&lt;JobMasterId, JobMasterGateway, JMTMRegistrationSuccess&gt; &#123;</span><br><span class="line"></span><br><span class="line">      JobManagerRegisteredRpcConnection(</span><br><span class="line">            Logger log,</span><br><span class="line">            String targetAddress,</span><br><span class="line">            JobMasterId jobMasterId,</span><br><span class="line">            Executor executor) &#123;</span><br><span class="line">         super(log, targetAddress, jobMasterId, executor);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected RetryingRegistration&lt;JobMasterId, JobMasterGateway, JMTMRegistrationSuccess&gt; generateRegistration() &#123;</span><br><span class="line">         return new JobLeaderService.JobManagerRetryingRegistration(</span><br><span class="line">               LOG,</span><br><span class="line">               rpcService,</span><br><span class="line">               &quot;JobManager&quot;,</span><br><span class="line">               JobMasterGateway.class,</span><br><span class="line">               getTargetAddress(),</span><br><span class="line">               getTargetLeaderId(),</span><br><span class="line">               retryingRegistrationConfiguration,</span><br><span class="line">               ownerAddress,</span><br><span class="line">               ownLocation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected void onRegistrationSuccess(JMTMRegistrationSuccess success) &#123;</span><br><span class="line">         &#x2F;&#x2F; filter out old registration attempts</span><br><span class="line">         if (Objects.equals(getTargetLeaderId(), currentJobMasterId)) &#123;</span><br><span class="line">            log.info(&quot;Successful registration at job manager &#123;&#125; for job &#123;&#125;.&quot;, getTargetAddress(), jobId);</span><br><span class="line"></span><br><span class="line">            jobLeaderListener.jobManagerGainedLeadership(jobId, getTargetGateway(), success);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Encountered obsolete JobManager registration success from &#123;&#125; with leader session ID &#123;&#125;.&quot;, getTargetAddress(), getTargetLeaderId());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected void onRegistrationFailure(Throwable failure) &#123;</span><br><span class="line">         &#x2F;&#x2F; filter out old registration attempts</span><br><span class="line">         if (Objects.equals(getTargetLeaderId(), currentJobMasterId)) &#123;</span><br><span class="line">            log.info(&quot;Failed to register at job  manager &#123;&#125; for job &#123;&#125;.&quot;, getTargetAddress(), jobId);</span><br><span class="line">            jobLeaderListener.handleError(failure);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Obsolete JobManager registration failure from &#123;&#125; with leader session ID &#123;&#125;.&quot;, getTargetAddress(), getTargetLeaderId(), failure);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobLeaderListenerImpl类及jobManagerLostLeadership回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class JobLeaderListenerImpl implements JobLeaderListener &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void jobManagerGainedLeadership(</span><br><span class="line">		final JobID jobId,</span><br><span class="line">		final JobMasterGateway jobManagerGateway,</span><br><span class="line">		final JMTMRegistrationSuccess registrationMessage) &#123;</span><br><span class="line">		runAsync(</span><br><span class="line">			() -&gt;</span><br><span class="line">			&#x2F;&#x2F;与JobManager的leader节点建立连接</span><br><span class="line">				establishJobManagerConnection(</span><br><span class="line">					jobId,</span><br><span class="line">					jobManagerGateway,</span><br><span class="line">					registrationMessage));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void jobManagerLostLeadership(final JobID jobId, final JobMasterId jobMasterId) &#123;</span><br><span class="line">		log.info(&quot;JobManager for job &#123;&#125; with leader id &#123;&#125; lost leadership.&quot;, jobId, jobMasterId);</span><br><span class="line">	</span><br><span class="line">		runAsync(() -&gt;</span><br><span class="line">			closeJobManagerConnection(</span><br><span class="line">				jobId,</span><br><span class="line">				new Exception(&quot;Job leader for job id &quot; + jobId + &quot; lost leadership.&quot;)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void handleError(Throwable throwable) &#123;</span><br><span class="line">		onFatalError(throwable);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jobManagerGainedLeadership函数再调用TaskExecutor的establishJobManagerConnection函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) &#123;</span><br><span class="line"></span><br><span class="line">   if (jobManagerTable.contains(jobId)) &#123;</span><br><span class="line">      JobManagerConnection oldJobManagerConnection &#x3D; jobManagerTable.get(jobId);</span><br><span class="line"></span><br><span class="line">      if (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) &#123;</span><br><span class="line">         &#x2F;&#x2F; we already are connected to the given job manager</span><br><span class="line">         log.debug(&quot;Ignore JobManager gained leadership message for &#123;&#125; because we are already connected to it.&quot;, jobMasterGateway.getFencingToken());</span><br><span class="line">         return;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         closeJobManagerConnection(jobId, new Exception(&quot;Found new job leader for job id &quot; + jobId + &#39;.&#39;));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Establish JobManager connection for job &#123;&#125;.&quot;, jobId);</span><br><span class="line"></span><br><span class="line">   ResourceID jobManagerResourceID &#x3D; registrationSuccess.getResourceID();</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;初始化JobManagerConnection，用于存储TaskExecutor所需的JobManager的信息</span><br><span class="line">   JobManagerConnection newJobManagerConnection &#x3D; associateWithJobManager(</span><br><span class="line">         jobId,</span><br><span class="line">         jobManagerResourceID,</span><br><span class="line">         jobMasterGateway);</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F;将JobManagerConnection存入map</span><br><span class="line">   jobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);</span><br><span class="line">   jobManagerTable.put(jobId, newJobManagerConnection);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; monitor the job manager as heartbeat target</span><br><span class="line">   jobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget&lt;AccumulatorReport&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</span><br><span class="line">         jobMasterGateway.heartbeatFromTaskManager(resourceID, payload);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</span><br><span class="line">         &#x2F;&#x2F; request heartbeat will never be called on the task manager side</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向JobManager提供需要的slot资源，在TaskManager上报Slot资源的过程已经分析。</span><br><span class="line">   offerSlotsToJobManager(jobId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>associateWithJobManager方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private JobManagerConnection associateWithJobManager(</span><br><span class="line">      JobID jobID,</span><br><span class="line">      ResourceID resourceID,</span><br><span class="line">      JobMasterGateway jobMasterGateway) &#123;</span><br><span class="line">   checkNotNull(jobID);</span><br><span class="line">   checkNotNull(resourceID);</span><br><span class="line">   checkNotNull(jobMasterGateway);</span><br><span class="line"></span><br><span class="line">   TaskManagerActions taskManagerActions &#x3D; new TaskManagerActionsImpl(jobMasterGateway);</span><br><span class="line"></span><br><span class="line">   CheckpointResponder checkpointResponder &#x3D; new RpcCheckpointResponder(jobMasterGateway);</span><br><span class="line">   GlobalAggregateManager aggregateManager &#x3D; new RpcGlobalAggregateManager(jobMasterGateway);</span><br><span class="line"></span><br><span class="line">   final LibraryCacheManager libraryCacheManager &#x3D; new BlobLibraryCacheManager(</span><br><span class="line">      blobCacheService.getPermanentBlobService(),</span><br><span class="line">      taskManagerConfiguration.getClassLoaderResolveOrder(),</span><br><span class="line">      taskManagerConfiguration.getAlwaysParentFirstLoaderPatterns());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ResultPartition监听</span><br><span class="line">   ResultPartitionConsumableNotifier resultPartitionConsumableNotifier &#x3D; new RpcResultPartitionConsumableNotifier(</span><br><span class="line">      jobMasterGateway,</span><br><span class="line">      getRpcService().getExecutor(),</span><br><span class="line">      taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">   PartitionProducerStateChecker partitionStateChecker &#x3D; new RpcPartitionStateChecker(jobMasterGateway);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册可查询的State</span><br><span class="line">   registerQueryableState(jobID, jobMasterGateway);</span><br><span class="line"></span><br><span class="line">   return new JobManagerConnection(</span><br><span class="line">      jobID,</span><br><span class="line">      resourceID,</span><br><span class="line">      jobMasterGateway,</span><br><span class="line">      taskManagerActions,</span><br><span class="line">      checkpointResponder,</span><br><span class="line">      aggregateManager,</span><br><span class="line">      libraryCacheManager,</span><br><span class="line">      resultPartitionConsumableNotifier,</span><br><span class="line">      partitionStateChecker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobManagerConnection类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class JobManagerConnection &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Job id related with the job manager</span><br><span class="line">   private final JobID jobID;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The unique id used for identifying the job manager</span><br><span class="line">   private final ResourceID resourceID;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Gateway to the job master</span><br><span class="line">   private final JobMasterGateway jobMasterGateway;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Task manager actions with respect to the connected job manager</span><br><span class="line">   private final TaskManagerActions taskManagerActions;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Checkpoint responder for the specific job manager</span><br><span class="line">   private final CheckpointResponder checkpointResponder;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; GlobalAggregateManager interface to job manager</span><br><span class="line">   private final GlobalAggregateManager aggregateManager;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Library cache manager connected to the specific job manager</span><br><span class="line">   private final LibraryCacheManager libraryCacheManager;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Result partition consumable notifier for the specific job manager</span><br><span class="line">   private final ResultPartitionConsumableNotifier resultPartitionConsumableNotifier;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Partition state checker for the specific job manager</span><br><span class="line">   private final PartitionProducerStateChecker partitionStateChecker;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/Flink%E7%9A%84Slot%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/18/Flink%E7%9A%84Slot%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" itemprop="url">Flink的Slot资源管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T15:55:12+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2020/06/18/Flink%E7%9A%84Slot%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/1.png" alt></p>
<p>上图是TaskManager 上报slot资源的大致流程。</p>
<p>TaskManager 管理slot的逻辑在TaskExecutor类里面。Resoucemanager组件对所有TaskManager 的slot资源进行管理，因此TaskExecutor与Resoucemanager建立连接之后会报告slot的分配情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void establishResourceManagerConnection(</span><br><span class="line">			ResourceManagerGateway resourceManagerGateway,</span><br><span class="line">			ResourceID resourceManagerResourceId,</span><br><span class="line">			InstanceID taskExecutorRegistrationId,</span><br><span class="line">			ClusterInformation clusterInformation) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送slot报告</span><br><span class="line">		final CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture &#x3D; resourceManagerGateway.sendSlotReport(</span><br><span class="line">			getResourceID(),</span><br><span class="line">			taskExecutorRegistrationId,</span><br><span class="line">			taskSlotTable.createSlotReport(getResourceID()),</span><br><span class="line">			taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">		slotReportResponseFuture.whenCompleteAsync(</span><br><span class="line">			(acknowledge, throwable) -&gt; &#123;</span><br><span class="line">				if (throwable !&#x3D; null) &#123;</span><br><span class="line">					reconnectToResourceManager(new TaskManagerException(&quot;Failed to send initial slot report to ResourceManager.&quot;, throwable));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>TaskSlotTableImpl类的createSlotReport，收集该TaskManager 的slot资源情况，TaskSlotTableImpl类是TaskSlotTable实现类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public SlotReport createSlotReport(ResourceID resourceId) &#123;</span><br><span class="line">   List&lt;SlotStatus&gt; slotStatuses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; numberSlots; i++) &#123;</span><br><span class="line">      SlotID slotId &#x3D; new SlotID(resourceId, i);</span><br><span class="line">      SlotStatus slotStatus;</span><br><span class="line">      \\所有的taskSlots</span><br><span class="line">      if (taskSlots.containsKey(i)) &#123;</span><br><span class="line">         TaskSlot&lt;T&gt; taskSlot &#x3D; taskSlots.get(i);</span><br><span class="line"></span><br><span class="line">         slotStatus &#x3D; new SlotStatus(</span><br><span class="line">            slotId,</span><br><span class="line">            taskSlot.getResourceProfile(),</span><br><span class="line">            taskSlot.getJobId(),</span><br><span class="line">            taskSlot.getAllocationId());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      \\初始slot状态未分配id</span><br><span class="line">         slotStatus &#x3D; new SlotStatus(</span><br><span class="line">            slotId,</span><br><span class="line">            defaultSlotResourceProfile,</span><br><span class="line">            null,</span><br><span class="line">            null);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      slotStatuses.add(slotStatus);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">\\allocation slot id</span><br><span class="line">   for (TaskSlot&lt;T&gt; taskSlot : allocatedSlots.values()) &#123;</span><br><span class="line">      if (taskSlot.getIndex() &lt; 0) &#123;</span><br><span class="line">         SlotID slotID &#x3D; SlotID.generateDynamicSlotID(resourceId);</span><br><span class="line">         SlotStatus slotStatus &#x3D; new SlotStatus(</span><br><span class="line">            slotID,</span><br><span class="line">            taskSlot.getResourceProfile(),</span><br><span class="line">            taskSlot.getJobId(),</span><br><span class="line">            taskSlot.getAllocationId());</span><br><span class="line">         slotStatuses.add(slotStatus);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final SlotReport slotReport &#x3D; new SlotReport(slotStatuses);</span><br><span class="line"></span><br><span class="line">   return slotReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看一下TaskSlotTable的初始化，这个过程是在启动TaskManager的过程中。TaskManagerRunner类的startTaskManager方法启动TaskExecutor，同时初始化TaskManagerServices，初始化TaskManagerServices之前创建TaskSlotTable，做为TaskManagerServices的一个成员变量。createTaskSlotTable方法初始化TaskSlotTableImpl。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskManagerServices taskManagerServices &#x3D; TaskManagerServices.fromConfiguration(</span><br><span class="line">   taskManagerServicesConfiguration,</span><br><span class="line">   taskManagerMetricGroup.f1,</span><br><span class="line">   rpcService.getExecutor());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static TaskManagerServices fromConfiguration(</span><br><span class="line">      TaskManagerServicesConfiguration taskManagerServicesConfiguration,</span><br><span class="line">      MetricGroup taskManagerMetricGroup,</span><br><span class="line">      Executor taskIOExecutor) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">   final TaskSlotTable&lt;Task&gt; taskSlotTable &#x3D; createTaskSlotTable(</span><br><span class="line">      taskManagerServicesConfiguration.getNumberOfSlots(),</span><br><span class="line">      taskManagerServicesConfiguration.getTaskExecutorResourceSpec(),</span><br><span class="line">      taskManagerServicesConfiguration.getTimerServiceShutdownTimeout(),</span><br><span class="line">      taskManagerServicesConfiguration.getPageSize());</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  return new TaskManagerServices(..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static TaskSlotTable&lt;Task&gt; createTaskSlotTable(</span><br><span class="line">      final int numberOfSlots,</span><br><span class="line">      final TaskExecutorResourceSpec taskExecutorResourceSpec,</span><br><span class="line">      final long timerServiceShutdownTimeout,</span><br><span class="line">      final int pageSize) &#123;</span><br><span class="line">   final TimerService&lt;AllocationID&gt; timerService &#x3D; new TimerService&lt;&gt;(</span><br><span class="line">      new ScheduledThreadPoolExecutor(1),</span><br><span class="line">      timerServiceShutdownTimeout);</span><br><span class="line">   return new TaskSlotTableImpl&lt;&gt;(</span><br><span class="line">      numberOfSlots,</span><br><span class="line">      TaskExecutorResourceUtils.generateTotalAvailableResourceProfile(taskExecutorResourceSpec),</span><br><span class="line">      TaskExecutorResourceUtils.generateDefaultSlotResourceProfile(taskExecutorResourceSpec, numberOfSlots),</span><br><span class="line">      pageSize,</span><br><span class="line">      timerService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskSlotTable生成slot的报告之后向resourceManagerGateway发送slot资源信息，</p>
<p>ResourceManager类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; sendSlotReport(ResourceID taskManagerResourceId, InstanceID taskManagerRegistrationId, SlotReport slotReport, Time timeout) &#123;</span><br><span class="line">   final WorkerRegistration&lt;WorkerType&gt; workerTypeWorkerRegistration &#x3D; taskExecutors.get(taskManagerResourceId);</span><br><span class="line"></span><br><span class="line">   if (workerTypeWorkerRegistration.getInstanceID().equals(taskManagerRegistrationId)) &#123;</span><br><span class="line">      slotManager.registerTaskManager(workerTypeWorkerRegistration, slotReport);</span><br><span class="line">      return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new ResourceManagerException(String.format(&quot;Unknown TaskManager registration id %s.&quot;, taskManagerRegistrationId)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入SlotManagerImpl类,向SlotManager注册TaskManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we identify task managers by their instance id</span><br><span class="line">   &#x2F;&#x2F;已经注册的taskManager上报更新SlotStatus</span><br><span class="line">   if (taskManagerRegistrations.containsKey(taskExecutorConnection.getInstanceID())) &#123;</span><br><span class="line">      reportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F;第一次注册的TaskManager，新注册TaskManager和slot</span><br><span class="line">      &#x2F;&#x2F; first register the TaskManager</span><br><span class="line">      ArrayList&lt;SlotID&gt; reportedSlots &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      for (SlotStatus slotStatus : initialSlotReport) &#123;</span><br><span class="line">         reportedSlots.add(slotStatus.getSlotID());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TaskManagerRegistration taskManagerRegistration &#x3D; new TaskManagerRegistration(</span><br><span class="line">         taskExecutorConnection,</span><br><span class="line">         reportedSlots);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加新的taskManager的id</span><br><span class="line">      taskManagerRegistrations.put(taskExecutorConnection.getInstanceID(), taskManagerRegistration);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; next register the new slots</span><br><span class="line">      &#x2F;&#x2F;register新的slot</span><br><span class="line">      for (SlotStatus slotStatus : initialSlotReport) &#123;</span><br><span class="line">         registerSlot(</span><br><span class="line">            slotStatus.getSlotID(),</span><br><span class="line">            slotStatus.getAllocationID(),</span><br><span class="line">            slotStatus.getJobID(),</span><br><span class="line">            slotStatus.getResourceProfile(),</span><br><span class="line">            taskExecutorConnection);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SlotManagerImpl注册新的slot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private void registerSlot(</span><br><span class="line">      SlotID slotId,</span><br><span class="line">      AllocationID allocationId,</span><br><span class="line">      JobID jobId,</span><br><span class="line">      ResourceProfile resourceProfile,</span><br><span class="line">      TaskExecutorConnection taskManagerConnection) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除老的同名slot</span><br><span class="line">   if (slots.containsKey(slotId)) &#123;</span><br><span class="line">      &#x2F;&#x2F; remove the old slot first</span><br><span class="line">      removeSlot(</span><br><span class="line">         slotId,</span><br><span class="line">         new SlotManagerException(</span><br><span class="line">            String.format(</span><br><span class="line">               &quot;Re-registration of slot %s. This indicates that the TaskExecutor has re-connected.&quot;,</span><br><span class="line">               slotId)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化TaskManagerSlot类并将&lt;SlotId,TaskManagerSlot&gt;键值对存入slots</span><br><span class="line">   final TaskManagerSlot slot &#x3D; createAndRegisterTaskManagerSlot(slotId, resourceProfile, taskManagerConnection);</span><br><span class="line"></span><br><span class="line">   final PendingTaskManagerSlot pendingTaskManagerSlot;</span><br><span class="line"></span><br><span class="line">   if (allocationId &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;这个 slot 还没有被分配，则找到和当前 slot 的计算资源相匹配的 PendingTaskManagerSlot</span><br><span class="line">      pendingTaskManagerSlot &#x3D; findExactlyMatchingPendingTaskManagerSlot(resourceProfile);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F;这个 slot 已经被分配了</span><br><span class="line">      pendingTaskManagerSlot &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (pendingTaskManagerSlot &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;两种可能： 1）slot已经被分配了 2）没有匹配的 PendingTaskManagerSlot</span><br><span class="line">      updateSlot(slotId, allocationId, jobId);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F; 新注册的 slot 能够满足 PendingTaskManagerSlot 的要求</span><br><span class="line">      pendingSlots.remove(pendingTaskManagerSlot.getTaskManagerSlotId());</span><br><span class="line">      final PendingSlotRequest assignedPendingSlotRequest &#x3D; pendingTaskManagerSlot.getAssignedPendingSlotRequest();</span><br><span class="line">     &#x2F;&#x2F; PendingTaskManagerSlot 可能有关联的 PedningSlotRequest</span><br><span class="line">      if (assignedPendingSlotRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;没有关联的 PedningSlotRequest，则将 slot 是 Free 状态</span><br><span class="line">         handleFreeSlot(slot);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;有关联的 PedningSlotRequest，则这个 request 可以被满足，分配 slot</span><br><span class="line">         assignedPendingSlotRequest.unassignPendingTaskManagerSlot();</span><br><span class="line">         allocateSlot(slot, assignedPendingSlotRequest);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleFreeSlot方法先查找是否有能够满足的 PendingSlotRequest，如果没有将该TaskManagerSlot放入freeSlots列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void handleFreeSlot(TaskManagerSlot freeSlot) &#123;</span><br><span class="line">   Preconditions.checkState(freeSlot.getState() &#x3D;&#x3D; TaskManagerSlot.State.FREE);</span><br><span class="line"></span><br><span class="line">   PendingSlotRequest pendingSlotRequest &#x3D; findMatchingRequest(freeSlot.getResourceProfile());</span><br><span class="line"></span><br><span class="line">   if (null !&#x3D; pendingSlotRequest) &#123;</span><br><span class="line">      allocateSlot(freeSlot, pendingSlotRequest);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      freeSlots.put(freeSlot.getSlotId(), freeSlot);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SlotManagerImpl分配slot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) &#123;</span><br><span class="line">   Preconditions.checkState(taskManagerSlot.getState() &#x3D;&#x3D; TaskManagerSlot.State.FREE);</span><br><span class="line"></span><br><span class="line">   TaskExecutorConnection taskExecutorConnection &#x3D; taskManagerSlot.getTaskManagerConnection();</span><br><span class="line">   TaskExecutorGateway gateway &#x3D; taskExecutorConnection.getTaskExecutorGateway();</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; completableFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">   final AllocationID allocationId &#x3D; pendingSlotRequest.getAllocationId();</span><br><span class="line">   final SlotID slotId &#x3D; taskManagerSlot.getSlotId();</span><br><span class="line">   final InstanceID instanceID &#x3D; taskManagerSlot.getInstanceId();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;taskManagerSlot 状态变为 PENDING</span><br><span class="line">   taskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);</span><br><span class="line">   pendingSlotRequest.setRequestFuture(completableFuture);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果有 PendingTaskManager 指派给当前 pendingSlotRequest，要先解除关联</span><br><span class="line">   returnPendingTaskManagerSlotIfAssigned(pendingSlotRequest);</span><br><span class="line"></span><br><span class="line">   TaskManagerRegistration taskManagerRegistration &#x3D; taskManagerRegistrations.get(instanceID);</span><br><span class="line"></span><br><span class="line">   if (taskManagerRegistration &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Could not find a registered task manager for instance id &quot; +</span><br><span class="line">         instanceID + &#39;.&#39;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   taskManagerRegistration.markUsed();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; RPC call to the task manager</span><br><span class="line">   &#x2F;&#x2F; 通过 RPC 调用向 TaskExecutor 请求 slot</span><br><span class="line">   CompletableFuture&lt;Acknowledge&gt; requestFuture &#x3D; gateway.requestSlot(</span><br><span class="line">      slotId,</span><br><span class="line">      pendingSlotRequest.getJobId(),</span><br><span class="line">      allocationId,</span><br><span class="line">      pendingSlotRequest.getResourceProfile(),</span><br><span class="line">      pendingSlotRequest.getTargetAddress(),</span><br><span class="line">      resourceManagerId,</span><br><span class="line">      taskManagerRequestTimeout);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;RPC调用的请求完成</span><br><span class="line">   requestFuture.whenComplete(</span><br><span class="line">      (Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">         if (acknowledge !&#x3D; null) &#123;</span><br><span class="line">            completableFuture.complete(acknowledge);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            completableFuture.completeExceptionally(throwable);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PendingSlotRequest 请求完成的回调函数</span><br><span class="line">		&#x2F;&#x2F;PendingSlotRequest 请求完成可能是由于上面 RPC 调用完成，也可能是因为 PendingSlotRequest 被取消</span><br><span class="line">   completableFuture.whenCompleteAsync(</span><br><span class="line">      (Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            if (acknowledge !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果请求成功，则取消 pendingSlotRequest，并更新 slot 状态 PENDING -&gt; ALLOCATED</span><br><span class="line">               updateSlot(slotId, allocationId, pendingSlotRequest.getJobId());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               if (throwable instanceof SlotOccupiedException) &#123;</span><br><span class="line">               &#x2F;&#x2F;这个 slot 已经被占用了，更新状态</span><br><span class="line">                  SlotOccupiedException exception &#x3D; (SlotOccupiedException) throwable;</span><br><span class="line">                  updateSlot(slotId, exception.getAllocationId(), exception.getJobId());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F;请求失败，将 pendingSlotRequest 从 TaskManagerSlot 中移除</span><br><span class="line">                  removeSlotRequestFromSlot(slotId, allocationId);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!(throwable instanceof CancellationException)) &#123;</span><br><span class="line">               &#x2F;&#x2F;slot request 请求失败，会进行重试</span><br><span class="line">                  handleFailedSlotRequest(slotId, allocationId, throwable);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F;主动取消</span><br><span class="line">                  LOG.debug(&quot;Slot allocation request &#123;&#125; has been cancelled.&quot;, allocationId, throwable);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            LOG.error(&quot;Error while completing the slot allocation.&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mainThreadExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求slot调用TaskExecutor 的requestSlot方法，由TaskExecutor 直接向jobManager提供slot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; requestSlot(</span><br><span class="line">   final SlotID slotId,</span><br><span class="line">   final JobID jobId,</span><br><span class="line">   final AllocationID allocationId,</span><br><span class="line">   final ResourceProfile resourceProfile,</span><br><span class="line">   final String targetAddress,</span><br><span class="line">   final ResourceManagerId resourceManagerId,</span><br><span class="line">   final Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;判断发送请求的 RM 是否是当前 TaskExecutor 注册的</span><br><span class="line">      if (!isConnectedToResourceManager(resourceManagerId)) &#123;</span><br><span class="line">         final String message &#x3D; String.format(&quot;TaskManager is not connected to the resource manager %s.&quot;, resourceManagerId);</span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskManagerException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果 slot 是 Free 状态，则分配 slot</span><br><span class="line">         if (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, resourceProfile, taskManagerConfiguration.getTimeout())) &#123;</span><br><span class="line">            log.info(&quot;Allocated slot for &#123;&#125;.&quot;, allocationId);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            log.info(&quot;Could not allocate slot for &#123;&#125;.&quot;, allocationId);</span><br><span class="line">            throw new SlotAllocationException(&quot;Could not allocate slot.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else if (!taskSlotTable.isAllocated(slotId.getSlotNumber(), jobId, allocationId)) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果 slot 已经被分配了，则抛出异常</span><br><span class="line">         final String message &#x3D; &quot;The slot &quot; + slotId + &quot; has already been allocated for a different job.&quot;;</span><br><span class="line"></span><br><span class="line">         log.info(message);</span><br><span class="line"></span><br><span class="line">         final AllocationID allocationID &#x3D; taskSlotTable.getCurrentAllocation(slotId.getSlotNumber());</span><br><span class="line">         throw new SlotOccupiedException(message, allocationID, taskSlotTable.getOwningJob(allocationID));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将分配的 slot 提供给发送请求的 JobManager</span><br><span class="line">      if (jobManagerTable.contains(jobId)) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果和对应的 JobManager 已经建立了连接，则向 JobManager 提供 slot</span><br><span class="line">         offerSlotsToJobManager(jobId);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">         &#x2F;&#x2F;否则，先和JobManager 建立连接，连接建立后会调用 offerSlotsToJobManager(jobId) 方法</span><br><span class="line">            jobLeaderService.addJob(jobId, targetAddress);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; free the allocated slot</span><br><span class="line">            try &#123;</span><br><span class="line">               taskSlotTable.freeSlot(allocationId);</span><br><span class="line">            &#125; catch (SlotNotFoundException slotNotFoundException) &#123;</span><br><span class="line">               &#x2F;&#x2F; slot no longer existent, this should actually never happen, because we&#39;ve</span><br><span class="line">               &#x2F;&#x2F; just allocated the slot. So let&#39;s fail hard in this case!</span><br><span class="line">               onFatalError(slotNotFoundException);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; release local state under the allocation id.</span><br><span class="line">            localStateStoresManager.releaseLocalStateForAllocationId(allocationId);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; sanity check</span><br><span class="line">            if (!taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</span><br><span class="line">               onFatalError(new Exception(&quot;Could not free slot &quot; + slotId));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new SlotAllocationException(&quot;Could not add job to job leader service.&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (TaskManagerException taskManagerException) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(taskManagerException);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Slot 被分配给之后，TaskExecutor 需要将对应的 slot 提供给 JobManager，此时分两种情况，如果请求资源的jobmanager还没有和TaskExecutor 建立连接，则先将TaskExecutor 与jobmanager的leader节点建立连接，并注册TaskExecutor 。然后再通过offerSlotsToJobManager提供slot。如果已经存在连接则直接调用offerSlotsToJobManager</p>
<p>建立连接过程如下：通过JobLeaderService的addJob，由highAvailabilityServices选取该job的JobManager的Leader节点，并启动JobManagerLeaderListener主节点的监听。JobLeaderService是用来管理JobManager的leader节点的服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void addJob(final JobID jobId, final String defaultTargetAddress) throws Exception &#123;</span><br><span class="line">   Preconditions.checkState(JobLeaderService.State.STARTED &#x3D;&#x3D; state, &quot;The service is currently not running.&quot;);</span><br><span class="line"></span><br><span class="line">   LOG.info(&quot;Add job &#123;&#125; for job leader monitoring.&quot;, jobId);</span><br><span class="line"></span><br><span class="line">   final LeaderRetrievalService leaderRetrievalService &#x3D; highAvailabilityServices.getJobManagerLeaderRetriever(</span><br><span class="line">      jobId,</span><br><span class="line">      defaultTargetAddress);</span><br><span class="line"></span><br><span class="line">   JobLeaderService.JobManagerLeaderListener jobManagerLeaderListener &#x3D; new JobManagerLeaderListener(jobId);</span><br><span class="line"></span><br><span class="line">   final Tuple2&lt;LeaderRetrievalService, JobManagerLeaderListener&gt; oldEntry &#x3D; jobLeaderServices.put(jobId, Tuple2.of(leaderRetrievalService, jobManagerLeaderListener));</span><br><span class="line"></span><br><span class="line">   if (oldEntry !&#x3D; null) &#123;</span><br><span class="line">      oldEntry.f0.stop();</span><br><span class="line">      oldEntry.f1.stop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   leaderRetrievalService.start(jobManagerLeaderListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选取成功，回调JobManagerLeaderListener的notifyLeaderAddress方法告知JobManager主节点地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notifyLeaderAddress(final @Nullable String leaderAddress, final @Nullable UUID leaderId) &#123;</span><br><span class="line">   if (stopped) &#123;</span><br><span class="line">      LOG.debug(&quot;&#123;&#125;&#39;s leader retrieval listener reported a new leader for job &#123;&#125;. &quot; +</span><br><span class="line">         &quot;However, the service is no longer running.&quot;, JobLeaderService.class.getSimpleName(), jobId);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final JobMasterId jobMasterId &#x3D; JobMasterId.fromUuidOrNull(leaderId);</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;New leader information for job &#123;&#125;. Address: &#123;&#125;, leader id: &#123;&#125;.&quot;,</span><br><span class="line">         jobId, leaderAddress, jobMasterId);</span><br><span class="line"></span><br><span class="line">      if (leaderAddress &#x3D;&#x3D; null || leaderAddress.isEmpty()) &#123;</span><br><span class="line">         &#x2F;&#x2F; the leader lost leadership but there is no other leader yet.</span><br><span class="line">         if (rpcConnection !&#x3D; null) &#123;</span><br><span class="line">            rpcConnection.close();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         jobLeaderListener.jobManagerLostLeadership(jobId, currentJobMasterId);</span><br><span class="line"></span><br><span class="line">         currentJobMasterId &#x3D; jobMasterId;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         currentJobMasterId &#x3D; jobMasterId;</span><br><span class="line"></span><br><span class="line">         if (rpcConnection !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we are already trying to connect to this leader</span><br><span class="line">            if (!Objects.equals(jobMasterId, rpcConnection.getTargetLeaderId())) &#123;</span><br><span class="line">               rpcConnection.close();</span><br><span class="line"></span><br><span class="line">               rpcConnection &#x3D; new JobManagerRegisteredRpcConnection(</span><br><span class="line">                  LOG,</span><br><span class="line">                  leaderAddress,</span><br><span class="line">                  jobMasterId,</span><br><span class="line">                  rpcService.getExecutor());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            rpcConnection &#x3D; new JobManagerRegisteredRpcConnection(</span><br><span class="line">               LOG,</span><br><span class="line">               leaderAddress,</span><br><span class="line">               jobMasterId,</span><br><span class="line">               rpcService.getExecutor());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; double check for a concurrent stop operation</span><br><span class="line">         if (stopped) &#123;</span><br><span class="line">            rpcConnection.close();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.info(&quot;Try to register at job manager &#123;&#125; with leader id &#123;&#125;.&quot;, leaderAddress, leaderId);</span><br><span class="line">            rpcConnection.start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rpcConnection.start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">   checkState(!closed, &quot;The RPC connection is already closed&quot;);</span><br><span class="line">   checkState(!isConnected() &amp;&amp; pendingRegistration &#x3D;&#x3D; null, &quot;The RPC connection is already started&quot;);</span><br><span class="line"></span><br><span class="line">   final RetryingRegistration&lt;F, G, S&gt; newRegistration &#x3D; createNewRegistration();</span><br><span class="line"></span><br><span class="line">   if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">      newRegistration.startRegistration();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; concurrent start operation</span><br><span class="line">      newRegistration.cancel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过startRegistration最终进入JobLeaderService的invokeRegistration，调用JobMaster的registerTaskManager注册taskManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</span><br><span class="line">      JobMasterGateway gateway,</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      long timeoutMillis) throws Exception &#123;</span><br><span class="line">   return gateway.registerTaskManager(taskManagerRpcAddress, taskManagerLocation, Time.milliseconds(timeoutMillis));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;RegistrationResponse&gt; registerTaskManager(</span><br><span class="line">      final String taskManagerRpcAddress,</span><br><span class="line">      final TaskManagerLocation taskManagerLocation,</span><br><span class="line">      final Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   final ResourceID taskManagerId &#x3D; taskManagerLocation.getResourceID();</span><br><span class="line"></span><br><span class="line">   if (registeredTaskManagers.containsKey(taskManagerId)) &#123;</span><br><span class="line">      final RegistrationResponse response &#x3D; new JMTMRegistrationSuccess(resourceId);</span><br><span class="line">      return CompletableFuture.completedFuture(response);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return getRpcService()</span><br><span class="line">         .connect(taskManagerRpcAddress, TaskExecutorGateway.class)</span><br><span class="line">         .handleAsync(</span><br><span class="line">            (TaskExecutorGateway taskExecutorGateway, Throwable throwable) -&gt; &#123;</span><br><span class="line">               if (throwable !&#x3D; null) &#123;</span><br><span class="line">                  return new RegistrationResponse.Decline(throwable.getMessage());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               slotPool.registerTaskManager(taskManagerId);</span><br><span class="line">               registeredTaskManagers.put(taskManagerId, Tuple2.of(taskManagerLocation, taskExecutorGateway));</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; monitor the task manager as heartbeat target</span><br><span class="line">               taskManagerHeartbeatManager.monitorTarget(taskManagerId, new HeartbeatTarget&lt;AllocatedSlotReport&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void receiveHeartbeat(ResourceID resourceID, AllocatedSlotReport payload) &#123;</span><br><span class="line">                     &#x2F;&#x2F; the task manager will not request heartbeat, so this method will never be called currently</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  @Override</span><br><span class="line">                  public void requestHeartbeat(ResourceID resourceID, AllocatedSlotReport allocatedSlotReport) &#123;</span><br><span class="line">                     taskExecutorGateway.heartbeatFromJobManager(resourceID, allocatedSlotReport);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">               return new JMTMRegistrationSuccess(resourceId);</span><br><span class="line">            &#125;,</span><br><span class="line">            getMainThreadExecutor());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而通过 offerSlotsToJobManager(jobId)方法来实现slot分配给JobManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void offerSlotsToJobManager(final JobID jobId) &#123;</span><br><span class="line">   final JobManagerConnection jobManagerConnection &#x3D; jobManagerTable.get(jobId);</span><br><span class="line"></span><br><span class="line">   if (jobManagerConnection &#x3D;&#x3D; null) &#123;</span><br><span class="line">      log.debug(&quot;There is no job manager connection to the leader of job &#123;&#125;.&quot;, jobId);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      if (taskSlotTable.hasAllocatedSlots(jobId)) &#123;</span><br><span class="line">         log.info(&quot;Offer reserved slots to the leader of job &#123;&#125;.&quot;, jobId);</span><br><span class="line"></span><br><span class="line">         final JobMasterGateway jobMasterGateway &#x3D; jobManagerConnection.getJobManagerGateway();</span><br><span class="line">       &#x2F;&#x2F;获取分配给当前 Job 的 slot，这里只会取得状态为 allocated 的 slot</span><br><span class="line">         final Iterator&lt;TaskSlot&lt;Task&gt;&gt; reservedSlotsIterator &#x3D; taskSlotTable.getAllocatedSlots(jobId);</span><br><span class="line">         final JobMasterId jobMasterId &#x3D; jobManagerConnection.getJobMasterId();</span><br><span class="line"></span><br><span class="line">         final Collection&lt;SlotOffer&gt; reservedSlots &#x3D; new HashSet&lt;&gt;(2);</span><br><span class="line"></span><br><span class="line">         while (reservedSlotsIterator.hasNext()) &#123;</span><br><span class="line">         &#x2F;&#x2F;SlotOffer请求类，用于向jobmanager提供slot</span><br><span class="line">            SlotOffer offer &#x3D; reservedSlotsIterator.next().generateSlotOffer();</span><br><span class="line">            reservedSlots.add(offer);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 RPC 调用，将slot提供给 JobMaster</span><br><span class="line">         CompletableFuture&lt;Collection&lt;SlotOffer&gt;&gt; acceptedSlotsFuture &#x3D; jobMasterGateway.offerSlots(</span><br><span class="line">            getResourceID(),</span><br><span class="line">            reservedSlots,</span><br><span class="line">            taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">         acceptedSlotsFuture.whenCompleteAsync(</span><br><span class="line">            handleAcceptedSlotOffers(jobId, jobMasterGateway, jobMasterId, reservedSlots),</span><br><span class="line">            getMainThreadExecutor());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         log.debug(&quot;There are no unassigned slots for the job &#123;&#125;.&quot;, jobId);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private BiConsumer&lt;Iterable&lt;SlotOffer&gt;, Throwable&gt; handleAcceptedSlotOffers(JobID jobId, JobMasterGateway jobMasterGateway, JobMasterId jobMasterId, Collection&lt;SlotOffer&gt; offeredSlots) &#123;</span><br><span class="line">   return (Iterable&lt;SlotOffer&gt; acceptedSlots, Throwable throwable) -&gt; &#123;</span><br><span class="line">      if (throwable !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;超时，则重试</span><br><span class="line">         if (throwable instanceof TimeoutException) &#123;</span><br><span class="line">            log.info(&quot;Slot offering to JobManager did not finish in time. Retrying the slot offering.&quot;);</span><br><span class="line">            &#x2F;&#x2F; We ran into a timeout. Try again.</span><br><span class="line">            offerSlotsToJobManager(jobId);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            log.warn(&quot;Slot offering to JobManager failed. Freeing the slots &quot; +</span><br><span class="line">               &quot;and returning them to the ResourceManager.&quot;, throwable);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; We encountered an exception. Free the slots and return them to the RM.</span><br><span class="line">            &#x2F;&#x2F; 发生异常，则释放所有的 slot</span><br><span class="line">            for (SlotOffer reservedSlot: offeredSlots) &#123;</span><br><span class="line">               freeSlotInternal(reservedSlot.getAllocationId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;调用成功</span><br><span class="line">         &#x2F;&#x2F; check if the response is still valid</span><br><span class="line">         if (isJobManagerConnectionValid(jobId, jobMasterId)) &#123;</span><br><span class="line">            &#x2F;&#x2F; mark accepted slots active</span><br><span class="line">            &#x2F;&#x2F;对于被 JobMaster 确认接受的 slot， 标记为 Active 状态</span><br><span class="line">            for (SlotOffer acceptedSlot : acceptedSlots) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                  if (!taskSlotTable.markSlotActive(acceptedSlot.getAllocationId())) &#123;</span><br><span class="line">                     &#x2F;&#x2F; the slot is either free or releasing at the moment</span><br><span class="line">                     final String message &#x3D; &quot;Could not mark slot &quot; + jobId + &quot; active.&quot;;</span><br><span class="line">                     log.debug(message);</span><br><span class="line">                     jobMasterGateway.failSlot(</span><br><span class="line">                        getResourceID(),</span><br><span class="line">                        acceptedSlot.getAllocationId(),</span><br><span class="line">                        new FlinkException(message));</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; catch (SlotNotFoundException e) &#123;</span><br><span class="line">                  final String message &#x3D; &quot;Could not mark slot &quot; + jobId + &quot; active.&quot;;</span><br><span class="line">                  jobMasterGateway.failSlot(</span><br><span class="line">                     getResourceID(),</span><br><span class="line">                     acceptedSlot.getAllocationId(),</span><br><span class="line">                     new FlinkException(message));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               offeredSlots.remove(acceptedSlot);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final Exception e &#x3D; new Exception(&quot;The slot was rejected by the JobManager.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放剩余没有被接受的 slot</span><br><span class="line">            for (SlotOffer rejectedSlot : offeredSlots) &#123;</span><br><span class="line">               freeSlotInternal(rejectedSlot.getAllocationId(), e);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; discard the response since there is a new leader for the job</span><br><span class="line">            log.debug(&quot;Discard offer slot response since there is a new leader &quot; +</span><br><span class="line">               &quot;for the job &#123;&#125;.&quot;, jobId);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 freeSlotInternal(AllocationID, Throwable)方法， 释放和 <code>AllocationID</code> 关联的 slot：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void freeSlotInternal(AllocationID allocationId, Throwable cause) &#123;</span><br><span class="line">   checkNotNull(allocationId);</span><br><span class="line"></span><br><span class="line">   log.debug(&quot;Free slot with allocation id &#123;&#125; because: &#123;&#125;&quot;, allocationId, cause.getMessage());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      final JobID jobId &#x3D; taskSlotTable.getOwningJob(allocationId);</span><br><span class="line">&#x2F;&#x2F;尝试释放 allocationId 绑定的 slot</span><br><span class="line">      final int slotIndex &#x3D; taskSlotTable.freeSlot(allocationId, cause);</span><br><span class="line"></span><br><span class="line">      if (slotIndex !&#x3D; -1) &#123;</span><br><span class="line">&#x2F;&#x2F;成功释放 slot</span><br><span class="line">         if (isConnectedToResourceManager()) &#123;</span><br><span class="line">         &#x2F;&#x2F;告知 ResourceManager 当前 slot 可用</span><br><span class="line">            &#x2F;&#x2F; the slot was freed. Tell the RM about it</span><br><span class="line">            ResourceManagerGateway resourceManagerGateway &#x3D; establishedResourceManagerConnection.getResourceManagerGateway();</span><br><span class="line"></span><br><span class="line">            resourceManagerGateway.notifySlotAvailable(</span><br><span class="line">               establishedResourceManagerConnection.getTaskExecutorRegistrationId(),</span><br><span class="line">               new SlotID(getResourceID(), slotIndex),</span><br><span class="line">               allocationId);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (jobId !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果和 allocationID 绑定的 Job 已经没有分配的 slot 了，那么可以断开和 JobMaster 的连接了</span><br><span class="line">            closeJobManagerConnectionIfNoAllocatedResources(jobId);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (SlotNotFoundException e) &#123;</span><br><span class="line">      log.debug(&quot;Could not free slot for allocation id &#123;&#125;.&quot;, allocationId, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   localStateStoresManager.releaseLocalStateForAllocationId(allocationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskExecutor 的 requestSlot是通过TaskSlotTableImpl的allocateSlot和freeSlot方法来分配和释放slot资源。TaskSlotTableImpl是TaskSlotTable的实现类。</p>
<p>allocateSlot新建TaskSlot类并加入slot的map和已分配slot的map已经每个job的slot的map，freeSlot从各个map中移除TaskSlot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public boolean allocateSlot(</span><br><span class="line">      int index,</span><br><span class="line">      JobID jobId,</span><br><span class="line">      AllocationID allocationId,</span><br><span class="line">      ResourceProfile resourceProfile,</span><br><span class="line">      Time slotTimeout) &#123;</span><br><span class="line">   checkRunning();</span><br><span class="line"></span><br><span class="line">   Preconditions.checkArgument(index &lt; numberSlots);</span><br><span class="line"></span><br><span class="line">   TaskSlot&lt;T&gt; taskSlot &#x3D; allocatedSlots.get(allocationId);</span><br><span class="line">   if (taskSlot !&#x3D; null) &#123;</span><br><span class="line">      LOG.info(&quot;Allocation ID &#123;&#125; is already allocated in &#123;&#125;.&quot;, allocationId, taskSlot);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (taskSlots.containsKey(index)) &#123;</span><br><span class="line">      TaskSlot&lt;T&gt; duplicatedTaskSlot &#x3D; taskSlots.get(index);</span><br><span class="line">      LOG.info(&quot;Slot with index &#123;&#125; already exist, with resource profile &#123;&#125;, job id &#123;&#125; and allocation id &#123;&#125;.&quot;,</span><br><span class="line">         index,</span><br><span class="line">         duplicatedTaskSlot.getResourceProfile(),</span><br><span class="line">         duplicatedTaskSlot.getJobId(),</span><br><span class="line">         duplicatedTaskSlot.getAllocationId());</span><br><span class="line">      return duplicatedTaskSlot.getJobId().equals(jobId) &amp;&amp;</span><br><span class="line">         duplicatedTaskSlot.getAllocationId().equals(allocationId);</span><br><span class="line">   &#125; else if (allocatedSlots.containsKey(allocationId)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   resourceProfile &#x3D; index &gt;&#x3D; 0 ? defaultSlotResourceProfile : resourceProfile;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ResourceBudgetManager分配资源ResourceProfile，ResourceProfile是cpu，内存等指标，资源不够则报错</span><br><span class="line">   if (!budgetManager.reserve(resourceProfile)) &#123;</span><br><span class="line">      LOG.info(&quot;Cannot allocate the requested resources. Trying to allocate &#123;&#125;, &quot;</span><br><span class="line">            + &quot;while the currently remaining available resources are &#123;&#125;, total is &#123;&#125;.&quot;,</span><br><span class="line">         resourceProfile,</span><br><span class="line">         budgetManager.getAvailableBudget(),</span><br><span class="line">         budgetManager.getTotalBudget());</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新建TaskSlot</span><br><span class="line">   taskSlot &#x3D; new TaskSlot&lt;&gt;(index, resourceProfile, memoryPageSize, jobId, allocationId);</span><br><span class="line">   if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">      taskSlots.put(index, taskSlot);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; update the allocation id to task slot map</span><br><span class="line">   allocatedSlots.put(allocationId, taskSlot);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; register a timeout for this slot since it&#39;s in state allocated</span><br><span class="line">   timerService.registerTimeout(allocationId, slotTimeout.getSize(), slotTimeout.getUnit());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; add this slot to the set of job slots</span><br><span class="line">   Set&lt;AllocationID&gt; slots &#x3D; slotsPerJob.get(jobId);</span><br><span class="line"></span><br><span class="line">   if (slots &#x3D;&#x3D; null) &#123;</span><br><span class="line">      slots &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">      slotsPerJob.put(jobId, slots);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   slots.add(allocationId);</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public int freeSlot(AllocationID allocationId, Throwable cause) throws SlotNotFoundException &#123;</span><br><span class="line">   checkStarted();</span><br><span class="line"></span><br><span class="line">   TaskSlot&lt;T&gt; taskSlot &#x3D; getTaskSlot(allocationId);</span><br><span class="line"></span><br><span class="line">   if (taskSlot !&#x3D; null) &#123;</span><br><span class="line">      return freeSlotInternal(taskSlot, cause).isDone() ? taskSlot.getIndex() : -1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new SlotNotFoundException(allocationId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private CompletableFuture&lt;Void&gt; freeSlotInternal(TaskSlot&lt;T&gt; taskSlot, Throwable cause) &#123;</span><br><span class="line">   AllocationID allocationId &#x3D; taskSlot.getAllocationId();</span><br><span class="line"></span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;Free slot &#123;&#125;.&quot;, taskSlot, cause);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      LOG.info(&quot;Free slot &#123;&#125;.&quot;, taskSlot);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (taskSlot.isEmpty()) &#123;</span><br><span class="line">      &#x2F;&#x2F; remove the allocation id to task slot mapping</span><br><span class="line">      allocatedSlots.remove(allocationId);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; unregister a potential timeout</span><br><span class="line">      timerService.unregisterTimeout(allocationId);</span><br><span class="line"></span><br><span class="line">      JobID jobId &#x3D; taskSlot.getJobId();</span><br><span class="line">      Set&lt;AllocationID&gt; slots &#x3D; slotsPerJob.get(jobId);</span><br><span class="line"></span><br><span class="line">      if (slots &#x3D;&#x3D; null) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;There are no more slots allocated for the job &quot; + jobId +</span><br><span class="line">            &quot;. This indicates a programming bug.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      slots.remove(allocationId);</span><br><span class="line"></span><br><span class="line">      if (slots.isEmpty()) &#123;</span><br><span class="line">         slotsPerJob.remove(jobId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      taskSlots.remove(taskSlot.getIndex());</span><br><span class="line">      &#x2F;&#x2F;ResourceBudgetManager释放资源ResourceProfile</span><br><span class="line">      budgetManager.release(taskSlot.getResourceProfile());</span><br><span class="line">   &#125;</span><br><span class="line">   return taskSlot.closeAsync(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看下SlotManagerImpl的updateSlot更新Slot信息，updateSlot有两种情况，1，上报slot消息的taskExecutor已经注册，在reportSlotStatus方法中被调用，2，registerSlot时候被调用，slot已经被分配或没有匹配的 PendingTaskManagerSlot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private boolean updateSlot(SlotID slotId, AllocationID allocationId, JobID jobId) &#123;</span><br><span class="line">   final TaskManagerSlot slot &#x3D; slots.get(slotId);</span><br><span class="line"></span><br><span class="line">   if (slot !&#x3D; null) &#123;</span><br><span class="line">      final TaskManagerRegistration taskManagerRegistration &#x3D; taskManagerRegistrations.get(slot.getInstanceId());</span><br><span class="line"></span><br><span class="line">      if (taskManagerRegistration !&#x3D; null) &#123;</span><br><span class="line">         updateSlotState(slot, taskManagerRegistration, allocationId, jobId);</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Trying to update a slot from a TaskManager &quot; +</span><br><span class="line">            slot.getInstanceId() + &quot; which has not been registered.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      LOG.debug(&quot;Trying to update unknown slot with slot id &#123;&#125;.&quot;, slotId);</span><br><span class="line"></span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是调用updateSlotState方法，更新TaskManagerSlot的状态，有ALLOCATED，PENDING，FREE三种状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private void updateSlotState(</span><br><span class="line">      TaskManagerSlot slot,</span><br><span class="line">      TaskManagerRegistration taskManagerRegistration,</span><br><span class="line">      @Nullable AllocationID allocationId,</span><br><span class="line">      @Nullable JobID jobId) &#123;</span><br><span class="line">   if (null !&#x3D; allocationId) &#123;</span><br><span class="line">      switch (slot.getState()) &#123;</span><br><span class="line">         case PENDING:</span><br><span class="line">            &#x2F;&#x2F; we have a pending slot request --&gt; check whether we have to reject it</span><br><span class="line">            PendingSlotRequest pendingSlotRequest &#x3D; slot.getAssignedSlotRequest();</span><br><span class="line"></span><br><span class="line">            if (Objects.equals(pendingSlotRequest.getAllocationId(), allocationId)) &#123;</span><br><span class="line">               &#x2F;&#x2F; we can cancel the slot request because it has been fulfilled</span><br><span class="line">               cancelPendingSlotRequest(pendingSlotRequest);</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; remove the pending slot request, since it has been completed</span><br><span class="line">               pendingSlotRequests.remove(pendingSlotRequest.getAllocationId());</span><br><span class="line"></span><br><span class="line">               slot.completeAllocation(allocationId, jobId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; we first have to free the slot in order to set a new allocationId</span><br><span class="line">               slot.clearPendingSlotRequest();</span><br><span class="line">               &#x2F;&#x2F; set the allocation id such that the slot won&#39;t be considered for the pending slot request</span><br><span class="line">               slot.updateAllocation(allocationId, jobId);</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; remove the pending request if any as it has been assigned</span><br><span class="line">               final PendingSlotRequest actualPendingSlotRequest &#x3D; pendingSlotRequests.remove(allocationId);</span><br><span class="line"></span><br><span class="line">               if (actualPendingSlotRequest !&#x3D; null) &#123;</span><br><span class="line">                  cancelPendingSlotRequest(actualPendingSlotRequest);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; this will try to find a new slot for the request</span><br><span class="line">               rejectPendingSlotRequest(</span><br><span class="line">                  pendingSlotRequest,</span><br><span class="line">                  new Exception(&quot;Task manager reported slot &quot; + slot.getSlotId() + &quot; being already allocated.&quot;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            taskManagerRegistration.occupySlot();</span><br><span class="line">            break;</span><br><span class="line">         case ALLOCATED:</span><br><span class="line">            if (!Objects.equals(allocationId, slot.getAllocationId())) &#123;</span><br><span class="line">               slot.freeSlot();</span><br><span class="line">               slot.updateAllocation(allocationId, jobId);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         case FREE:</span><br><span class="line">            &#x2F;&#x2F; the slot is currently free --&gt; it is stored in freeSlots</span><br><span class="line">            freeSlots.remove(slot.getSlotId());</span><br><span class="line">            slot.updateAllocation(allocationId, jobId);</span><br><span class="line">            taskManagerRegistration.occupySlot();</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fulfilledSlotRequests.put(allocationId, slot.getSlotId());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; no allocation reported</span><br><span class="line">      switch (slot.getState()) &#123;</span><br><span class="line">         case FREE:</span><br><span class="line">            handleFreeSlot(slot);</span><br><span class="line">            break;</span><br><span class="line">         case PENDING:</span><br><span class="line">            &#x2F;&#x2F; don&#39;t do anything because we still have a pending slot request</span><br><span class="line">            break;</span><br><span class="line">         case ALLOCATED:</span><br><span class="line">            AllocationID oldAllocation &#x3D; slot.getAllocationId();</span><br><span class="line">            slot.freeSlot();</span><br><span class="line">            fulfilledSlotRequests.remove(oldAllocation);</span><br><span class="line">            taskManagerRegistration.freeSlot();</span><br><span class="line"></span><br><span class="line">            handleFreeSlot(slot);</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看下TaskSlot，这是TaskManager对slot的封装类，有Releasing，Allocated，Active，Free四种状态，初始状态为Allocated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TaskSlot&lt;T extends TaskSlotPayload&gt; implements AutoCloseableAsync &#123;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(TaskSlot.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;** Index of the task slot. *&#x2F;</span><br><span class="line">   private final int index;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Resource characteristics for this slot. *&#x2F;</span><br><span class="line">   private final ResourceProfile resourceProfile;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Tasks running in this slot. *&#x2F;</span><br><span class="line">   private final Map&lt;ExecutionAttemptID, T&gt; tasks;</span><br><span class="line"></span><br><span class="line">   private final MemoryManager memoryManager;</span><br><span class="line"></span><br><span class="line">   &#x2F;** State of this slot. *&#x2F;</span><br><span class="line">   private TaskSlotState state;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Job id to which the slot has been allocated. *&#x2F;</span><br><span class="line">   private final JobID jobId;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Allocation id of this slot. *&#x2F;</span><br><span class="line">   private final AllocationID allocationId;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The closing future is completed when the slot is freed and closed. *&#x2F;</span><br><span class="line">   private final CompletableFuture&lt;Void&gt; closingFuture;</span><br></pre></td></tr></table></figure>

<p>TaskSlot可以管理task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(T task) &#123;</span><br><span class="line">   &#x2F;&#x2F; Check that this slot has been assigned to the job sending this task</span><br><span class="line">   Preconditions.checkArgument(task.getJobID().equals(jobId), &quot;The task&#39;s job id does not match the &quot; +</span><br><span class="line">      &quot;job id for which the slot has been allocated.&quot;);</span><br><span class="line">   Preconditions.checkArgument(task.getAllocationId().equals(allocationId), &quot;The task&#39;s allocation &quot; +</span><br><span class="line">      &quot;id does not match the allocation id for which the slot has been allocated.&quot;);</span><br><span class="line">   Preconditions.checkState(TaskSlotState.ACTIVE &#x3D;&#x3D; state, &quot;The task slot is not in state active.&quot;);</span><br><span class="line"></span><br><span class="line">   T oldTask &#x3D; tasks.put(task.getExecutionId(), task);</span><br><span class="line"></span><br><span class="line">   if (oldTask !&#x3D; null) &#123;</span><br><span class="line">      tasks.put(task.getExecutionId(), oldTask);</span><br><span class="line">      return false;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已上是TaskManager向Resoucemanager上报slot状态的过程，下面看一下TaskManager和job manager的交互过程。</p>
<p>在前文中提到，在 Slot 被分配给之后，TaskExecutor 需要将对应的 slot 提供给 JobManager，通过offerSlotsToJobManager方法实现，其中调用了jobMasterGateway的offerSlots,jobMasterGateway继承自FencedRpcGateway。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Collection&lt;SlotOffer&gt;&gt; acceptedSlotsFuture &#x3D; jobMasterGateway.offerSlots(</span><br><span class="line">   getResourceID(),</span><br><span class="line">   reservedSlots,</span><br><span class="line">   taskManagerConfiguration.getTimeout());</span><br></pre></td></tr></table></figure>

<p>JobMasterGateway实现类为JobMaster,进入JobMaster的offerSlots</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Collection&lt;SlotOffer&gt;&gt; offerSlots(</span><br><span class="line">      final ResourceID taskManagerId,</span><br><span class="line">      final Collection&lt;SlotOffer&gt; slots,</span><br><span class="line">      final Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   Tuple2&lt;TaskManagerLocation, TaskExecutorGateway&gt; taskManager &#x3D; registeredTaskManagers.get(taskManagerId);</span><br><span class="line"></span><br><span class="line">   if (taskManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new Exception(&quot;Unknown TaskManager &quot; + taskManagerId));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final TaskManagerLocation taskManagerLocation &#x3D; taskManager.f0;</span><br><span class="line">   final TaskExecutorGateway taskExecutorGateway &#x3D; taskManager.f1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;建立TaskManager的Gateway</span><br><span class="line">   final RpcTaskManagerGateway rpcTaskManagerGateway &#x3D; new RpcTaskManagerGateway(taskExecutorGateway, getFencingToken());</span><br><span class="line"></span><br><span class="line">   return CompletableFuture.completedFuture(</span><br><span class="line">      slotPool.offerSlots(</span><br><span class="line">         taskManagerLocation,</span><br><span class="line">         rpcTaskManagerGateway,</span><br><span class="line">         slots));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobMaster里管理slot的类是SlotPool，进入SlotPool的offerSlots</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Collection&lt;SlotOffer&gt; offerSlots(</span><br><span class="line">      TaskManagerLocation taskManagerLocation,</span><br><span class="line">      TaskManagerGateway taskManagerGateway,</span><br><span class="line">      Collection&lt;SlotOffer&gt; offers) &#123;</span><br><span class="line"></span><br><span class="line">   ArrayList&lt;SlotOffer&gt; result &#x3D; new ArrayList&lt;&gt;(offers.size());</span><br><span class="line">&#x2F;&#x2F;对每个SlotOffer请求依此调用offerSlot</span><br><span class="line">   for (SlotOffer offer : offers) &#123;</span><br><span class="line">      if (offerSlot(</span><br><span class="line">         taskManagerLocation,</span><br><span class="line">         taskManagerGateway,</span><br><span class="line">         offer)) &#123;</span><br><span class="line"></span><br><span class="line">         result.add(offer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">boolean offerSlot(</span><br><span class="line">      final TaskManagerLocation taskManagerLocation,</span><br><span class="line">      final TaskManagerGateway taskManagerGateway,</span><br><span class="line">      final SlotOffer slotOffer) &#123;</span><br><span class="line"></span><br><span class="line">   componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; check if this TaskManager is valid</span><br><span class="line">   final ResourceID resourceID &#x3D; taskManagerLocation.getResourceID();</span><br><span class="line">   final AllocationID allocationID &#x3D; slotOffer.getAllocationId();</span><br><span class="line"></span><br><span class="line">   if (!registeredTaskManagers.contains(resourceID)) &#123;</span><br><span class="line">      log.debug(&quot;Received outdated slot offering [&#123;&#125;] from unregistered TaskManager: &#123;&#125;&quot;,</span><br><span class="line">            slotOffer.getAllocationId(), taskManagerLocation);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; check whether we have already using this slot</span><br><span class="line">   AllocatedSlot existingSlot;</span><br><span class="line">   &#x2F;&#x2F;是否已接收该slot</span><br><span class="line">   if ((existingSlot &#x3D; allocatedSlots.get(allocationID)) !&#x3D; null ||</span><br><span class="line">      (existingSlot &#x3D; availableSlots.get(allocationID)) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we need to figure out if this is a repeated offer for the exact same slot,</span><br><span class="line">      &#x2F;&#x2F; or another offer that comes from a different TaskManager after the ResourceManager</span><br><span class="line">      &#x2F;&#x2F; re-tried the request</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we write this in terms of comparing slot IDs, because the Slot IDs are the identifiers of</span><br><span class="line">      &#x2F;&#x2F; the actual slots on the TaskManagers</span><br><span class="line">      &#x2F;&#x2F; Note: The slotOffer should have the SlotID</span><br><span class="line">      final SlotID existingSlotId &#x3D; existingSlot.getSlotId();</span><br><span class="line">      final SlotID newSlotId &#x3D; new SlotID(taskManagerLocation.getResourceID(), slotOffer.getSlotIndex());</span><br><span class="line"></span><br><span class="line">      if (existingSlotId.equals(newSlotId)) &#123;</span><br><span class="line">      &#x2F;&#x2F;发送了重复的Slot</span><br><span class="line">         log.info(&quot;Received repeated offer for slot [&#123;&#125;]. Ignoring.&quot;, allocationID);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; return true here so that the sender will get a positive acknowledgement to the retry</span><br><span class="line">         &#x2F;&#x2F; and mark the offering as a success</span><br><span class="line">         return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;jobmaster需要的slot已经被其他task executor提供的slot满足，则拒绝该slot，该slot最终会释放。</span><br><span class="line">         &#x2F;&#x2F; the allocation has been fulfilled by another slot, reject the offer so the task executor</span><br><span class="line">         &#x2F;&#x2F; will offer the slot to the resource manager</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建AllocatedSlot，AllocatedSlot是jobmanager里对slot的封装。通过AllocationID 区分</span><br><span class="line">   final AllocatedSlot allocatedSlot &#x3D; new AllocatedSlot(</span><br><span class="line">      allocationID,</span><br><span class="line">      taskManagerLocation,</span><br><span class="line">      slotOffer.getSlotIndex(),</span><br><span class="line">      slotOffer.getResourceProfile(),</span><br><span class="line">      taskManagerGateway);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; check whether we have request waiting for this slot</span><br><span class="line">   PendingRequest pendingRequest &#x3D; pendingRequests.removeKeyB(allocationID);</span><br><span class="line">   &#x2F;&#x2F; 检查是否有一个 request 和 这个 AllocationID 关联</span><br><span class="line">   if (pendingRequest !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; we were waiting for this!</span><br><span class="line">      &#x2F;&#x2F;有一个pending request 正在等待这个 slot</span><br><span class="line">      allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试去完成那个等待的请求</span><br><span class="line">      if (!pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot)) &#123;</span><br><span class="line">         &#x2F;&#x2F; we could not complete the pending slot future --&gt; try to fulfill another pending request</span><br><span class="line">         &#x2F;&#x2F;尝试失败</span><br><span class="line">         allocatedSlots.remove(pendingRequest.getSlotRequestId());</span><br><span class="line">         &#x2F;&#x2F;尝试去满足其他在等待的请求</span><br><span class="line">         tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         log.debug(&quot;Fulfilled slot request [&#123;&#125;] with allocated slot [&#123;&#125;].&quot;, pendingRequest.getSlotRequestId(), allocationID);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">   &#x2F;&#x2F;没有请求在等待这个slot，可能请求已经被满足了，尝试去满足其他在等待的请求</span><br><span class="line">      &#x2F;&#x2F; we were actually not waiting for this:</span><br><span class="line">      &#x2F;&#x2F;   - could be that this request had been fulfilled</span><br><span class="line">      &#x2F;&#x2F;   - we are receiving the slots from TaskManagers after becoming leaders</span><br><span class="line">      tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we accepted the request in any case. slot will be released after it idled for</span><br><span class="line">   &#x2F;&#x2F; too long and timed out</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦有新的可用的 <code>AllocatedSlot</code> 的时候，<code>SlotPoolImpl</code> 会尝试用这个 <code>AllocatedSlot</code> 去提前满足其他还在等待响应的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void tryFulfillSlotRequestOrMakeAvailable(AllocatedSlot allocatedSlot) &#123;</span><br><span class="line">   Preconditions.checkState(!allocatedSlot.isUsed(), &quot;Provided slot is still in use.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;查找和当前 AllocatedSlot 的计算资源相匹配的还在等待的请求</span><br><span class="line">   final PendingRequest pendingRequest &#x3D; pollMatchingPendingRequest(allocatedSlot);</span><br><span class="line"></span><br><span class="line">   if (pendingRequest !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果有匹配的请求，那么将 AllocatedSlot 分配给等待的请求</span><br><span class="line">      log.debug(&quot;Fulfilling pending slot request [&#123;&#125;] early with returned slot [&#123;&#125;]&quot;,</span><br><span class="line">         pendingRequest.getSlotRequestId(), allocatedSlot.getAllocationId());</span><br><span class="line"></span><br><span class="line">      allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot);</span><br><span class="line">      pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F;如果没有，那么这个 AllocatedSlot 变成 available 的</span><br><span class="line">      log.debug(&quot;Adding returned slot [&#123;&#125;] to available slots&quot;, allocatedSlot.getAllocationId());</span><br><span class="line">      availableSlots.add(allocatedSlot, clock.relativeTimeMillis());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private PendingRequest pollMatchingPendingRequest(final AllocatedSlot slot) &#123;</span><br><span class="line">   final ResourceProfile slotResources &#x3D; slot.getResourceProfile();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; try the requests sent to the resource manager first</span><br><span class="line">   for (PendingRequest request : pendingRequests.values()) &#123;</span><br><span class="line">      if (slotResources.isMatching(request.getResourceProfile())) &#123;</span><br><span class="line">         pendingRequests.removeKeyA(request.getSlotRequestId());</span><br><span class="line">         return request;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; try the requests waiting for a resource manager connection next</span><br><span class="line">   for (PendingRequest request : waitingForResourceManager.values()) &#123;</span><br><span class="line">      if (slotResources.isMatching(request.getResourceProfile())) &#123;</span><br><span class="line">         waitingForResourceManager.remove(request.getSlotRequestId());</span><br><span class="line">         return request;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; no request pending, or no request matches</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slotPool</code> 启动的时候会开启一个定时调度的任务，周期性地检查空闲的 slot，如果 slot 空闲时间过长，会将该 slot 归还给 TaskManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void start(</span><br><span class="line">   @Nonnull JobMasterId jobMasterId,</span><br><span class="line">   @Nonnull String newJobManagerAddress,</span><br><span class="line">   @Nonnull ComponentMainThreadExecutor componentMainThreadExecutor) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   this.jobMasterId &#x3D; jobMasterId;</span><br><span class="line">   this.jobManagerAddress &#x3D; newJobManagerAddress;</span><br><span class="line">   this.componentMainThreadExecutor &#x3D; componentMainThreadExecutor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查空闲slot</span><br><span class="line">   scheduleRunAsync(this::checkIdleSlot, idleSlotTimeout);</span><br><span class="line">   scheduleRunAsync(this::checkBatchSlotTimeout, batchSlotTimeout);</span><br><span class="line"></span><br><span class="line">   if (log.isDebugEnabled()) &#123;</span><br><span class="line">      scheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected void checkIdleSlot() &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The timestamp in SlotAndTimestamp is relative</span><br><span class="line">   final long currentRelativeTimeMillis &#x3D; clock.relativeTimeMillis();</span><br><span class="line"></span><br><span class="line">   final List&lt;AllocatedSlot&gt; expiredSlots &#x3D; new ArrayList&lt;&gt;(availableSlots.size());</span><br><span class="line"></span><br><span class="line">   for (SlotAndTimestamp slotAndTimestamp : availableSlots.availableSlots.values()) &#123;</span><br><span class="line">      if (currentRelativeTimeMillis - slotAndTimestamp.timestamp &gt; idleSlotTimeout.toMilliseconds()) &#123;</span><br><span class="line">         expiredSlots.add(slotAndTimestamp.slot);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final FlinkException cause &#x3D; new FlinkException(&quot;Releasing idle slot.&quot;);</span><br><span class="line"></span><br><span class="line">   for (AllocatedSlot expiredSlot : expiredSlots) &#123;</span><br><span class="line">      final AllocationID allocationID &#x3D; expiredSlot.getAllocationId();</span><br><span class="line">      if (availableSlots.tryRemove(allocationID) !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;将空闲的 slot 归还给 TaskManager，调用TaskExecutor的freeSlot</span><br><span class="line">         log.info(&quot;Releasing idle slot [&#123;&#125;].&quot;, allocationID);</span><br><span class="line">         final CompletableFuture&lt;Acknowledge&gt; freeSlotFuture &#x3D; expiredSlot.getTaskManagerGateway().freeSlot(</span><br><span class="line">            allocationID,</span><br><span class="line">            cause,</span><br><span class="line">            rpcTimeout);</span><br><span class="line"></span><br><span class="line">         FutureUtils.whenCompleteAsyncIfNotDone(</span><br><span class="line">            freeSlotFuture,</span><br><span class="line">            componentMainThreadExecutor,</span><br><span class="line">            (Acknowledge ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">               if (throwable !&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;&#x2F; The slot status will be synced to task manager in next heartbeat.</span><br><span class="line">                  log.debug(&quot;Releasing slot [&#123;&#125;] of registered TaskExecutor &#123;&#125; failed. Discarding slot.&quot;,</span><br><span class="line">                           allocationID, expiredSlot.getTaskManagerId(), throwable);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   scheduleRunAsync(this::checkIdleSlot, idleSlotTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SlotPool通过requestNewAllocatedSlot请求Slot，根据所需的资源大小创建PendingRequest类用于申请slot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;PhysicalSlot&gt; requestNewAllocatedSlot(</span><br><span class="line">			@Nonnull SlotRequestId slotRequestId,</span><br><span class="line">			@Nonnull ResourceProfile resourceProfile,</span><br><span class="line">			Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">		componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">		final PendingRequest pendingRequest &#x3D; PendingRequest.createStreamingRequest(slotRequestId, resourceProfile);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; register request timeout</span><br><span class="line">		FutureUtils</span><br><span class="line">			.orTimeout(</span><br><span class="line">				pendingRequest.getAllocatedSlotFuture(),</span><br><span class="line">				timeout.toMilliseconds(),</span><br><span class="line">				TimeUnit.MILLISECONDS,</span><br><span class="line">				componentMainThreadExecutor)</span><br><span class="line">			.whenComplete(</span><br><span class="line">				(AllocatedSlot ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">					if (throwable instanceof TimeoutException) &#123;</span><br><span class="line">						timeoutPendingSlotRequest(slotRequestId);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">		return requestNewAllocatedSlotInternal(pendingRequest)</span><br><span class="line">			.thenApply((Function.identity()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Nonnull</span><br><span class="line">	@Override</span><br><span class="line">	public CompletableFuture&lt;PhysicalSlot&gt; requestNewAllocatedBatchSlot(</span><br><span class="line">		@Nonnull SlotRequestId slotRequestId,</span><br><span class="line">		@Nonnull ResourceProfile resourceProfile) &#123;</span><br><span class="line"></span><br><span class="line">		componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">		final PendingRequest pendingRequest &#x3D; PendingRequest.createBatchRequest(slotRequestId, resourceProfile);</span><br><span class="line"></span><br><span class="line">		return requestNewAllocatedSlotInternal(pendingRequest)</span><br><span class="line">			.thenApply(Function.identity());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最终通过RPC调用ResourceManager的requestSlot，并封装SlotRequest请求类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;AllocatedSlot&gt; requestNewAllocatedSlotInternal(PendingRequest pendingRequest) &#123;</span><br><span class="line"></span><br><span class="line">   if (resourceManagerGateway &#x3D;&#x3D; null) &#123;</span><br><span class="line">      stashRequestWaitingForResourceManager(pendingRequest);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      requestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return pendingRequest.getAllocatedSlotFuture();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void requestSlotFromResourceManager(</span><br><span class="line">      final ResourceManagerGateway resourceManagerGateway,</span><br><span class="line">      final PendingRequest pendingRequest) &#123;</span><br><span class="line"></span><br><span class="line">   checkNotNull(resourceManagerGateway);</span><br><span class="line">   checkNotNull(pendingRequest);</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Requesting new slot [&#123;&#125;] and profile &#123;&#125; from resource manager.&quot;, pendingRequest.getSlotRequestId(), pendingRequest.getResourceProfile());</span><br><span class="line"></span><br><span class="line">   final AllocationID allocationId &#x3D; new AllocationID();</span><br><span class="line"></span><br><span class="line">   pendingRequests.put(pendingRequest.getSlotRequestId(), allocationId, pendingRequest);</span><br><span class="line"></span><br><span class="line">   pendingRequest.getAllocatedSlotFuture().whenComplete(</span><br><span class="line">      (AllocatedSlot allocatedSlot, Throwable throwable) -&gt; &#123;</span><br><span class="line">         if (throwable !&#x3D; null || !allocationId.equals(allocatedSlot.getAllocationId())) &#123;</span><br><span class="line">            &#x2F;&#x2F; cancel the slot request if there is a failure or if the pending request has</span><br><span class="line">            &#x2F;&#x2F; been completed with another allocated slot</span><br><span class="line">            resourceManagerGateway.cancelSlotRequest(allocationId);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;Acknowledge&gt; rmResponse &#x3D; resourceManagerGateway.requestSlot(</span><br><span class="line">      jobMasterId,</span><br><span class="line">      new SlotRequest(jobId, allocationId, pendingRequest.getResourceProfile(), jobManagerAddress),</span><br><span class="line">      rpcTimeout);</span><br><span class="line"></span><br><span class="line">   FutureUtils.whenCompleteAsyncIfNotDone(</span><br><span class="line">      rmResponse,</span><br><span class="line">      componentMainThreadExecutor,</span><br><span class="line">      (Acknowledge ignored, Throwable failure) -&gt; &#123;</span><br><span class="line">         &#x2F;&#x2F; on failure, fail the request future</span><br><span class="line">         if (failure !&#x3D; null) &#123;</span><br><span class="line">            slotRequestToResourceManagerFailed(pendingRequest.getSlotRequestId(), failure);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceManager的requestSlot调用SlotManager的registerSlotRequest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; requestSlot(</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      SlotRequest slotRequest,</span><br><span class="line">      final Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   JobID jobId &#x3D; slotRequest.getJobId();</span><br><span class="line">   JobManagerRegistration jobManagerRegistration &#x3D; jobManagerRegistrations.get(jobId);</span><br><span class="line"></span><br><span class="line">   if (null !&#x3D; jobManagerRegistration) &#123;</span><br><span class="line">      if (Objects.equals(jobMasterId, jobManagerRegistration.getJobMasterId())) &#123;</span><br><span class="line">         log.info(&quot;Request slot with profile &#123;&#125; for job &#123;&#125; with allocation id &#123;&#125;.&quot;,</span><br><span class="line">            slotRequest.getResourceProfile(),</span><br><span class="line">            slotRequest.getJobId(),</span><br><span class="line">            slotRequest.getAllocationId());</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">            slotManager.registerSlotRequest(slotRequest);</span><br><span class="line">         &#125; catch (ResourceManagerException e) &#123;</span><br><span class="line">            return FutureUtils.completedExceptionally(e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return FutureUtils.completedExceptionally(new ResourceManagerException(&quot;The job leader&#39;s id &quot; +</span><br><span class="line">            jobManagerRegistration.getJobMasterId() + &quot; does not match the received id &quot; + jobMasterId + &#39;.&#39;));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new ResourceManagerException(&quot;Could not find registered job manager for job &quot; + jobId + &#39;.&#39;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SlotManager通过internalRequestSlot查找是否有满足输入的PendingSlotRequest的预留资源，如果有通过fulfillPendingSlotRequestWithPendingTaskManagerSlot直接分配slot，如果没有通过allocateSlot向TaskManager申请slot。allocateSlot与前文逻辑一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean registerSlotRequest(SlotRequest slotRequest) throws ResourceManagerException &#123;</span><br><span class="line">   checkInit();</span><br><span class="line"></span><br><span class="line">   if (checkDuplicateRequest(slotRequest.getAllocationId())) &#123;</span><br><span class="line">      LOG.debug(&quot;Ignoring a duplicate slot request with allocation id &#123;&#125;.&quot;, slotRequest.getAllocationId());</span><br><span class="line"></span><br><span class="line">      return false;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      PendingSlotRequest pendingSlotRequest &#x3D; new PendingSlotRequest(slotRequest);</span><br><span class="line"></span><br><span class="line">      pendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         internalRequestSlot(pendingSlotRequest);</span><br><span class="line">      &#125; catch (ResourceManagerException e) &#123;</span><br><span class="line">         &#x2F;&#x2F; requesting the slot failed --&gt; remove pending slot request</span><br><span class="line">         pendingSlotRequests.remove(slotRequest.getAllocationId());</span><br><span class="line"></span><br><span class="line">         throw new ResourceManagerException(&quot;Could not fulfill slot request &quot; + slotRequest.getAllocationId() + &#39;.&#39;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException &#123;</span><br><span class="line">   final ResourceProfile resourceProfile &#x3D; pendingSlotRequest.getResourceProfile();</span><br><span class="line"></span><br><span class="line">   OptionalConsumer.of(findMatchingSlot(resourceProfile))</span><br><span class="line">      .ifPresent(taskManagerSlot -&gt; allocateSlot(taskManagerSlot, pendingSlotRequest))</span><br><span class="line">      .ifNotPresent(() -&gt; fulfillPendingSlotRequestWithPendingTaskManagerSlot(pendingSlotRequest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void fulfillPendingSlotRequestWithPendingTaskManagerSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException &#123;</span><br><span class="line">   ResourceProfile resourceProfile &#x3D; pendingSlotRequest.getResourceProfile();</span><br><span class="line">   Optional&lt;PendingTaskManagerSlot&gt; pendingTaskManagerSlotOptional &#x3D; findFreeMatchingPendingTaskManagerSlot(resourceProfile);</span><br><span class="line"></span><br><span class="line">   if (!pendingTaskManagerSlotOptional.isPresent()) &#123;</span><br><span class="line">      pendingTaskManagerSlotOptional &#x3D; allocateResource(resourceProfile);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   OptionalConsumer.of(pendingTaskManagerSlotOptional)</span><br><span class="line">      .ifPresent(pendingTaskManagerSlot -&gt; assignPendingTaskManagerSlot(pendingSlotRequest, pendingTaskManagerSlot))</span><br><span class="line">      .ifNotPresent(() -&gt; &#123;</span><br><span class="line">         &#x2F;&#x2F; request can not be fulfilled by any free slot or pending slot that can be allocated,</span><br><span class="line">         &#x2F;&#x2F; check whether it can be fulfilled by allocated slots</span><br><span class="line">         if (failUnfulfillableRequest &amp;&amp; !isFulfillableByRegisteredSlots(pendingSlotRequest.getResourceProfile())) &#123;</span><br><span class="line">            throw new UnfulfillableSlotRequestException(pendingSlotRequest.getAllocationId(), pendingSlotRequest.getResourceProfile());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/selenium%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E5%BE%AE%E5%8D%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/12/selenium%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E5%BE%AE%E5%8D%9A/" itemprop="url">selenium自动删除微博</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-12T15:14:47+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>最近微博账号被盗用，莫名发了很多广告的微博。占据了前面几页，导致别人访问我的微博印象很不好。数了数大约前100条微博都是垃圾内容，如果手动一个一个删除会相当累。于是想用python实现一个自动删除微博内容的代码，搜了一下用selenium的webdriver模拟鼠标的点击删除操作是一个可行的方法。</code></pre><p>​    代码比较简单，因为我这里模拟了chrome浏览器，所以要下载与本机chrome浏览器版本一致的chromedriver并放入chrome浏览器的安装路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class WeiboCrawler:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chrome_driver &#x3D; &#39;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe&#39;</span><br><span class="line">        self.browser &#x3D; webdriver.Chrome(executable_path&#x3D;self.chrome_driver)  ##控制谷歌浏览器</span><br><span class="line">        self.browser.get(&#39;http:&#x2F;&#x2F;weibo.com&#x2F;login.php&#39;)  ## 打开微博</span><br><span class="line">        self.browser.maximize_window()</span><br><span class="line"></span><br><span class="line">    def login(self, user, pasw, numb):</span><br><span class="line">        self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;loginname&quot;]&#39;).send_keys(user)</span><br><span class="line">        # 把密码填入</span><br><span class="line">        self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;pl_login_form&quot;]&#x2F;div&#x2F;div[3]&#x2F;div[2]&#x2F;div&#x2F;input&#39;).send_keys(pasw)</span><br><span class="line">        # 把记住我勾去掉</span><br><span class="line">        self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;login_form_savestate&quot;]&#39;).click()</span><br><span class="line"></span><br><span class="line">        # 点击登录按钮</span><br><span class="line">        self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;pl_login_form&quot;]&#x2F;div&#x2F;div[3]&#x2F;div[6]&#x2F;a&#39;).click()</span><br><span class="line">        time.sleep(4)</span><br><span class="line"></span><br><span class="line">        print(&quot;登陆成功&quot;)</span><br><span class="line">        self.del_start(numb)</span><br><span class="line"></span><br><span class="line">    def del_start(self, numb):</span><br><span class="line">    #进入我的主页</span><br><span class="line">        self.browser.find_element_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;v6_pl_rightmod_myinfo&quot;]&#x2F;div&#x2F;div&#x2F;div[2]&#x2F;ul&#x2F;li[3]&#x2F;a&#x2F;strong&#39;).click()</span><br><span class="line"></span><br><span class="line">        for i in range(0, numb):</span><br><span class="line">            time.sleep(3)</span><br><span class="line">            # 下拉菜单</span><br><span class="line">            self.browser.find_element_by_xpath(</span><br><span class="line">                &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;Pl_Official_MyProfileFeed__20&quot;]&#x2F;div&#x2F;div[2]&#x2F;div[1]&#x2F;div[1]&#x2F;div&#x2F;a&#x2F;i&#39;).click()</span><br><span class="line">            # 点击删除按键</span><br><span class="line">            self.browser.find_element_by_xpath(</span><br><span class="line">                &#39;&#x2F;&#x2F;*[@id&#x3D;&quot;Pl_Official_MyProfileFeed__20&quot;]&#x2F;div&#x2F;div[2]&#x2F;div[1]&#x2F;div[1]&#x2F;div&#x2F;div&#x2F;ul&#x2F;li[1]&#x2F;a&#39;).click()</span><br><span class="line">            # 点击确认删除</span><br><span class="line">            self.browser.find_element_by_xpath(&quot;&#x2F;&#x2F;*[@id]&#x2F;div&#x2F;p[2]&#x2F;a[1]&#x2F;span&quot;).click()</span><br><span class="line">        self.browser.close()</span><br><span class="line">        print(&#39;微博已经清空&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    starttime &#x3D; time.time()</span><br><span class="line">    weiboCrawler &#x3D; WeiboCrawler()</span><br><span class="line">    n &#x3D; 20</span><br><span class="line">    weiboCrawler.login(&quot;微博账号&quot;, &quot;微博密码&quot;, n)</span><br><span class="line">    endtime &#x3D; time.time()</span><br><span class="line">    dtime &#x3D; endtime - starttime</span><br><span class="line">    print(&#39;删除完成&#39; + str(n) + &#39;篇微博&#39;)</span><br><span class="line">    print(&quot;程序运行时间：%.8s s&quot; % dtime)</span><br></pre></td></tr></table></figure>

<p>​    直接运行即可，主要就是模拟登录及拿到各个事件的标识并点击。有一个问题，点击登录按钮这里如果操作比较频繁，会弹出输入验证码的窗口，造成登录超时拿不到我的主页的标识。可以重复运行试一下，或者注释掉自动点击登录，多sleep几秒，然后手动点击登录窗并输入验证码。</p>
<p>运行结果如下，微博瞬间清静了很多：</p>
<blockquote>
<p>登陆成功<br>微博已经清空<br>删除完成20篇微博<br>程序运行时间：75.53805 s</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Flink%E7%9A%84miniCluster%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/09/Flink%E7%9A%84miniCluster%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" itemprop="url">Flink的miniCluster启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-09T16:19:13+08:00">
                2020-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>flink的PipelineExecutor分为远程和本地，以本地环境为例，看下miniCluster启动过程。入口在本地环境LocalExecutor的excute方法里。先根据streamGraph生成JobGraph，再启动MiniCluster，然后将JobGraph提交至MiniCluster。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;JobClient&gt; execute(Pipeline pipeline, Configuration configuration) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   final JobGraph jobGraph &#x3D; getJobGraph(pipeline, configuration);</span><br><span class="line">   final MiniCluster miniCluster &#x3D; startMiniCluster(jobGraph, configuration);</span><br><span class="line">   final MiniClusterClient clusterClient &#x3D; new MiniClusterClient(configuration, miniCluster);</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;JobID&gt; jobIdFuture &#x3D; clusterClient.submitJob(jobGraph);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下startMiniCluster的过程，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private MiniCluster startMiniCluster(final JobGraph jobGraph, final Configuration configuration) throws Exception &#123;</span><br><span class="line">   if (!configuration.contains(RestOptions.BIND_PORT)) &#123;</span><br><span class="line">      configuration.setString(RestOptions.BIND_PORT, &quot;0&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;要启动的TaskManager个数，由local.number-taskmanager配置，默认为1</span><br><span class="line">   int numTaskManagers &#x3D; configuration.getInteger(</span><br><span class="line">         ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,</span><br><span class="line">         ConfigConstants.DEFAULT_LOCAL_NUMBER_TASK_MANAGER);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we have to use the maximum parallelism as a default here, otherwise streaming</span><br><span class="line">   &#x2F;&#x2F; pipelines would not run</span><br><span class="line">   &#x2F;&#x2F;每个TaskManager的slot的数量，默认最大并行度</span><br><span class="line">   int numSlotsPerTaskManager &#x3D; configuration.getInteger(</span><br><span class="line">         TaskManagerOptions.NUM_TASK_SLOTS,</span><br><span class="line">         jobGraph.getMaximumParallelism());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置参数</span><br><span class="line">   final MiniClusterConfiguration miniClusterConfiguration &#x3D;</span><br><span class="line">         new MiniClusterConfiguration.Builder()</span><br><span class="line">               .setConfiguration(configuration)</span><br><span class="line">               .setNumTaskManagers(numTaskManagers)</span><br><span class="line">               .setRpcServiceSharing(RpcServiceSharing.SHARED)</span><br><span class="line">               .setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动集群</span><br><span class="line">   final MiniCluster miniCluster &#x3D; new MiniCluster(miniClusterConfiguration);</span><br><span class="line">   miniCluster.start();</span><br><span class="line"></span><br><span class="line">   configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());</span><br><span class="line"></span><br><span class="line">   return miniCluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MiniCluster类构造函数，定义了组件个数及超时时间等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) &#123;</span><br><span class="line">   this.miniClusterConfiguration &#x3D; checkNotNull(miniClusterConfiguration, &quot;config may not be null&quot;);</span><br><span class="line">   &#x2F;&#x2F;需要启动的服务个数，common + JM + RM + TMs,commonRpcService用来进行一些额外的调用，比如获取metric等</span><br><span class="line">   this.rpcServices &#x3D; new ArrayList&lt;&gt;(1 + 2 + miniClusterConfiguration.getNumTaskManagers()); &#x2F;&#x2F; common + JM + RM + TMs</span><br><span class="line">   this.dispatcherResourceManagerComponents &#x3D; new ArrayList&lt;&gt;(1);</span><br><span class="line"></span><br><span class="line">   this.rpcTimeout &#x3D; miniClusterConfiguration.getRpcTimeout();</span><br><span class="line">   this.terminationFuture &#x3D; CompletableFuture.completedFuture(null);</span><br><span class="line">   running &#x3D; false;</span><br><span class="line"></span><br><span class="line">   this.taskManagers &#x3D; new ArrayList&lt;&gt;(miniClusterConfiguration.getNumTaskManagers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MiniCluster类的start函数，启动MiniCluster的各个组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws Exception &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      checkState(!running, &quot;MiniCluster is already running&quot;);</span><br><span class="line"></span><br><span class="line">      LOG.info(&quot;Starting Flink Mini Cluster&quot;);</span><br><span class="line">      LOG.debug(&quot;Using configuration &#123;&#125;&quot;, miniClusterConfiguration);</span><br><span class="line"></span><br><span class="line">      final Configuration configuration &#x3D; miniClusterConfiguration.getConfiguration();</span><br><span class="line">      final boolean useSingleRpcService &#x3D; miniClusterConfiguration.getRpcServiceSharing() &#x3D;&#x3D; RpcServiceSharing.SHARED;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         initializeIOFormatClasses(configuration);</span><br><span class="line"></span><br><span class="line">         LOG.info(&quot;Starting Metrics Registry&quot;);</span><br><span class="line">         metricRegistry &#x3D; createMetricRegistry(configuration);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; bring up all the RPC services</span><br><span class="line">         LOG.info(&quot;Starting RPC Service(s)&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;akka的Rpc服务</span><br><span class="line">         AkkaRpcServiceConfiguration akkaRpcServiceConfig &#x3D; AkkaRpcServiceConfiguration.fromConfiguration(configuration);</span><br><span class="line"></span><br><span class="line">         final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果只用一个Rpc服务，则所有组件起在一个服务里</span><br><span class="line">         if (useSingleRpcService) &#123;</span><br><span class="line">            &#x2F;&#x2F; we always need the &#39;commonRpcService&#39; for auxiliary calls</span><br><span class="line">            commonRpcService &#x3D; createRpcService(akkaRpcServiceConfig, false, null);</span><br><span class="line">            final CommonRpcServiceFactory commonRpcServiceFactory &#x3D; new CommonRpcServiceFactory(commonRpcService);</span><br><span class="line">            taskManagerRpcServiceFactory &#x3D; commonRpcServiceFactory;</span><br><span class="line">            dispatcherResourceManagreComponentRpcServiceFactory &#x3D; commonRpcServiceFactory;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F;不同的组件分开部署</span><br><span class="line">            &#x2F;&#x2F; we always need the &#39;commonRpcService&#39; for auxiliary calls</span><br><span class="line">            commonRpcService &#x3D; createRpcService(akkaRpcServiceConfig, true, null);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; start a new service per component, possibly with custom bind addresses</span><br><span class="line">            final String jobManagerBindAddress &#x3D; miniClusterConfiguration.getJobManagerBindAddress();</span><br><span class="line">            final String taskManagerBindAddress &#x3D; miniClusterConfiguration.getTaskManagerBindAddress();</span><br><span class="line"></span><br><span class="line">            dispatcherResourceManagreComponentRpcServiceFactory &#x3D; new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress);</span><br><span class="line">            taskManagerRpcServiceFactory &#x3D; new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;metric查询服务</span><br><span class="line">         RpcService metricQueryServiceRpcService &#x3D; MetricUtils.startMetricsRpcService(</span><br><span class="line">            configuration,</span><br><span class="line">            commonRpcService.getAddress());</span><br><span class="line">         metricRegistry.startQueryService(metricQueryServiceRpcService, null);</span><br><span class="line"></span><br><span class="line">         processMetricGroup &#x3D; MetricUtils.instantiateProcessMetricGroup(</span><br><span class="line">            metricRegistry,</span><br><span class="line">            RpcUtils.getHostname(commonRpcService),</span><br><span class="line">            ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建高可用HA服务</span><br><span class="line">         ioExecutor &#x3D; Executors.newFixedThreadPool(</span><br><span class="line">            Hardware.getNumberCPUCores(),</span><br><span class="line">            new ExecutorThreadFactory(&quot;mini-cluster-io&quot;));</span><br><span class="line">         haServices &#x3D; createHighAvailabilityServices(configuration, ioExecutor);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动blobServer</span><br><span class="line">         blobServer &#x3D; new BlobServer(configuration, haServices.createBlobStore());</span><br><span class="line">         blobServer.start();</span><br><span class="line"></span><br><span class="line">         heartbeatServices &#x3D; HeartbeatServices.fromConfiguration(configuration);</span><br><span class="line"></span><br><span class="line">         blobCacheService &#x3D; new BlobCacheService(</span><br><span class="line">            configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())</span><br><span class="line">         );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动TaskManager</span><br><span class="line">         startTaskManagers();</span><br><span class="line"></span><br><span class="line">         MetricQueryServiceRetriever metricQueryServiceRetriever &#x3D; new RpcMetricQueryServiceRetriever(metricRegistry.getMetricQueryServiceRpcService());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建DispatcherResourceManager</span><br><span class="line">         setupDispatcherResourceManagerComponents(configuration, dispatcherResourceManagreComponentRpcServiceFactory, metricQueryServiceRetriever);</span><br><span class="line"></span><br><span class="line">         resourceManagerLeaderRetriever &#x3D; haServices.getResourceManagerLeaderRetriever();</span><br><span class="line">         dispatcherLeaderRetriever &#x3D; haServices.getDispatcherLeaderRetriever();</span><br><span class="line">         clusterRestEndpointLeaderRetrievalService &#x3D; haServices.getClusterRestEndpointLeaderRetriever();</span><br><span class="line"></span><br><span class="line">         dispatcherGatewayRetriever &#x3D; new RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">            commonRpcService,</span><br><span class="line">            DispatcherGateway.class,</span><br><span class="line">            DispatcherId::fromUuid,</span><br><span class="line">            20,</span><br><span class="line">            Time.milliseconds(20L));</span><br><span class="line">         resourceManagerGatewayRetriever &#x3D; new RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">            commonRpcService,</span><br><span class="line">            ResourceManagerGateway.class,</span><br><span class="line">            ResourceManagerId::fromUuid,</span><br><span class="line">            20,</span><br><span class="line">            Time.milliseconds(20L));</span><br><span class="line">         webMonitorLeaderRetriever &#x3D; new LeaderRetriever();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动resourceManager及dispatcher</span><br><span class="line">         resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever);</span><br><span class="line">         dispatcherLeaderRetriever.start(dispatcherGatewayRetriever);</span><br><span class="line">         clusterRestEndpointLeaderRetrievalService.start(webMonitorLeaderRetriever);</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下上面过程中的部分服务的启动，首先是创建<code>HighAvailabilityServices</code>，根据配置的HA模式来实现不同的HA类，如果没有配置则使用EmbeddedHaServices。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected HighAvailabilityServices createHighAvailabilityServices(Configuration configuration, Executor executor) throws Exception &#123;</span><br><span class="line">   LOG.info(&quot;Starting high-availability services&quot;);</span><br><span class="line">   return HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(</span><br><span class="line">      configuration,</span><br><span class="line">      executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HighAvailabilityServicesUtils &#123;</span><br><span class="line"></span><br><span class="line">	public static HighAvailabilityServices createAvailableOrEmbeddedServices(</span><br><span class="line">		Configuration config,</span><br><span class="line">		Executor executor) throws Exception &#123;</span><br><span class="line">		HighAvailabilityMode highAvailabilityMode &#x3D; HighAvailabilityMode.fromConfig(config);</span><br><span class="line"></span><br><span class="line">		switch (highAvailabilityMode) &#123;</span><br><span class="line">			case NONE:</span><br><span class="line">				return new EmbeddedHaServices(executor);</span><br><span class="line"></span><br><span class="line">			case ZOOKEEPER:</span><br><span class="line">				BlobStoreService blobStoreService &#x3D; BlobUtils.createBlobStoreFromConfig(config);</span><br><span class="line"></span><br><span class="line">				return new ZooKeeperHaServices(</span><br><span class="line">					ZooKeeperUtils.startCuratorFramework(config),</span><br><span class="line">					executor,</span><br><span class="line">					config,</span><br><span class="line">					blobStoreService);</span><br><span class="line"></span><br><span class="line">			case FACTORY_CLASS:</span><br><span class="line">				return createCustomHAServices(config, executor);</span><br><span class="line"></span><br><span class="line">			default:</span><br><span class="line">				throw new Exception(&quot;High availability mode &quot; + highAvailabilityMode + &quot; is not supported.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接着是startTaskManagers，根据配置的numTaskManagers数量调用startTaskExecutor，<code>TaskManagerRunner#startTaskManager</code> 会创建一个 <code>TaskExecutor</code>, <code>TaskExecutor</code> 实现了 <code>RpcEndpoint</code>接口。 <code>TaskExecutor</code> 需要和 <code>ResourceManager</code> 等组件进行通信，可以通过 <code>HighAvailabilityServices</code>获得对应的服务地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void startTaskManagers() throws Exception &#123;</span><br><span class="line">   final int numTaskManagers &#x3D; miniClusterConfiguration.getNumTaskManagers();</span><br><span class="line"></span><br><span class="line">   LOG.info(&quot;Starting &#123;&#125; TaskManger(s)&quot;, numTaskManagers);</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; numTaskManagers; i++) &#123;</span><br><span class="line">      startTaskExecutor();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void startTaskExecutor() throws Exception &#123;</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			final Configuration configuration &#x3D; miniClusterConfiguration.getConfiguration();</span><br><span class="line"></span><br><span class="line">			final TaskExecutor taskExecutor &#x3D; TaskManagerRunner.startTaskManager(</span><br><span class="line">				configuration,</span><br><span class="line">				new ResourceID(UUID.randomUUID().toString()),</span><br><span class="line">				taskManagerRpcServiceFactory.createRpcService(),</span><br><span class="line">				haServices,</span><br><span class="line">				heartbeatServices,</span><br><span class="line">				metricRegistry,</span><br><span class="line">				blobCacheService,</span><br><span class="line">				useLocalCommunication(),</span><br><span class="line">				taskManagerTerminatingFatalErrorHandlerFactory.create(taskManagers.size()));</span><br><span class="line"></span><br><span class="line">			taskExecutor.start();</span><br><span class="line">			taskManagers.add(taskExecutor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManagerRunner#startTaskManager</code>,创建TaskExecutor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static TaskExecutor startTaskManager(</span><br><span class="line">      Configuration configuration,</span><br><span class="line">      ResourceID resourceID,</span><br><span class="line">      RpcService rpcService,</span><br><span class="line">      HighAvailabilityServices highAvailabilityServices,</span><br><span class="line">      HeartbeatServices heartbeatServices,</span><br><span class="line">      MetricRegistry metricRegistry,</span><br><span class="line">      BlobCacheService blobCacheService,</span><br><span class="line">      boolean localCommunicationOnly,</span><br><span class="line">      FatalErrorHandler fatalErrorHandler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   InetAddress remoteAddress &#x3D; InetAddress.getByName(rpcService.getAddress());</span><br><span class="line"></span><br><span class="line">   final TaskExecutorResourceSpec taskExecutorResourceSpec &#x3D; TaskExecutorResourceUtils.resourceSpecFromConfig(configuration);</span><br><span class="line"></span><br><span class="line">   TaskManagerServicesConfiguration taskManagerServicesConfiguration &#x3D;</span><br><span class="line">      TaskManagerServicesConfiguration.fromConfiguration(</span><br><span class="line">         configuration,</span><br><span class="line">         resourceID,</span><br><span class="line">         remoteAddress,</span><br><span class="line">         localCommunicationOnly,</span><br><span class="line">         taskExecutorResourceSpec);</span><br><span class="line"></span><br><span class="line">   Tuple2&lt;TaskManagerMetricGroup, MetricGroup&gt; taskManagerMetricGroup &#x3D; MetricUtils.instantiateTaskManagerMetricGroup(</span><br><span class="line">      metricRegistry,</span><br><span class="line">      TaskManagerLocation.getHostName(remoteAddress),</span><br><span class="line">      resourceID,</span><br><span class="line">      taskManagerServicesConfiguration.getSystemResourceMetricsProbingInterval());</span><br><span class="line"></span><br><span class="line">   TaskManagerServices taskManagerServices &#x3D; TaskManagerServices.fromConfiguration(</span><br><span class="line">      taskManagerServicesConfiguration,</span><br><span class="line">      taskManagerMetricGroup.f1,</span><br><span class="line">      rpcService.getExecutor()); &#x2F;&#x2F; TODO replace this later with some dedicated executor for io.</span><br><span class="line"></span><br><span class="line">   TaskManagerConfiguration taskManagerConfiguration &#x3D;</span><br><span class="line">      TaskManagerConfiguration.fromConfiguration(configuration, taskExecutorResourceSpec);</span><br><span class="line"></span><br><span class="line">   String metricQueryServiceAddress &#x3D; metricRegistry.getMetricQueryServiceGatewayRpcAddress();</span><br><span class="line"></span><br><span class="line">   return new TaskExecutor(</span><br><span class="line">      rpcService,</span><br><span class="line">      taskManagerConfiguration,</span><br><span class="line">      highAvailabilityServices,</span><br><span class="line">      taskManagerServices,</span><br><span class="line">      heartbeatServices,</span><br><span class="line">      taskManagerMetricGroup.f0,</span><br><span class="line">      metricQueryServiceAddress,</span><br><span class="line">      blobCacheService,</span><br><span class="line">      fatalErrorHandler,</span><br><span class="line">      new TaskExecutorPartitionTrackerImpl(taskManagerServices.getShuffleEnvironment()),</span><br><span class="line">      createBackPressureSampleService(configuration, rpcService.getScheduledExecutor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskExecutor实现了RpcEndpoint，创建TaskExecutor之后调用RpcEndpoint的start启动akkaRpcActor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway</span><br></pre></td></tr></table></figure>

<p>启动akkaRpcActor成功会调用TaskExecutor的回调函数onStart，建立一系列连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStart() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      startTaskExecutorServices();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      final TaskManagerException exception &#x3D; new TaskManagerException(String.format(&quot;Could not start the TaskExecutor %s&quot;, getAddress()), e);</span><br><span class="line">      onFatalError(exception);</span><br><span class="line">      throw exception;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   startRegistrationTimeout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void startTaskExecutorServices() throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; start by connecting to the ResourceManager</span><br><span class="line">			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; tell the task slot table who&#39;s responsible for the task slot actions</span><br><span class="line">			taskSlotTable.start(new SlotActionsImpl(), getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; start the job leader service</span><br><span class="line">			jobLeaderService.start(getAddress(), getRpcService(), haServices, new JobLeaderListenerImpl());</span><br><span class="line"></span><br><span class="line">			fileCache &#x3D; new FileCache(taskManagerConfiguration.getTmpDirectories(), blobCacheService.getPermanentBlobService());</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			handleStartTaskExecutorServicesException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private final class ResourceManagerLeaderListener implements LeaderRetrievalListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void notifyLeaderAddress(final String leaderAddress, final UUID leaderSessionID) &#123;</span><br><span class="line">			runAsync(</span><br><span class="line">			&#x2F;&#x2F;与ResourceManager建立连接</span><br><span class="line">				() -&gt; notifyOfNewResourceManagerLeader(</span><br><span class="line">					leaderAddress,</span><br><span class="line">					ResourceManagerId.fromUuidOrNull(leaderSessionID)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void handleError(Exception exception) &#123;</span><br><span class="line">			onFatalError(exception);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private final class JobLeaderListenerImpl implements JobLeaderListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void jobManagerGainedLeadership(</span><br><span class="line">			final JobID jobId,</span><br><span class="line">			final JobMasterGateway jobManagerGateway,</span><br><span class="line">			final JMTMRegistrationSuccess registrationMessage) &#123;</span><br><span class="line">			runAsync(</span><br><span class="line">				() -&gt;</span><br><span class="line">				&#x2F;&#x2F;与JobManager的leader节点建立连接</span><br><span class="line">					establishJobManagerConnection(</span><br><span class="line">						jobId,</span><br><span class="line">						jobManagerGateway,</span><br><span class="line">						registrationMessage));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void jobManagerLostLeadership(final JobID jobId, final JobMasterId jobMasterId) &#123;</span><br><span class="line">			log.info(&quot;JobManager for job &#123;&#125; with leader id &#123;&#125; lost leadership.&quot;, jobId, jobMasterId);</span><br><span class="line"></span><br><span class="line">			runAsync(() -&gt;</span><br><span class="line">				closeJobManagerConnection(</span><br><span class="line">					jobId,</span><br><span class="line">					new Exception(&quot;Job leader for job id &quot; + jobId + &quot; lost leadership.&quot;)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void handleError(Throwable throwable) &#123;</span><br><span class="line">			onFatalError(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>ResourceManagerLeaderListener</code> 的监听被回调时，<code>TaskExecutor</code> 会试图建立和 <code>ResourceManager</code> 的连接，连接被封装为 <code>TaskExecutorToResourceManagerConnection</code>。一旦获取 <code>ResourceManager</code> 的 leader 被确定后，就可以获取到 <code>ResourceManager</code> 对应的 RpcGateway， 接下来就可以通过 RPC 调用发起 <code>ResourceManager#registerTaskExecutor</code> 注册流程。注册成功后，回调onRegistrationSuccess方法，<code>TaskExecutor</code> 向 <code>ResourceManager</code> 报告其资源（主要是 slots）情况，并建立连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">private void connectToResourceManager() &#123;</span><br><span class="line">   assert(resourceManagerAddress !&#x3D; null);</span><br><span class="line">   assert(establishedResourceManagerConnection &#x3D;&#x3D; null);</span><br><span class="line">   assert(resourceManagerConnection &#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Connecting to ResourceManager &#123;&#125;.&quot;, resourceManagerAddress);</span><br><span class="line"></span><br><span class="line">   final TaskExecutorRegistration taskExecutorRegistration &#x3D; new TaskExecutorRegistration(</span><br><span class="line">      getAddress(),</span><br><span class="line">      getResourceID(),</span><br><span class="line">      taskManagerLocation.dataPort(),</span><br><span class="line">      hardwareDescription,</span><br><span class="line">      taskManagerConfiguration.getDefaultSlotResourceProfile(),</span><br><span class="line">      taskManagerConfiguration.getTotalResourceProfile()</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   resourceManagerConnection &#x3D;</span><br><span class="line">      new TaskExecutorToResourceManagerConnection(</span><br><span class="line">         log,</span><br><span class="line">         getRpcService(),</span><br><span class="line">         taskManagerConfiguration.getRetryingRegistrationConfiguration(),</span><br><span class="line">         resourceManagerAddress.getAddress(),</span><br><span class="line">         resourceManagerAddress.getResourceManagerId(),</span><br><span class="line">         getMainThreadExecutor(),</span><br><span class="line">         new ResourceManagerRegistrationListener(),</span><br><span class="line">         taskExecutorRegistration);</span><br><span class="line">   resourceManagerConnection.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resourceManagerConnection.start()方法：</span><br><span class="line">public void start() &#123;</span><br><span class="line">		checkState(!closed, &quot;The RPC connection is already closed&quot;);</span><br><span class="line">		checkState(!isConnected() &amp;&amp; pendingRegistration &#x3D;&#x3D; null, &quot;The RPC connection is already started&quot;);</span><br><span class="line"></span><br><span class="line">		final RetryingRegistration&lt;F, G, S&gt; newRegistration &#x3D; createNewRegistration();</span><br><span class="line"></span><br><span class="line">		if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">			newRegistration.startRegistration();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;&#x2F; concurrent start operation</span><br><span class="line">			newRegistration.cancel();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">createNewRegistration方法：</span><br><span class="line">private RetryingRegistration&lt;F, G, S&gt; createNewRegistration() &#123;</span><br><span class="line">		RetryingRegistration&lt;F, G, S&gt; newRegistration &#x3D; checkNotNull(generateRegistration());</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Tuple2&lt;G, S&gt;&gt; future &#x3D; newRegistration.getFuture();</span><br><span class="line"></span><br><span class="line">		future.whenCompleteAsync(</span><br><span class="line">			(Tuple2&lt;G, S&gt; result, Throwable failure) -&gt; &#123;</span><br><span class="line">				if (failure !&#x3D; null) &#123;</span><br><span class="line">					if (failure instanceof CancellationException) &#123;</span><br><span class="line">						&#x2F;&#x2F; we ignore cancellation exceptions because they originate from cancelling</span><br><span class="line">						&#x2F;&#x2F; the RetryingRegistration</span><br><span class="line">						log.debug(&quot;Retrying registration towards &#123;&#125; was cancelled.&quot;, targetAddress);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						&#x2F;&#x2F; this future should only ever fail if there is a bug, not if the registration is declined</span><br><span class="line">						onRegistrationFailure(failure);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					targetGateway &#x3D; result.f0;</span><br><span class="line">					onRegistrationSuccess(result.f1);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, executor);</span><br><span class="line"></span><br><span class="line">		return newRegistration;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;generateRegistration方法</span><br><span class="line">@Override</span><br><span class="line">	protected RetryingRegistration&lt;ResourceManagerId, ResourceManagerGateway, TaskExecutorRegistrationSuccess&gt; generateRegistration() &#123;</span><br><span class="line">		return new TaskExecutorToResourceManagerConnection.ResourceManagerRegistration(</span><br><span class="line">			log,</span><br><span class="line">			rpcService,</span><br><span class="line">			getTargetAddress(),</span><br><span class="line">			getTargetLeaderId(),</span><br><span class="line">			retryingRegistrationConfiguration,</span><br><span class="line">			taskExecutorRegistration);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TaskExecutorToResourceManagerConnection类内部类：</span><br><span class="line">private static class ResourceManagerRegistration</span><br><span class="line">			extends RetryingRegistration&lt;ResourceManagerId, ResourceManagerGateway, TaskExecutorRegistrationSuccess&gt; &#123;</span><br><span class="line"></span><br><span class="line">		private final TaskExecutorRegistration taskExecutorRegistration;</span><br><span class="line"></span><br><span class="line">		ResourceManagerRegistration(</span><br><span class="line">				Logger log,</span><br><span class="line">				RpcService rpcService,</span><br><span class="line">				String targetAddress,</span><br><span class="line">				ResourceManagerId resourceManagerId,</span><br><span class="line">				RetryingRegistrationConfiguration retryingRegistrationConfiguration,</span><br><span class="line">				TaskExecutorRegistration taskExecutorRegistration) &#123;</span><br><span class="line"></span><br><span class="line">			super(log, rpcService, &quot;ResourceManager&quot;, ResourceManagerGateway.class, targetAddress, resourceManagerId, retryingRegistrationConfiguration);</span><br><span class="line">			this.taskExecutorRegistration &#x3D; taskExecutorRegistration;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</span><br><span class="line">				ResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">			Time timeout &#x3D; Time.milliseconds(timeoutMillis);</span><br><span class="line">			&#x2F;&#x2F;register taskExecutor</span><br><span class="line">			return resourceManager.registerTaskExecutor(</span><br><span class="line">				taskExecutorRegistration,</span><br><span class="line">				timeout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TaskExecutorToResourceManagerConnection类：</span><br><span class="line">&#x2F;&#x2F;完成上述Registration回调onRegistrationSuccess</span><br><span class="line">@Override</span><br><span class="line">	protected void onRegistrationSuccess(TaskExecutorRegistrationSuccess success) &#123;</span><br><span class="line">		log.info(&quot;Successful registration at resource manager &#123;&#125; under registration id &#123;&#125;.&quot;,</span><br><span class="line">			getTargetAddress(), success.getRegistrationId());</span><br><span class="line"></span><br><span class="line">		registrationListener.onRegistrationSuccess(this, success);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	TaskExecutor类内部的ResourceManagerRegistrationListener类：</span><br><span class="line">	public void onRegistrationSuccess(TaskExecutorToResourceManagerConnection connection, TaskExecutorRegistrationSuccess success) &#123;</span><br><span class="line">			final ResourceID resourceManagerId &#x3D; success.getResourceManagerId();</span><br><span class="line">			final InstanceID taskExecutorRegistrationId &#x3D; success.getRegistrationId();</span><br><span class="line">			final ClusterInformation clusterInformation &#x3D; success.getClusterInformation();</span><br><span class="line">			final ResourceManagerGateway resourceManagerGateway &#x3D; connection.getTargetGateway();</span><br><span class="line"></span><br><span class="line">			runAsync(</span><br><span class="line">				() -&gt; &#123;</span><br><span class="line">					&#x2F;&#x2F; filter out outdated connections</span><br><span class="line">					&#x2F;&#x2F;noinspection ObjectEquality</span><br><span class="line">					if (resourceManagerConnection &#x3D;&#x3D; connection) &#123;</span><br><span class="line">						establishResourceManagerConnection(</span><br><span class="line">							resourceManagerGateway,</span><br><span class="line">							resourceManagerId,</span><br><span class="line">							taskExecutorRegistrationId,</span><br><span class="line">							clusterInformation);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">private void establishResourceManagerConnection(</span><br><span class="line">			ResourceManagerGateway resourceManagerGateway,</span><br><span class="line">			ResourceID resourceManagerResourceId,</span><br><span class="line">			InstanceID taskExecutorRegistrationId,</span><br><span class="line">			ClusterInformation clusterInformation) &#123;</span><br><span class="line">&#x2F;&#x2F;发送SlotReport</span><br><span class="line">		final CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture &#x3D; resourceManagerGateway.sendSlotReport(</span><br><span class="line">			getResourceID(),</span><br><span class="line">			taskExecutorRegistrationId,</span><br><span class="line">			taskSlotTable.createSlotReport(getResourceID()),</span><br><span class="line">			taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">		slotReportResponseFuture.whenCompleteAsync(</span><br><span class="line">			(acknowledge, throwable) -&gt; &#123;</span><br><span class="line">				if (throwable !&#x3D; null) &#123;</span><br><span class="line">					reconnectToResourceManager(new TaskManagerException(&quot;Failed to send initial slot report to ResourceManager.&quot;, throwable));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; monitor the resource manager as heartbeat target</span><br><span class="line">		resourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget&lt;TaskExecutorHeartbeatPayload&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void receiveHeartbeat(ResourceID resourceID, TaskExecutorHeartbeatPayload heartbeatPayload) &#123;</span><br><span class="line">				resourceManagerGateway.heartbeatFromTaskManager(resourceID, heartbeatPayload);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void requestHeartbeat(ResourceID resourceID, TaskExecutorHeartbeatPayload heartbeatPayload) &#123;</span><br><span class="line">				&#x2F;&#x2F; the TaskManager won&#39;t send heartbeat requests to the ResourceManager</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; set the propagated blob server address</span><br><span class="line">		final InetSocketAddress blobServerAddress &#x3D; new InetSocketAddress(</span><br><span class="line">			clusterInformation.getBlobServerHostname(),</span><br><span class="line">			clusterInformation.getBlobServerPort());</span><br><span class="line"></span><br><span class="line">		blobCacheService.setBlobServerAddress(blobServerAddress);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;连接建立</span><br><span class="line">		establishedResourceManagerConnection &#x3D; new EstablishedResourceManagerConnection(</span><br><span class="line">			resourceManagerGateway,</span><br><span class="line">			resourceManagerResourceId,</span><br><span class="line">			taskExecutorRegistrationId);</span><br><span class="line"></span><br><span class="line">		stopRegistrationTimeout();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后，启动完taskmanager进入DispatcherResourceManagerComponent的启动过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void setupDispatcherResourceManagerComponents(Configuration configuration, RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory, MetricQueryServiceRetriever metricQueryServiceRetriever) throws Exception &#123;</span><br><span class="line">   dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(</span><br><span class="line">      configuration,</span><br><span class="line">      dispatcherResourceManagreComponentRpcServiceFactory,</span><br><span class="line">      haServices,</span><br><span class="line">      blobServer,</span><br><span class="line">      heartbeatServices,</span><br><span class="line">      metricRegistry,</span><br><span class="line">      metricQueryServiceRetriever,</span><br><span class="line">      new ShutDownFatalErrorHandler()</span><br><span class="line">   ));</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createDispatcherResourceManagerComponents:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Collection&lt;? extends DispatcherResourceManagerComponent&gt; createDispatcherResourceManagerComponents(</span><br><span class="line">      Configuration configuration,</span><br><span class="line">      RpcServiceFactory rpcServiceFactory,</span><br><span class="line">      HighAvailabilityServices haServices,</span><br><span class="line">      BlobServer blobServer,</span><br><span class="line">      HeartbeatServices heartbeatServices,</span><br><span class="line">      MetricRegistry metricRegistry,</span><br><span class="line">      MetricQueryServiceRetriever metricQueryServiceRetriever,</span><br><span class="line">      FatalErrorHandler fatalErrorHandler) throws Exception &#123;</span><br><span class="line">   DispatcherResourceManagerComponentFactory dispatcherResourceManagerComponentFactory &#x3D; createDispatcherResourceManagerComponentFactory();</span><br><span class="line">   return Collections.singleton(</span><br><span class="line">      dispatcherResourceManagerComponentFactory.create(</span><br><span class="line">         configuration,</span><br><span class="line">         ioExecutor,</span><br><span class="line">         rpcServiceFactory.createRpcService(),</span><br><span class="line">         haServices,</span><br><span class="line">         blobServer,</span><br><span class="line">         heartbeatServices,</span><br><span class="line">         metricRegistry,</span><br><span class="line">         new MemoryArchivedExecutionGraphStore(),</span><br><span class="line">         metricQueryServiceRetriever,</span><br><span class="line">         fatalErrorHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createDispatcherResourceManagerComponentFactory方法，分别得到Dispatcher，ResourceManager及restEndpoint组件的工厂类。分别是SessionDispatcherLeaderProcessFactoryFactory，StandaloneResourceManagerFactory以及SessionRestEndpointFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private DispatcherResourceManagerComponentFactory createDispatcherResourceManagerComponentFactory() &#123;</span><br><span class="line">   return DefaultDispatcherResourceManagerComponentFactory.createSessionComponentFactory(StandaloneResourceManagerFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static DefaultDispatcherResourceManagerComponentFactory createSessionComponentFactory(</span><br><span class="line">			ResourceManagerFactory&lt;?&gt; resourceManagerFactory) &#123;</span><br><span class="line">		return new DefaultDispatcherResourceManagerComponentFactory(</span><br><span class="line">			DefaultDispatcherRunnerFactory.createSessionRunner(SessionDispatcherFactory.INSTANCE),</span><br><span class="line">			resourceManagerFactory,</span><br><span class="line">			SessionRestEndpointFactory.INSTANCE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DefaultDispatcherResourceManagerComponentFactory(</span><br><span class="line">			@Nonnull DispatcherRunnerFactory dispatcherRunnerFactory,</span><br><span class="line">			@Nonnull ResourceManagerFactory&lt;?&gt; resourceManagerFactory,</span><br><span class="line">			@Nonnull RestEndpointFactory&lt;?&gt; restEndpointFactory) &#123;</span><br><span class="line">		this.dispatcherRunnerFactory &#x3D; dispatcherRunnerFactory;</span><br><span class="line">		this.resourceManagerFactory &#x3D; resourceManagerFactory;</span><br><span class="line">		this.restEndpointFactory &#x3D; restEndpointFactory;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultDispatcherResourceManagerComponentFactory类create方法创建Dispatcher，ResourceManager及restEndpoint组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public DispatcherResourceManagerComponent create(</span><br><span class="line">      Configuration configuration,</span><br><span class="line">      Executor ioExecutor,</span><br><span class="line">      RpcService rpcService,</span><br><span class="line">      HighAvailabilityServices highAvailabilityServices,</span><br><span class="line">      BlobServer blobServer,</span><br><span class="line">      HeartbeatServices heartbeatServices,</span><br><span class="line">      MetricRegistry metricRegistry,</span><br><span class="line">      ArchivedExecutionGraphStore archivedExecutionGraphStore,</span><br><span class="line">      MetricQueryServiceRetriever metricQueryServiceRetriever,</span><br><span class="line">      FatalErrorHandler fatalErrorHandler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   LeaderRetrievalService dispatcherLeaderRetrievalService &#x3D; null;</span><br><span class="line">   LeaderRetrievalService resourceManagerRetrievalService &#x3D; null;</span><br><span class="line">   WebMonitorEndpoint&lt;?&gt; webMonitorEndpoint &#x3D; null;</span><br><span class="line">   ResourceManager&lt;?&gt; resourceManager &#x3D; null;</span><br><span class="line">   ResourceManagerMetricGroup resourceManagerMetricGroup &#x3D; null;</span><br><span class="line">   DispatcherRunner dispatcherRunner &#x3D; null;</span><br><span class="line"></span><br><span class="line">      dispatcherLeaderRetrievalService &#x3D; highAvailabilityServices.getDispatcherLeaderRetriever();</span><br><span class="line"></span><br><span class="line">      resourceManagerRetrievalService &#x3D; highAvailabilityServices.getResourceManagerLeaderRetriever();</span><br><span class="line"></span><br><span class="line">      final LeaderGatewayRetriever&lt;DispatcherGateway&gt; dispatcherGatewayRetriever &#x3D; new RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">         rpcService,</span><br><span class="line">         DispatcherGateway.class,</span><br><span class="line">         DispatcherId::fromUuid,</span><br><span class="line">         10,</span><br><span class="line">         Time.milliseconds(50L));</span><br><span class="line"></span><br><span class="line">      final LeaderGatewayRetriever&lt;ResourceManagerGateway&gt; resourceManagerGatewayRetriever &#x3D; new RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">         rpcService,</span><br><span class="line">         ResourceManagerGateway.class,</span><br><span class="line">         ResourceManagerId::fromUuid,</span><br><span class="line">         10,</span><br><span class="line">         Time.milliseconds(50L));</span><br><span class="line"></span><br><span class="line">      final ExecutorService executor &#x3D; WebMonitorEndpoint.createExecutorService(</span><br><span class="line">         configuration.getInteger(RestOptions.SERVER_NUM_THREADS),</span><br><span class="line">         configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),</span><br><span class="line">         &quot;DispatcherRestEndpoint&quot;);</span><br><span class="line"></span><br><span class="line">      final long updateInterval &#x3D; configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL);</span><br><span class="line">      final MetricFetcher metricFetcher &#x3D; updateInterval &#x3D;&#x3D; 0</span><br><span class="line">         ? VoidMetricFetcher.INSTANCE</span><br><span class="line">         : MetricFetcherImpl.fromConfiguration(</span><br><span class="line">            configuration,</span><br><span class="line">            metricQueryServiceRetriever,</span><br><span class="line">            dispatcherGatewayRetriever,</span><br><span class="line">            executor);</span><br><span class="line"></span><br><span class="line">      webMonitorEndpoint &#x3D; restEndpointFactory.createRestEndpoint(</span><br><span class="line">         configuration,</span><br><span class="line">         dispatcherGatewayRetriever,</span><br><span class="line">         resourceManagerGatewayRetriever,</span><br><span class="line">         blobServer,</span><br><span class="line">         executor,</span><br><span class="line">         metricFetcher,</span><br><span class="line">         highAvailabilityServices.getClusterRestEndpointLeaderElectionService(),</span><br><span class="line">         fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">      log.debug(&quot;Starting Dispatcher REST endpoint.&quot;);</span><br><span class="line">      webMonitorEndpoint.start();</span><br><span class="line"></span><br><span class="line">      final String hostname &#x3D; RpcUtils.getHostname(rpcService);</span><br><span class="line"></span><br><span class="line">      resourceManagerMetricGroup &#x3D; ResourceManagerMetricGroup.create(metricRegistry, hostname);</span><br><span class="line">      resourceManager &#x3D; resourceManagerFactory.createResourceManager(</span><br><span class="line">         configuration,</span><br><span class="line">         ResourceID.generate(),</span><br><span class="line">         rpcService,</span><br><span class="line">         highAvailabilityServices,</span><br><span class="line">         heartbeatServices,</span><br><span class="line">         fatalErrorHandler,</span><br><span class="line">         new ClusterInformation(hostname, blobServer.getPort()),</span><br><span class="line">         webMonitorEndpoint.getRestBaseUrl(),</span><br><span class="line">         resourceManagerMetricGroup);</span><br><span class="line"></span><br><span class="line">      final HistoryServerArchivist historyServerArchivist &#x3D; HistoryServerArchivist.createHistoryServerArchivist(configuration, webMonitorEndpoint);</span><br><span class="line"></span><br><span class="line">      final PartialDispatcherServices partialDispatcherServices &#x3D; new PartialDispatcherServices(</span><br><span class="line">         configuration,</span><br><span class="line">         highAvailabilityServices,</span><br><span class="line">         resourceManagerGatewayRetriever,</span><br><span class="line">         blobServer,</span><br><span class="line">         heartbeatServices,</span><br><span class="line">         () -&gt; MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, hostname),</span><br><span class="line">         archivedExecutionGraphStore,</span><br><span class="line">         fatalErrorHandler,</span><br><span class="line">         historyServerArchivist,</span><br><span class="line">         metricRegistry.getMetricQueryServiceGatewayRpcAddress());</span><br><span class="line"></span><br><span class="line">      log.debug(&quot;Starting Dispatcher.&quot;);</span><br><span class="line">      dispatcherRunner &#x3D; dispatcherRunnerFactory.createDispatcherRunner(</span><br><span class="line">         highAvailabilityServices.getDispatcherLeaderElectionService(),</span><br><span class="line">         fatalErrorHandler,</span><br><span class="line">         new HaServicesJobGraphStoreFactory(highAvailabilityServices),</span><br><span class="line">         ioExecutor,</span><br><span class="line">         rpcService,</span><br><span class="line">         partialDispatcherServices);</span><br><span class="line"></span><br><span class="line">      log.debug(&quot;Starting ResourceManager.&quot;);</span><br><span class="line">      resourceManager.start();</span><br><span class="line"></span><br><span class="line">      resourceManagerRetrievalService.start(resourceManagerGatewayRetriever);</span><br><span class="line">      dispatcherLeaderRetrievalService.start(dispatcherGatewayRetriever);</span><br><span class="line"></span><br><span class="line">      return new DispatcherResourceManagerComponent(</span><br><span class="line">         dispatcherRunner,</span><br><span class="line">         resourceManager,</span><br><span class="line">         dispatcherLeaderRetrievalService,</span><br><span class="line">         resourceManagerRetrievalService,</span><br><span class="line">         webMonitorEndpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Starting Dispatcher REST endpoint，Dispatcher REST为WebMonitorEndpoint类继承自RestServerEndpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class WebMonitorEndpoint&lt;T extends RestfulGateway&gt; extends RestServerEndpoint implements LeaderContender, JsonArchivist</span><br></pre></td></tr></table></figure>

<p>Starting Dispatcher，创建DispatcherRunner，由LeaderElectionService启动DispatcherRunner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public DispatcherRunner createDispatcherRunner(</span><br><span class="line">      LeaderElectionService leaderElectionService,</span><br><span class="line">      FatalErrorHandler fatalErrorHandler,</span><br><span class="line">      JobGraphStoreFactory jobGraphStoreFactory,</span><br><span class="line">      Executor ioExecutor,</span><br><span class="line">      RpcService rpcService,</span><br><span class="line">      PartialDispatcherServices partialDispatcherServices) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   final DispatcherLeaderProcessFactory dispatcherLeaderProcessFactory &#x3D; dispatcherLeaderProcessFactoryFactory.createFactory(</span><br><span class="line">      jobGraphStoreFactory,</span><br><span class="line">      ioExecutor,</span><br><span class="line">      rpcService,</span><br><span class="line">      partialDispatcherServices,</span><br><span class="line">      fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">   return DefaultDispatcherRunner.create(</span><br><span class="line">      leaderElectionService,</span><br><span class="line">      fatalErrorHandler,</span><br><span class="line">      dispatcherLeaderProcessFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static DispatcherRunner create(</span><br><span class="line">			LeaderElectionService leaderElectionService,</span><br><span class="line">			FatalErrorHandler fatalErrorHandler,</span><br><span class="line">			DispatcherLeaderProcessFactory dispatcherLeaderProcessFactory) throws Exception &#123;</span><br><span class="line">		final DefaultDispatcherRunner dispatcherRunner &#x3D; new DefaultDispatcherRunner(</span><br><span class="line">			leaderElectionService,</span><br><span class="line">			fatalErrorHandler,</span><br><span class="line">			dispatcherLeaderProcessFactory);</span><br><span class="line">		return DispatcherRunnerLeaderElectionLifecycleManager.createFor(dispatcherRunner, leaderElectionService);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">private DispatcherRunnerLeaderElectionLifecycleManager(T dispatcherRunner, LeaderElectionService leaderElectionService) throws Exception &#123;</span><br><span class="line">		this.dispatcherRunner &#x3D; dispatcherRunner;</span><br><span class="line">		this.leaderElectionService &#x3D; leaderElectionService;</span><br><span class="line"></span><br><span class="line">		leaderElectionService.start(dispatcherRunner);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Starting ResourceManager，ResourceManager继承自FencedRpcEndpoint即RpcEndpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceManager&lt;WorkerType extends ResourceIDRetrievable&gt;</span><br><span class="line">      extends FencedRpcEndpoint&lt;ResourceManagerId&gt;</span><br><span class="line">      implements ResourceManagerGateway, LeaderContender</span><br></pre></td></tr></table></figure>

<p>创建所有组件成功，返回DispatcherResourceManagerComponent类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DispatcherResourceManagerComponent(</span><br><span class="line">      @Nonnull DispatcherRunner dispatcherRunner,</span><br><span class="line">      @Nonnull ResourceManager&lt;?&gt; resourceManager,</span><br><span class="line">      @Nonnull LeaderRetrievalService dispatcherLeaderRetrievalService,</span><br><span class="line">      @Nonnull LeaderRetrievalService resourceManagerRetrievalService,</span><br><span class="line">      @Nonnull WebMonitorEndpoint&lt;?&gt; webMonitorEndpoint) &#123;</span><br><span class="line">   this.dispatcherRunner &#x3D; dispatcherRunner;</span><br><span class="line">   this.resourceManager &#x3D; resourceManager;</span><br><span class="line">   this.dispatcherLeaderRetrievalService &#x3D; dispatcherLeaderRetrievalService;</span><br><span class="line">   this.resourceManagerRetrievalService &#x3D; resourceManagerRetrievalService;</span><br><span class="line">   this.webMonitorEndpoint &#x3D; webMonitorEndpoint;</span><br><span class="line">   this.terminationFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">   this.shutDownFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   registerShutDownFuture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/" itemprop="url">flink的Elasticsearch的connector使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T16:44:49+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="flink-connector-elasticsearch介绍"><a href="#flink-connector-elasticsearch介绍" class="headerlink" title="flink-connector-elasticsearch介绍"></a>flink-connector-elasticsearch介绍</h3><p>在实际应用中，一些明细数据需要存入Elasticsearch来供使用方快速的查询。而flink内部集成了Elasticsearch的connector可以直接使用封装的api。这里通过示例记录一下flink任务写入es的sink的方式。</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/2.png" alt></p>
<p>可以看到flink支持es的各种版本，从2.x到7.x。然后高版本是可以兼容低版本的写入的。代码方面主要分成了5个module: flink-connector-elasticsearch2，flink-connector-elasticsearch5，flink-connector-elasticsearch6，flink-connector-elasticsearch7，flink-connector-elasticsearch-base。其中flink-connector-elasticsearch-base定义了通用的接口，其他module为不同版本的实现。</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/3.png" alt></p>
<p>上图是主要的代码结构，flink-connector-elasticsearch7与flink-connector-elasticsearch6的结构基本一致。可以看到flink-connector-elasticsearch6之后做了很多调整，封装也更加完善。下面主要看一下</p>
<p>flink-connector-elasticsearch的使用。</p>
<p>这里演示两种方式，一种是使用ElasticsearchSink API，这种方式需要自己实现ElasticsearchSinkFunction接口进行增删改。另一种方式是使用flink-connector-elasticsearch自己封装的ElasticsearchUpsertTableSink，这种使用方式比较简单，直接传入es集群的相关参数就可以了。传参的方式一种是使用 descriptor API，也就是 org.apache.flink.table.descriptors.Elasticsearch，通过tableApi进行connect。或者通过DDL直接定义。</p>
<h3 id="ElasticsearchSink"><a href="#ElasticsearchSink" class="headerlink" title="ElasticsearchSink"></a>ElasticsearchSink</h3><p>先看下ElasticsearchSink 的实现，分别比较一下5.x和6.x和7.x。</p>
<h4 id="ElasticsearchSink-5-x"><a href="#ElasticsearchSink-5-x" class="headerlink" title="ElasticsearchSink 5.x"></a>ElasticsearchSink 5.x</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line">properties.setProperty(&quot;bootstrap.servers&quot;, KAFKA_SERVERS);</span><br><span class="line">properties.setProperty(&quot;group.id&quot;, GROUP_ID);</span><br><span class="line">FlinkKafkaConsumer011&lt;String&gt; depponConsumer &#x3D; new FlinkKafkaConsumer011&lt;&gt;(KAFKA_TOPIC, new ExchangeDeserializer(), properties);</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; dataStream &#x3D; env.addSource(depponConsumer)</span><br><span class="line">DataStream&lt;FmsNetTob&gt; smsNetTobStream &#x3D; dataStream</span><br><span class="line">        .map(new DataMapFunction())</span><br><span class="line">        .addSink(buildEalsticSink());</span><br></pre></td></tr></table></figure>

<p>从kafka读取消息并进行清洗，然后写入es。看下buildEalsticSink方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchSink&lt;FmsNetTob&gt; buildEalsticSink() &#123;</span><br><span class="line">    Map&lt;String, String&gt; userConfig &#x3D; ElasticsearchConfigHelper.loadYmalConfig(&quot;elasticsearch.yml&quot;);</span><br><span class="line">    &#x2F;&#x2F; ES客户端封装</span><br><span class="line">    ElasticsearchApiCallBridge&lt;TransportClient&gt; bridge &#x3D; new Elasticsearch5ApiCallBridge(ElasticsearchConfigHelper.getCluster(Constants.ELASTIC_SERVERS));</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;重试策略</span><br><span class="line">    ActionRequestFailureHandler failureHandler &#x3D; new NoOpFailureHandler();</span><br><span class="line">    if(Constants.ELASTIC_FAILHANDLER) &#123;</span><br><span class="line">        failureHandler &#x3D; new RetryRejectedExecutionFailureHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;es</span><br><span class="line">    ElasticsearchSinkFunction&lt;FmsNetTob&gt; elasticSinkFunction &#x3D; new DepponSinkFunction(Constants.INDEX_NAME, Constants.INDEX_TYPE);</span><br><span class="line">    </span><br><span class="line">    ElasticsearchSink&lt;FmsNetTob&gt; elasticSink &#x3D; new ElasticsearchSink&lt;FmsNetTob&gt;(bridge, userConfig, elasticSinkFunction, failureHandler);</span><br><span class="line">    </span><br><span class="line">    return elasticSink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElasticsearchSink需要自定义Elasticsearch5ApiCallBridge，ElasticsearchSinkFunction，ActionRequestFailureHandler等类并传入ElasticsearchSink的构造函数。看下ElasticsearchSinkFunction的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DepponSinkFunction implements ElasticsearchSinkFunction&lt;FmsNetTob&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;索引名</span><br><span class="line">    private String index;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;type名</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public DepponSinkFunction(String index, String type) &#123;</span><br><span class="line">        this.index &#x3D; index;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void process(FmsNetTob source, RuntimeContext context, RequestIndexer indexer) &#123;</span><br><span class="line">        indexer.add(indexRequest(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IndexRequest indexRequest(FmsNetTob source) &#123;</span><br><span class="line">        JSONObject jsonSource &#x3D; (JSONObject) JSON.toJSON(source);</span><br><span class="line">        IndexRequest indexRequest &#x3D; Requests.indexRequest().index(index).type(type).source(jsonSource.toJSONString(), XContentType.JSON);</span><br><span class="line">        return indexRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现ElasticsearchSinkFunction接口的process方法实现es写入，es以id去重，插入时不指定id会随机生成一个id。插入结果如下：</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/1.png" alt></p>
<h4 id="ElasticsearchSink-6-x"><a href="#ElasticsearchSink-6-x" class="headerlink" title="ElasticsearchSink 6.x"></a>ElasticsearchSink 6.x</h4><p>使用相同的pipeline流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line">properties.setProperty(&quot;bootstrap.servers&quot;, KAFKA_SERVERS);</span><br><span class="line">properties.setProperty(&quot;group.id&quot;, GROUP_ID);</span><br><span class="line">FlinkKafkaConsumer011&lt;String&gt; depponConsumer &#x3D; new FlinkKafkaConsumer011&lt;&gt;(KAFKA_TOPIC, new ExchangeDeserializer(), properties);</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; dataStream &#x3D; env.addSource(depponConsumer)</span><br><span class="line">DataStream&lt;FmsNetTob&gt; smsNetTobStream &#x3D; dataStream</span><br><span class="line">        .map(new DataMapFunction())</span><br><span class="line">        .addSink(buildEalsticSink());</span><br></pre></td></tr></table></figure>

<p>区别主要在buildEalsticSink过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchSink&lt;FmsNetTob&gt; buildEalsticSink() &#123;</span><br><span class="line">    List&lt;HttpHost&gt; httpHosts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    httpHosts.add(new HttpHost(&quot;10.xxx.xxx.xxx&quot;, 9200, &quot;http&quot;));</span><br><span class="line">    httpHosts.add(new HttpHost(&quot;10.xxx.xxx.xxx&quot;, 9200, &quot;http&quot;));</span><br><span class="line">    httpHosts.add(new HttpHost(&quot;10.xxx.xxx.xxx&quot;, 9200, &quot;http&quot;));</span><br><span class="line"></span><br><span class="line">    ElasticsearchSink.Builder&lt;FmsNetTob&gt; esSinkBuilder &#x3D; new ElasticsearchSink.Builder&lt;FmsNetTob&gt;(</span><br><span class="line">            httpHosts, new DepponEsfunction(&quot;fms_net_tob&quot;, &quot;fms_net_tob_balance&quot;));</span><br><span class="line"></span><br><span class="line">    esSinkBuilder.setBulkFlushMaxActions(Constants.ELASTIC_BULK_FLUSH_MAX_ACTIONS);</span><br><span class="line">    esSinkBuilder.setBulkFlushInterval(Constants.ELASTIC_BULK_FLUSH_INTERVAL_MS);</span><br><span class="line">    esSinkBuilder.setBulkFlushMaxSizeMb(Constants.ELASTIC_BULK_FLUSH_MAX_SIZE_MB);</span><br><span class="line"></span><br><span class="line">    ActionRequestFailureHandler failureHandler;</span><br><span class="line">    if(Constants.ELASTIC_BULK_FLUSH_BACKOFF_ENABLE) &#123;</span><br><span class="line">        failureHandler &#x3D; new RetryRejectedExecutionFailureHandler();</span><br><span class="line">        esSinkBuilder.setBulkFlushBackoff(true);</span><br><span class="line">        esSinkBuilder.setFailureHandler(failureHandler);</span><br><span class="line">        esSinkBuilder.setBulkFlushBackoffDelay(Constants.ELASTIC_BULK_FLUSH_BACKOFF_DELAY);</span><br><span class="line">        esSinkBuilder.setBulkFlushBackoffRetries(Constants.ELASTIC_BULK_FLUSH_BACKOFF_RETRIES);</span><br><span class="line">        esSinkBuilder.setBulkFlushBackoffType(ElasticsearchSinkBase.FlushBackoffType.CONSTANT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return esSinkBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElasticsearchSink 6.x增加了Builder构造器，并且将Elasticsearch6ApiCallBridge批处理封装进了ElasticsearchSink内部。构造时只需添加set进需要的参数就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private ElasticsearchSink(</span><br><span class="line">   Map&lt;String, String&gt; bulkRequestsConfig,</span><br><span class="line">   List&lt;HttpHost&gt; httpHosts,</span><br><span class="line">   ElasticsearchSinkFunction&lt;T&gt; elasticsearchSinkFunction,</span><br><span class="line">   ActionRequestFailureHandler failureHandler,</span><br><span class="line">   RestClientFactory restClientFactory) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Elasticsearch6ApiCallBridge在初始化ElasticsearchSink时被内部初始化</span><br><span class="line">   super(new Elasticsearch6ApiCallBridge在初始化(httpHosts, restClientFactory),  bulkRequestsConfig, elasticsearchSinkFunction, failureHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElasticsearchSinkBase类的一些初始化和invoke方法，ElasticsearchSinkBase实现了RichSinkFunction和CheckpointedFunction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void open(Configuration parameters) throws Exception &#123;</span><br><span class="line">   client &#x3D; callBridge.createClient(userConfig);</span><br><span class="line">   &#x2F;&#x2F;构造批处理类</span><br><span class="line">   bulkProcessor &#x3D; buildBulkProcessor(new BulkProcessorListener());</span><br><span class="line">   requestIndexer &#x3D; callBridge.createBulkProcessorIndexer(bulkProcessor, flushOnCheckpoint, numPendingRequests);</span><br><span class="line">   failureRequestIndexer &#x3D; new BufferingNoOpRequestIndexer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void invoke(T value, Context context) throws Exception &#123;</span><br><span class="line">   checkAsyncErrorsAndRequests();</span><br><span class="line">   &#x2F;&#x2F;调用elasticsearchSinkFunction的具体process</span><br><span class="line">   elasticsearchSinkFunction.process(value, getRuntimeContext(), requestIndexer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void initializeState(FunctionInitializationContext context) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; no initialization needed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void snapshotState(FunctionSnapshotContext context) throws Exception &#123;</span><br><span class="line">   checkAsyncErrorsAndRequests();</span><br><span class="line">&#x2F;&#x2F;checkpoint的时候把批处理的数据刷进es</span><br><span class="line">   if (flushOnCheckpoint) &#123;</span><br><span class="line">      while (numPendingRequests.get() !&#x3D; 0) &#123;</span><br><span class="line">         bulkProcessor.flush();</span><br><span class="line">         checkAsyncErrorsAndRequests();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElasticsearchSinkFunction的实现与5.x基本一致。不再重述。</p>
<h4 id="ElasticsearchSink-7-x"><a href="#ElasticsearchSink-7-x" class="headerlink" title="ElasticsearchSink 7.x"></a>ElasticsearchSink 7.x</h4><p>ElasticsearchSink 7.x与6.x的使用是基本一致的，唯一的区别是ElasticsearchSink 7.x废弃了插入时的type参数，直接指定id进行插入和更新。</p>
<h3 id="descriptor-API"><a href="#descriptor-API" class="headerlink" title="descriptor API"></a>descriptor API</h3><p>ElasticsearchSink 6.x之后提供了ElasticsearchUpsertTableSink的封装，可以传入参数就可以实现es的插入和更新，无需再实现ElasticsearchSinkFunction。descriptor API的用法是通过tableApi来connect org.apache.flink.table.descriptors.Elasticsearch类，如下是一个示例，这里使用了flink的1.10的版本，废弃了registerTableSink\Source改用createTemporaryTable，废弃了deriveScheme方法等,zookeeper.connect也为必填参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(1);</span><br><span class="line">    StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    Schema schema &#x3D; new Schema()</span><br><span class="line">            .field(&quot;busyId&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;account&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;userMobile&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;expressCompanyName&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;expressCompanyCode&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;busyType&quot;, DataTypes.INT())</span><br><span class="line">            .field(&quot;gainMoney&quot;, DataTypes.DOUBLE())</span><br><span class="line">            .field(&quot;netInbillMoney&quot;, DataTypes.DOUBLE())</span><br><span class="line">            .field(&quot;inbillMoney&quot;, DataTypes.DOUBLE())</span><br><span class="line">            .field(&quot;payType&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;payTm&quot;, DataTypes.BIGINT())</span><br><span class="line">            .field(&quot;paySerialNumber&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;remark&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;userUicId&quot;, DataTypes.BIGINT())</span><br><span class="line">            .field(&quot;province&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;city&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;district&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;postId&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;edCode&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;throwAddress&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;expressId&quot;, DataTypes.STRING())</span><br><span class="line">            .field(&quot;boxType&quot;, DataTypes.INT())</span><br><span class="line">            .field(&quot;isRefund&quot;, DataTypes.INT())</span><br><span class="line">            .field(&quot;serviceName&quot;, DataTypes.STRING());</span><br><span class="line"></span><br><span class="line">    tableEnv.connect(</span><br><span class="line">            new Kafka()</span><br><span class="line">                    .topic(&quot;testtest1&quot;)</span><br><span class="line">                    .property(&quot;bootstrap.servers&quot;, &quot;10.xxx.xxx.xxx:9092,10.xxx.xxx.xxx:9092,10.xxx.xxx.xxx:9092&quot;)</span><br><span class="line">                    .property(&quot;group.id&quot;, &quot;test&quot;)</span><br><span class="line">                    .property(&quot;zookeeper.connect&quot;,&quot;10.xxx.xxx.xxx:2181,10.xxx.xxx.xxx:2181&quot;)</span><br><span class="line">                    .startFromLatest()</span><br><span class="line">                    .version(&quot;0.11&quot;)</span><br><span class="line">            )</span><br><span class="line">            .withSchema(schema)</span><br><span class="line">            .withFormat(new Json())</span><br><span class="line">            .createTemporaryTable(&quot;Users&quot;);</span><br><span class="line"></span><br><span class="line">    Table table &#x3D; tableEnv.from(&quot;Users&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; print</span><br><span class="line">    tableEnv.toAppendStream(table, TypeInformation.of(Row.class)).print();</span><br><span class="line"></span><br><span class="line">    tableEnv.connect(</span><br><span class="line">            new Elasticsearch()</span><br><span class="line">                    .version(&quot;6&quot;)</span><br><span class="line">                    .host(&quot;10.xxx.xxx.xxx&quot;, 9200, &quot;http&quot;)</span><br><span class="line">                    .index(&quot;fms_net_tob&quot;)</span><br><span class="line">                    &#x2F;&#x2F;文档</span><br><span class="line">                    .documentType(&quot;fms_net_tob_balance&quot;)</span><br><span class="line">                    &#x2F;&#x2F; key之间的分隔符，默认&quot;#&quot;</span><br><span class="line">                    .keyDelimiter(&quot;#&quot;)</span><br><span class="line">                    &#x2F;&#x2F; 如果key为null，则用&quot;&quot;字符串替代</span><br><span class="line">                    .keyNullLiteral(&quot;&quot;)</span><br><span class="line">                    &#x2F;&#x2F; 失败处理策略，Fail（报错，job失败），Ignore(失败)，RetryRejected（重试），Custom（自己定义）</span><br><span class="line">                    .failureHandlerIgnore()</span><br><span class="line">                    &#x2F;&#x2F; 关闭flush检测</span><br><span class="line">                    .disableFlushOnCheckpoint()</span><br><span class="line">                    &#x2F;&#x2F; 为每个批量请求设置要缓冲的最大操作数</span><br><span class="line">                    .bulkFlushMaxActions(5)</span><br><span class="line">                    &#x2F;&#x2F; 每个批量请求的缓冲最大值，目前仅支持 MB</span><br><span class="line">                    .bulkFlushMaxSize(&quot;5 MB&quot;)</span><br><span class="line">                    &#x2F;&#x2F; 每个批量请求间隔时间</span><br><span class="line">                    .bulkFlushInterval(1000L)</span><br><span class="line">                    &#x2F;&#x2F; 设置刷新批量请求时要使用的常量回退类型</span><br><span class="line">                    .bulkFlushBackoffConstant()</span><br><span class="line">                    &#x2F;&#x2F; 设置刷新批量请求时每次回退尝试之间的延迟量（毫秒）</span><br><span class="line">                    .bulkFlushBackoffDelay(30000L)</span><br><span class="line">                    &#x2F;&#x2F; 设置刷新批量请求时回退尝试的最大重试次数。</span><br><span class="line">                    .bulkFlushBackoffMaxRetries(3)</span><br><span class="line">            )</span><br><span class="line">            .withSchema(schema)</span><br><span class="line">            .withFormat(new Json())</span><br><span class="line">            &#x2F;&#x2F;可以选择是append还是upsert</span><br><span class="line">            .inUpsertMode()</span><br><span class="line">            .createTemporaryTable(&quot;elsearch&quot;);</span><br><span class="line"></span><br><span class="line">    table.insertInto(&quot;elsearch&quot;);</span><br><span class="line">    env.execute(&quot;SqlSinkElasticSearchStream&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已上便实现了已table的形式插入es。DDL的方式类似，将Elasticsearch参数设置的过程转移到CREATE TABLE 的WITH参数下。运行程序可以看到插入的效果。</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/1.png" alt></p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/4.png" alt></p>
<p>据官方文档描述sql语句可以通过 SELECT a, b, c FROM t GROUP BY a, b 的方式指定a和b为id，即a#b。</p>
<p>修改sqlQuery为下面这样，则自动根据payTm,paySerialNumber的顺序生成id：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table table &#x3D; tableEnv.sqlQuery(&quot;select sum(busyType) as busyType, payTm,paySerialNumber from Users GROUP BY payTm,paySerialNumber&quot;);</span><br></pre></td></tr></table></figure>

<p>发送消息如下：</p>
<blockquote>
<p>{“paySerialNumber”:”PFC0105434202006021516032687707”,”payTm”:1591082163641,”busyType”:2}</p>
</blockquote>
<p>则插入结果如下：</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/5.png" alt></p>
<p>id即为payTm#paySerialNumber</p>
<p>再次发送消息，busyType被更新成了4：</p>
<p><img src="/2020/06/04/flink%E7%9A%84Elasticsearch%E7%9A%84connector%E4%BD%BF%E7%94%A8/6.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/flink%E7%9A%84sideout%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/flink%E7%9A%84sideout%E4%BD%BF%E7%94%A8/" itemprop="url">flink的sideout使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T10:30:27+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近遇到了一个使用了flink的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/side_output.html" target="_blank" rel="noopener">Side Outputs</a>的场景，这里记录一下。</p>
<p>需求的场景比较简单，从kafka接收用户的微信id去实时查询微信的接口获取用户的信息并写入数据库。接口是批量查询接口，可以一次传入多个id。因此有一个问题，如果一批id中有一个非法id，会导致同一批数据全部返回失败。这就需要把返回结果为失败的这一批id全部提取出来并且重新拆分进行查询。</p>
<p>这就需要用到分流，把查询成功的流输出到数据库，把查询失败的流输出到一个地方保存并重新解析。在flink中sideout(侧输出)就是解决这种问题的工具。</p>
<p>sideoutput的输出类型可以与主流不同，可以有多个sideoutput，每个侧输出不同的类型。在使用侧输出的时候需要先定义一个OutputTag。定义方式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputTag&lt;String&gt; outputTag &#x3D; newOutputTag&lt;String&gt;(&quot;side-output&quot;) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>OutputTag有两个构造函数，只有一个id参数，或者包括两个参数，id以及TypeInformation 的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputTag(String id)</span><br><span class="line">OutputTag(String id, TypeInformation&lt;T&gt;typeInfo)</span><br></pre></td></tr></table></figure>

<p>使用sideoutput需要在特定的函数里，通常是更底层的API如ProcessFunction里面，在这些函数里可以使用Context参数，这个参数在底层的API里是暴露给用户使用的。主要有以下几个API：</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/process_function.html" target="_blank" rel="noopener">ProcessFunction</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/process_function.html#the-keyedprocessfunction" target="_blank" rel="noopener">KeyedProcessFunction</a></li>
<li>CoProcessFunction</li>
<li>KeyedCoProcessFunction</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/windows.html#processwindowfunction" target="_blank" rel="noopener">ProcessWindowFunction</a></li>
<li>ProcessAllWindowFunction</li>
</ul>
<p>以下是部分代码示例：</p>
<p>1，首先是flink主流程，需要先定义OutputTag的输出类型及id，然后把OutputTag传入具体需要使用分流的MAP函数中，最后直接从MAP函数处理得到的OutputStream中调用getSideOutput方法拿到sideOutPut的流，这里是把sideOutPut的流输出到一个文件中保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static void execute(StreamExecutionEnvironment env) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从kafka接收用户微信id</span><br><span class="line">        DataStream&lt;String&gt; dataStream &#x3D;</span><br><span class="line">                KafkaSourceBuilder.buildKafkaStreamWithUid(env, KAFKA_SERVERS, GROUP_ID, KAFKA_TOPIC);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义OutputTag</span><br><span class="line">        final OutputTag&lt;List&lt;Map&lt;String, String&gt;&gt;&gt; outputTag &#x3D; new OutputTag&lt;List&lt;Map&lt;String, String&gt;&gt;&gt;(&quot;side-output&quot;)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;WeiXinUserDTO,Map&lt;String, String&gt;&gt;&gt; singleOutputStreamOperator &#x3D; dataStream</span><br><span class="line">                .filter(i -&gt; StringUtils.isNotBlank(i))</span><br><span class="line">                .map(new JsonMapFunction())</span><br><span class="line">                .filter(i -&gt; i !&#x3D; null)</span><br><span class="line">            .windowAll(TimeAndCountWindowAssigner.of(Time.seconds(5),100))</span><br><span class="line">                .aggregate(new ListAggregateFunction())</span><br><span class="line">                &#x2F;&#x2F;这里把outputTag传入HttpWXProcessFunction函数中</span><br><span class="line">                .process(new HttpWXProcessFunction(outputTag))；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正常的流输出到数据库</span><br><span class="line">        singleOutputStreamOperator</span><br><span class="line">                .addSink(new WxMysqlSink());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拿到SideOutput输出流</span><br><span class="line">        DataStream&lt;List&lt;Map&lt;String, String&gt;&gt;&gt; sideOutStream &#x3D; singleOutputStreamOperator.getSideOutput(outputTag);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;使用SideOutput输出流</span><br><span class="line">        sideOutStream</span><br><span class="line">                .addSink(new SideOutSink(&quot;&#x2F;app&#x2F;weixin&#x2F;&quot;,&quot;wexinId&quot;,&quot;yyyyMMdd&quot;))</span><br></pre></td></tr></table></figure>

<p>2，接下来是ProcessFunction函数的执行过程，通过接口查询用户信息。如果成功则使用out.collect发送至下游，如果失败则通过Context将错误的id输出到sideoutput。即ctx.output(outputTag, value)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class HttpWXProcessFunction extends ProcessFunction&lt;List&lt; String&gt; , WeiXinUserDTO&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void processElement(&lt;List&lt; String&gt;&gt; value, Context ctx, Collector&lt;WeiXinUserDTO&gt; out) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        tempList.put(&quot;user_list&quot;, value);</span><br><span class="line"></span><br><span class="line">       String result &#x3D; transHttpReqFacade.getHttpPostResult (&quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;info&#x2F;batchget?access_token&#x3D;&quot; + accessToken, JSONObject.toJSONString(tempList));</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">       WeiXinUserDTO weiXinUserDTO &#x3D; JSONObject.parseObject(result, WeiXinUserDTO.class);</span><br><span class="line">                </span><br><span class="line">       if (weiXinUserDTO.getUser_info_list().size() &gt; 0) &#123;</span><br><span class="line">           log.info(&quot;微信接口成功,tempList size为:&#123;&#125;&quot;, weiXinUserDTO .getUser_info_list().size());</span><br><span class="line">           &#x2F;&#x2F;成功则发送到下游</span><br><span class="line">           out.collect(new Tuple2(weiXinUserDTO, map));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           log.error(&quot;微信获取接口的值失败为:&#123;&#125;,token值为:&#123;&#125;,tempList值为:&#123;&#125;&quot;, result, accessToken, JSONObject.toJSONString(tempList));</span><br><span class="line">           &#x2F;&#x2F;失败则输出到sideoutput</span><br><span class="line">           ctx.output(outputTag, value);</span><br><span class="line">      &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在运行过程中可以在指定的SideOutPut的输出路径下找到查询失败的id列表文件，重新处理操作就可以了。</p>
<blockquote>
<p> [:/app/weixin]$<br>wexinId.txt</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HH KKs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HH KKs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
