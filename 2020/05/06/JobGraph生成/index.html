<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="JobGraph的结构：  StreamGraph生成的过程是StreamExecutionEnvironment类execute，通过getStreamGraph得到StreamGraph： 12345public JobExecutionResult execute(String jobName) throws Exception &amp;#123;	Preconditions.checkNotNu">
<meta property="og:type" content="article">
<meta property="og:title" content="JobGraph生成">
<meta property="og:url" content="http://yoursite.com/2020/05/06/JobGraph%E7%94%9F%E6%88%90/index.html">
<meta property="og:site_name" content="HK书屋">
<meta property="og:description" content="JobGraph的结构：  StreamGraph生成的过程是StreamExecutionEnvironment类execute，通过getStreamGraph得到StreamGraph： 12345public JobExecutionResult execute(String jobName) throws Exception &amp;#123;	Preconditions.checkNotNu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/05/06/JobGraph%E7%94%9F%E6%88%90/1.png">
<meta property="og:image" content="http://yoursite.com/2020/05/06/JobGraph%E7%94%9F%E6%88%90/2.png">
<meta property="article:published_time" content="2020-05-06T02:16:32.083Z">
<meta property="article:modified_time" content="2020-05-06T09:16:48.541Z">
<meta property="article:author" content="HH KKs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/05/06/JobGraph%E7%94%9F%E6%88%90/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/06/JobGraph生成/"/>





  <title>JobGraph生成 | HK书屋</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HK书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/JobGraph%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JobGraph生成</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T10:16:32+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JobGraph的结构：</p>
<p><img src="/2020/05/06/JobGraph%E7%94%9F%E6%88%90/1.png" alt></p>
<p>StreamGraph生成的过程是StreamExecutionEnvironment类execute，通过getStreamGraph得到StreamGraph：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public JobExecutionResult execute(String jobName) throws Exception &#123;</span><br><span class="line">	Preconditions.checkNotNull(jobName, &quot;Streaming Job name should not be null.&quot;);</span><br><span class="line"></span><br><span class="line">	return execute(getStreamGraph(jobName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续执行execute，调用了异步方法executeAsync</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public JobExecutionResult execute(StreamGraph streamGraph) throws Exception &#123;</span><br><span class="line">   final JobClient jobClient &#x3D; executeAsync(streamGraph);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步执行streamGraph调度，Executor根据环境有LocalExecutor(本地)，AbstractJobClusterExecutor(job模式)，AbstractSessionClusterExecutor(session模式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public JobClient executeAsync(StreamGraph streamGraph) throws Exception &#123;</span><br><span class="line">   checkNotNull(streamGraph, &quot;StreamGraph cannot be null.&quot;);</span><br><span class="line">   checkNotNull(configuration.get(DeploymentOptions.TARGET), &quot;No execution.target specified in your configuration file.&quot;);</span><br><span class="line"></span><br><span class="line">   final PipelineExecutorFactory executorFactory &#x3D;</span><br><span class="line">      executorServiceLoader.getExecutorFactory(configuration);</span><br><span class="line"></span><br><span class="line">   checkNotNull(</span><br><span class="line">      executorFactory,</span><br><span class="line">      &quot;Cannot find compatible factory for specified execution.target (&#x3D;%s)&quot;,</span><br><span class="line">      configuration.get(DeploymentOptions.TARGET));</span><br><span class="line"></span><br><span class="line">   CompletableFuture&lt;JobClient&gt; jobClientFuture &#x3D; executorFactory</span><br><span class="line">      .getExecutor(configuration)</span><br><span class="line">      .execute(streamGraph, configuration);</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以LocalExecutor为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;JobClient&gt; execute(Pipeline pipeline, Configuration configuration) throws Exception &#123;</span><br><span class="line">   checkNotNull(pipeline);</span><br><span class="line">   checkNotNull(configuration);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we only support attached execution with the local executor.</span><br><span class="line">   checkState(configuration.getBoolean(DeploymentOptions.ATTACHED));</span><br><span class="line"></span><br><span class="line">   final JobGraph jobGraph &#x3D; getJobGraph(pipeline, configuration);</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>调用getJobGraph</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private JobGraph getJobGraph(Pipeline pipeline, Configuration configuration) &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   return FlinkPipelineTranslationUtil.getJobGraph(pipeline, configuration, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlinkPipelineTranslationUtil#getJobGraph：</span><br><span class="line"></span><br><span class="line">public static JobGraph getJobGraph(</span><br><span class="line">			Pipeline pipeline,</span><br><span class="line">			Configuration optimizerConfiguration,</span><br><span class="line">			int defaultParallelism) &#123;</span><br><span class="line"></span><br><span class="line">		FlinkPipelineTranslator pipelineTranslator &#x3D; getPipelineTranslator(pipeline);</span><br><span class="line"></span><br><span class="line">		return pipelineTranslator.translateToJobGraph(pipeline,</span><br><span class="line">				optimizerConfiguration,</span><br><span class="line">				defaultParallelism);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>FlinkPipelineTranslator根据API的不同分StreamGraphTranslator(流处理)和PlanTranslator(批处理)，进入流处理的Translator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public JobGraph translateToJobGraph(</span><br><span class="line">      Pipeline pipeline,</span><br><span class="line">      Configuration optimizerConfiguration,</span><br><span class="line">      int defaultParallelism) &#123;</span><br><span class="line">   checkArgument(pipeline instanceof StreamGraph,</span><br><span class="line">         &quot;Given pipeline is not a DataStream StreamGraph.&quot;);</span><br><span class="line"></span><br><span class="line">   StreamGraph streamGraph &#x3D; (StreamGraph) pipeline;</span><br><span class="line">   return streamGraph.getJobGraph(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了StreamGraph的getJobGraph,最终进入了StreamingJobGraphGenerator的createJobGraph</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public JobGraph getJobGraph(@Nullable JobID jobID) &#123;</span><br><span class="line">   return StreamingJobGraphGenerator.createJobGraph(this, jobID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createJobGraph是JobGraph生成的主要逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private JobGraph createJobGraph() &#123;</span><br><span class="line">   preValidate();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure that all vertices start immediately</span><br><span class="line">   jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Generate deterministic hashes for the nodes in order to identify them across</span><br><span class="line">   &#x2F;&#x2F; submission iff they didn&#39;t change.</span><br><span class="line">   &#x2F;&#x2F;有两种Hasher，StreamGraphHasherV2和StreamGraphUserHashHasher，生成的Map为（key-&gt; StreamNode的id，value-&gt;为StreamNode生成的hash值，用来做jobVertex的id</span><br><span class="line">   Map&lt;Integer, byte[]&gt; hashes &#x3D; defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Generate legacy version hashes for backwards compatibility</span><br><span class="line">   &#x2F;&#x2F; 为了保持兼容性创建的hash</span><br><span class="line">   List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes &#x3D; new ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">   for (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">      legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里的逻辑大致可以理解为，挨个遍历节点，如果该节点是一个chain的头节点，就生成一个JobVertex，如果不是头节点，就要把自身配置并入头节点，然后把头节点和自己的出边相连；对于不能chain的节点，当作只有头节点处理即可</span><br><span class="line">   setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将每个JobVertex的输入边集合也序列化到该JobVertex的StreamConfig中</span><br><span class="line">    &#x2F;&#x2F; (出边集合已经在setChaining的时候写入了)</span><br><span class="line">   setPhysicalEdges();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据group name，为每个 JobVertex 指定所属的 SlotSharingGroup</span><br><span class="line">		&#x2F;&#x2F; 以及针对 Iteration的头尾设置  CoLocationGroup</span><br><span class="line">   setSlotSharingAndCoLocation();</span><br><span class="line"></span><br><span class="line">   setManagedMemoryFraction(</span><br><span class="line">      Collections.unmodifiableMap(jobVertices),</span><br><span class="line">      Collections.unmodifiableMap(vertexConfigs),</span><br><span class="line">      Collections.unmodifiableMap(chainedConfigs),</span><br><span class="line">      id -&gt; streamGraph.getStreamNode(id).getMinResources(),</span><br><span class="line">      id -&gt; streamGraph.getStreamNode(id).getManagedMemoryWeight());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置 checkpoint</span><br><span class="line">   configureCheckpointing();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  &#x2F;&#x2F;设置Savepoint的配置信息</span><br><span class="line">jobGraph.setSavepointRestoreSettings(streamGraph.getSavepointRestoreSettings());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加用户提供的自定义的文件信息</span><br><span class="line">   JobGraphGenerator.addUserArtifactEntries(streamGraph.getUserArtifacts(), jobGraph);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; set the ExecutionConfig last when it has been finalized</span><br><span class="line">   &#x2F;&#x2F; 将 StreamGraph 的 ExecutionConfig 序列化到 JobGraph 的配置中</span><br><span class="line">   try &#123;</span><br><span class="line">      jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException e) &#123;</span><br><span class="line">      throw new IllegalConfigurationException(&quot;Could not serialize the ExecutionConfig.&quot; +</span><br><span class="line">            &quot;This indicates that non-serializable types (like custom serializers) were registered&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createJobGraph的主要步骤是setChaining，</p>
<ul>
<li><p>chain的逻辑如下图：</p>
<p><img src="/2020/05/06/JobGraph%E7%94%9F%E6%88%90/2.png" alt></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private void setChaining(Map&lt;Integer, byte[]&gt; hashes, List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes, Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes) &#123;</span><br><span class="line">   for (Integer sourceNodeId : streamGraph.getSourceIDs()) &#123;</span><br><span class="line">      createChain(sourceNodeId, sourceNodeId, hashes, legacyHashes, 0, chainedOperatorHashes);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建 operator chain（可能包含一个或多个StreamNode），返回值是当前的这个 operator chain 实际的输出边（不包括内部的边）</span><br><span class="line">	&#x2F;&#x2F;如果 currentNodeId !&#x3D; startNodeId, 说明当前节点在  operator chain 的内部</span><br><span class="line">private List&lt;StreamEdge&gt; createChain(</span><br><span class="line">      Integer startNodeId,</span><br><span class="line">      Integer currentNodeId,</span><br><span class="line">      Map&lt;Integer, byte[]&gt; hashes,</span><br><span class="line">      List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes,</span><br><span class="line">      int chainIndex,</span><br><span class="line">      Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes) &#123;</span><br><span class="line"></span><br><span class="line">   if (!builtVertices.contains(startNodeId)) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前 operator chain 最终的输出边，不包括内部的边</span><br><span class="line">      List&lt;StreamEdge&gt; transitiveOutEdges &#x3D; new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">      List&lt;StreamEdge&gt; chainableOutputs &#x3D; new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">      List&lt;StreamEdge&gt; nonChainableOutputs &#x3D; new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">      StreamNode currentNode &#x3D; streamGraph.getStreamNode(currentNodeId);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前节点的出边分为两组，即 chainable 和 nonChainable</span><br><span class="line">      for (StreamEdge outEdge : currentNode.getOutEdges()) &#123;</span><br><span class="line">         if (isChainable(outEdge, streamGraph)) &#123;</span><br><span class="line">            chainableOutputs.add(outEdge);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            nonChainableOutputs.add(outEdge);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于chainable的输出边，递归调用，找到最终的输出边并加入到输出列表中</span><br><span class="line">      for (StreamEdge chainable : chainableOutputs) &#123;</span><br><span class="line">         transitiveOutEdges.addAll(</span><br><span class="line">               createChain(startNodeId, chainable.getTargetId(), hashes, legacyHashes, chainIndex + 1, chainedOperatorHashes));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于 nonChainable 的边</span><br><span class="line">      for (StreamEdge nonChainable : nonChainableOutputs) &#123;</span><br><span class="line">      &#x2F;&#x2F;先把这个边本身加入到当前节点的输出列表中</span><br><span class="line">         transitiveOutEdges.add(nonChainable);</span><br><span class="line">         &#x2F;&#x2F;递归调用，以下游节点为起点创建新的operator chain</span><br><span class="line">         createChain(nonChainable.getTargetId(), nonChainable.getTargetId(), hashes, legacyHashes, 0, chainedOperatorHashes);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用于保存一个operator chain所有 operator 的 hash 信息，每个startNodeId对应一个list，保存在输入参数chainedOperatorHashes中，list的内容为tuple（currentNodeId的hash，currentNodeId的legacyHash），一个currentNodeId可以有多个tuple</span><br><span class="line">      List&lt;Tuple2&lt;byte[], byte[]&gt;&gt; operatorHashes &#x3D;</span><br><span class="line">         chainedOperatorHashes.computeIfAbsent(startNodeId, k -&gt; new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">      byte[] primaryHashBytes &#x3D; hashes.get(currentNodeId);</span><br><span class="line">      OperatorID currentOperatorId &#x3D; new OperatorID(primaryHashBytes);</span><br><span class="line"></span><br><span class="line">      for (Map&lt;Integer, byte[]&gt; legacyHash : legacyHashes) &#123;</span><br><span class="line">         operatorHashes.add(new Tuple2&lt;&gt;(primaryHashBytes, legacyHash.get(currentNodeId)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前节点的名称，资源要求等信息</span><br><span class="line">      chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs));</span><br><span class="line">      chainedMinResources.put(currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));</span><br><span class="line">      chainedPreferredResources.put(currentNodeId, createChainedPreferredResources(currentNodeId, chainableOutputs));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来生成InputOutputFormatVertex</span><br><span class="line">      if (currentNode.getInputFormat() !&#x3D; null) &#123;</span><br><span class="line">         getOrCreateFormatContainer(startNodeId).addInputFormat(currentOperatorId, currentNode.getInputFormat());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (currentNode.getOutputFormat() !&#x3D; null) &#123;</span><br><span class="line">         getOrCreateFormatContainer(startNodeId).addOutputFormat(currentOperatorId, currentNode.getOutputFormat());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果当前节点是起始节点, 则直接创建 JobVertex 并返回 StreamConfig, 否则先创建一个空的 StreamConfig，createJobVertex 函数就是根据 StreamNode 创建对应的 JobVertex</span><br><span class="line">      StreamConfig config &#x3D; currentNodeId.equals(startNodeId)</span><br><span class="line">            ? createJobVertex(startNodeId, hashes, legacyHashes, chainedOperatorHashes)</span><br><span class="line">            : new StreamConfig(new Configuration());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置 JobVertex 的 StreamConfig, 基本上是序列化 StreamNode 中的配置到 StreamConfig 中.其中包括 序列化器, StreamOperator, Checkpoint 等相关配置</span><br><span class="line">      setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);</span><br><span class="line"></span><br><span class="line">      if (currentNodeId.equals(startNodeId)) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果是chain的起始节点。（不是chain中的节点，也会被标记成 chain start）</span><br><span class="line">         config.setChainStart();</span><br><span class="line">         config.setChainIndex(0);</span><br><span class="line">         config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());</span><br><span class="line">         &#x2F;&#x2F;把实际的输出边写入配置, 部署时会用到</span><br><span class="line">         config.setOutEdgesInOrder(transitiveOutEdges);</span><br><span class="line">         &#x2F;&#x2F;operator chain 的头部 operator 的输出边，包括内部的边config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());</span><br><span class="line">         </span><br><span class="line">&#x2F;&#x2F; 将当前节点(headOfChain)与所有出边相连</span><br><span class="line">         for (StreamEdge edge : transitiveOutEdges) &#123;</span><br><span class="line">         &#x2F;&#x2F; 通过StreamEdge构建出JobEdge，创建IntermediateDataSet，用来将JobVertex和JobEdge相连</span><br><span class="line">            connect(startNodeId, edge);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 将operator chain中所有子节点的 StreamConfig 写入到 headOfChain 节点的 CHAINED_TASK_CONFIG 配置中config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;对于chain的内部node，直接把自己的配置记录进startNodeId的chainedConfigs中</span><br><span class="line">         chainedConfigs.computeIfAbsent(startNodeId, k -&gt; new HashMap&lt;Integer, StreamConfig&gt;());</span><br><span class="line"></span><br><span class="line">         config.setChainIndex(chainIndex);</span><br><span class="line">         StreamNode node &#x3D; streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">         config.setOperatorName(node.getOperatorName());</span><br><span class="line">         chainedConfigs.get(startNodeId).put(currentNodeId, config);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置当前 operator 的 OperatorID</span><br><span class="line">      config.setOperatorID(currentOperatorId);</span><br><span class="line"></span><br><span class="line">      if (chainableOutputs.isEmpty()) &#123;</span><br><span class="line">         config.setChainEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      return transitiveOutEdges;</span><br><span class="line"></span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return new ArrayList&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算子chain在一起的条件是：</p>
<ul>
<li><p>上下游的并行度一致</p>
</li>
<li><p>下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）</p>
</li>
<li><p>上下游节点都在同一个 slot group 中（下面会解释 slot group）</p>
</li>
<li><p>下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）</p>
</li>
<li><p>上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）</p>
</li>
<li><p>两个节点间数据分区方式是 forward（参考理解数据流的分区）</p>
</li>
<li><p>用户没有禁用 chain</p>
<p>这个过程在isChainable中进行判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) &#123;</span><br><span class="line">   StreamNode upStreamVertex &#x3D; streamGraph.getSourceVertex(edge);</span><br><span class="line">   StreamNode downStreamVertex &#x3D; streamGraph.getTargetVertex(edge);</span><br><span class="line"></span><br><span class="line">   StreamOperatorFactory&lt;?&gt; headOperator &#x3D; upStreamVertex.getOperatorFactory();</span><br><span class="line">   StreamOperatorFactory&lt;?&gt; outOperator &#x3D; downStreamVertex.getOperatorFactory();</span><br><span class="line"></span><br><span class="line">   return downStreamVertex.getInEdges().size() &#x3D;&#x3D; 1</span><br><span class="line">         &amp;&amp; outOperator !&#x3D; null</span><br><span class="line">         &amp;&amp; headOperator !&#x3D; null</span><br><span class="line">         &amp;&amp; upStreamVertex.isSameSlotSharingGroup(downStreamVertex)</span><br><span class="line">         &amp;&amp; outOperator.getChainingStrategy() &#x3D;&#x3D; ChainingStrategy.ALWAYS</span><br><span class="line">         &amp;&amp; (headOperator.getChainingStrategy() &#x3D;&#x3D; ChainingStrategy.HEAD ||</span><br><span class="line">            headOperator.getChainingStrategy() &#x3D;&#x3D; ChainingStrategy.ALWAYS)</span><br><span class="line">         &amp;&amp; (edge.getPartitioner() instanceof ForwardPartitioner)</span><br><span class="line">         &amp;&amp; edge.getShuffleMode() !&#x3D; ShuffleMode.BATCH</span><br><span class="line">         &amp;&amp; upStreamVertex.getParallelism() &#x3D;&#x3D; downStreamVertex.getParallelism()</span><br><span class="line">         &amp;&amp; streamGraph.isChainingEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>createJobVertex生成JobVertex，相当于jobghaph的顶点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private StreamConfig createJobVertex(</span><br><span class="line">      Integer streamNodeId,</span><br><span class="line">      Map&lt;Integer, byte[]&gt; hashes,</span><br><span class="line">      List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes,</span><br><span class="line">      Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes) &#123;</span><br><span class="line"></span><br><span class="line">   JobVertex jobVertex;</span><br><span class="line">   StreamNode streamNode &#x3D; streamGraph.getStreamNode(streamNodeId);</span><br><span class="line"></span><br><span class="line">   byte[] hash &#x3D; hashes.get(streamNodeId);</span><br><span class="line"></span><br><span class="line">   if (hash &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Cannot find node hash. &quot; +</span><br><span class="line">            &quot;Did you generate them before calling this method?&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JobVertexID就是StreamID的hash</span><br><span class="line">   JobVertexID jobVertexId &#x3D; new JobVertexID(hash);</span><br><span class="line"></span><br><span class="line">   List&lt;JobVertexID&gt; legacyJobVertexIds &#x3D; new ArrayList&lt;&gt;(legacyHashes.size());</span><br><span class="line">   for (Map&lt;Integer, byte[]&gt; legacyHash : legacyHashes) &#123;</span><br><span class="line">      hash &#x3D; legacyHash.get(streamNodeId);</span><br><span class="line">      if (null !&#x3D; hash) &#123;</span><br><span class="line">         legacyJobVertexIds.add(new JobVertexID(hash));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;得到chain算子的hash和userDefinedHash</span><br><span class="line">   List&lt;Tuple2&lt;byte[], byte[]&gt;&gt; chainedOperators &#x3D; chainedOperatorHashes.get(streamNodeId);</span><br><span class="line">   List&lt;OperatorID&gt; chainedOperatorVertexIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;OperatorID&gt; userDefinedChainedOperatorVertexIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   if (chainedOperators !&#x3D; null) &#123;</span><br><span class="line">      for (Tuple2&lt;byte[], byte[]&gt; chainedOperator : chainedOperators) &#123;</span><br><span class="line">         chainedOperatorVertexIds.add(new OperatorID(chainedOperator.f0));</span><br><span class="line">         userDefinedChainedOperatorVertexIds.add(chainedOperator.f1 !&#x3D; null ? new OperatorID(chainedOperator.f1) : null);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (chainedInputOutputFormats.containsKey(streamNodeId)) &#123;</span><br><span class="line">   &#x2F;&#x2F;生成InputOutputFormatVertex</span><br><span class="line">      jobVertex &#x3D; new InputOutputFormatVertex(</span><br><span class="line">            chainedNames.get(streamNodeId),</span><br><span class="line">            jobVertexId,</span><br><span class="line">            legacyJobVertexIds,</span><br><span class="line">            chainedOperatorVertexIds,</span><br><span class="line">            userDefinedChainedOperatorVertexIds);</span><br><span class="line"></span><br><span class="line">      chainedInputOutputFormats</span><br><span class="line">         .get(streamNodeId)</span><br><span class="line">         .write(new TaskConfig(jobVertex.getConfiguration()));</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F;生成jobVertex</span><br><span class="line">      jobVertex &#x3D; new JobVertex(</span><br><span class="line">            chainedNames.get(streamNodeId),</span><br><span class="line">            jobVertexId,</span><br><span class="line">            legacyJobVertexIds,</span><br><span class="line">            chainedOperatorVertexIds,</span><br><span class="line">            userDefinedChainedOperatorVertexIds);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   jobVertex.setResources(chainedMinResources.get(streamNodeId), chainedPreferredResources.get(streamNodeId));</span><br><span class="line"></span><br><span class="line">   jobVertex.setInvokableClass(streamNode.getJobVertexClass());</span><br><span class="line"></span><br><span class="line">   int parallelism &#x3D; streamNode.getParallelism();</span><br><span class="line"></span><br><span class="line">   if (parallelism &gt; 0) &#123;</span><br><span class="line">      jobVertex.setParallelism(parallelism);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      parallelism &#x3D; jobVertex.getParallelism();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   jobVertex.setMaxParallelism(streamNode.getMaxParallelism());</span><br><span class="line"></span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;Parallelism set: &#123;&#125; for &#123;&#125;&quot;, parallelism, streamNodeId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; TODO: inherit InputDependencyConstraint from the head operator</span><br><span class="line">   jobVertex.setInputDependencyConstraint(streamGraph.getExecutionConfig().getDefaultInputDependencyConstraint());</span><br><span class="line"></span><br><span class="line">   jobVertices.put(streamNodeId, jobVertex);</span><br><span class="line">   builtVertices.add(streamNodeId);</span><br><span class="line">   jobGraph.addVertex(jobVertex);</span><br><span class="line"></span><br><span class="line">   return new StreamConfig(jobVertex.getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobVertex类，每个 <code>JobVertex</code> 中包含一个或多个 Operators，其输入是 <code>JobEdge</code> 列表, 输出是 <code>IntermediateDataSet</code> 列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class JobVertex implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">   private static final String DEFAULT_NAME &#x3D; &quot;(unnamed vertex)&quot;;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Members that define the structure &#x2F; topology of the graph</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** The ID of the vertex. *&#x2F;</span><br><span class="line">   private final JobVertexID id;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The alternative IDs of the vertex. *&#x2F;</span><br><span class="line">   private final ArrayList&lt;JobVertexID&gt; idAlternatives &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The IDs of all operators contained in this vertex. *&#x2F;</span><br><span class="line">   private final ArrayList&lt;OperatorID&gt; operatorIDs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The alternative IDs of all operators contained in this vertex. *&#x2F;</span><br><span class="line">   private final ArrayList&lt;OperatorID&gt; operatorIdsAlternatives &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** List of produced data sets, one per writer. *&#x2F;</span><br><span class="line">   private final ArrayList&lt;IntermediateDataSet&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** List of edges with incoming data. One per Reader. *&#x2F;</span><br><span class="line">   private final ArrayList&lt;JobEdge&gt; inputs &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>每一个 operator chain 都会为所有的实际输出边创建对应的 <code>JobEdge</code>，并和 <code>JobVertex</code> 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private void connect(Integer headOfChain, StreamEdge edge) &#123;</span><br><span class="line"></span><br><span class="line">   physicalEdgesInOrder.add(edge);</span><br><span class="line"></span><br><span class="line">   Integer downStreamvertexID &#x3D; edge.getTargetId();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取上下游JobVertex</span><br><span class="line">   JobVertex headVertex &#x3D; jobVertices.get(headOfChain);</span><br><span class="line">   JobVertex downStreamVertex &#x3D; jobVertices.get(downStreamvertexID);</span><br><span class="line"></span><br><span class="line">   StreamConfig downStreamConfig &#x3D; new StreamConfig(downStreamVertex.getConfiguration());</span><br><span class="line">&#x2F;&#x2F;下游节点增加一个输入</span><br><span class="line">   downStreamConfig.setNumberOfInputs(downStreamConfig.getNumberOfInputs() + 1);</span><br><span class="line"></span><br><span class="line">   StreamPartitioner&lt;?&gt; partitioner &#x3D; edge.getPartitioner();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据StreamEdge的Shuffle模式得到ResultPartitionType</span><br><span class="line">   ResultPartitionType resultPartitionType;</span><br><span class="line">   switch (edge.getShuffleMode()) &#123;</span><br><span class="line">      case PIPELINED:</span><br><span class="line">         resultPartitionType &#x3D; ResultPartitionType.PIPELINED_BOUNDED;</span><br><span class="line">         break;</span><br><span class="line">      case BATCH:</span><br><span class="line">         resultPartitionType &#x3D; ResultPartitionType.BLOCKING;</span><br><span class="line">         break;</span><br><span class="line">      case UNDEFINED:</span><br><span class="line">         resultPartitionType &#x3D; streamGraph.isBlockingConnectionsBetweenChains() ?</span><br><span class="line">               ResultPartitionType.BLOCKING : ResultPartitionType.PIPELINED_BOUNDED;</span><br><span class="line">         break;</span><br><span class="line">      default:</span><br><span class="line">         throw new UnsupportedOperationException(&quot;Data exchange mode &quot; +</span><br><span class="line">            edge.getShuffleMode() + &quot; is not supported yet.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 JobEdge 和 IntermediateDataSet，根据StreamPartitioner类型决定在上游节点（生产者）的子任务和下游节点（消费者）之间的连接模式</span><br><span class="line">   JobEdge jobEdge;</span><br><span class="line">   if (partitioner instanceof ForwardPartitioner || partitioner instanceof RescalePartitioner) &#123;</span><br><span class="line">      jobEdge &#x3D; downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">         headVertex,</span><br><span class="line">         DistributionPattern.POINTWISE,</span><br><span class="line">         resultPartitionType);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      jobEdge &#x3D; downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">            headVertex,</span><br><span class="line">            DistributionPattern.ALL_TO_ALL,</span><br><span class="line">            resultPartitionType);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; set strategy name so that web interface can show it.</span><br><span class="line">   jobEdge.setShipStrategyName(partitioner.toString());</span><br><span class="line"></span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;CONNECTED: &#123;&#125; - &#123;&#125; -&gt; &#123;&#125;&quot;, partitioner.getClass().getSimpleName(),</span><br><span class="line">            headOfChain, downStreamvertexID);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connectNewDataSetAsInput方法在JobVertex类里面，由下游节点调用生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public JobEdge connectNewDataSetAsInput(</span><br><span class="line">      JobVertex input,</span><br><span class="line">      DistributionPattern distPattern,</span><br><span class="line">      ResultPartitionType partitionType) &#123;</span><br><span class="line"></span><br><span class="line">   IntermediateDataSet dataSet &#x3D; input.createAndAddResultDataSet(partitionType);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建JobEdge</span><br><span class="line">   JobEdge edge &#x3D; new JobEdge(dataSet, this, distPattern);</span><br><span class="line">   this.inputs.add(edge);</span><br><span class="line">   dataSet.addConsumer(edge);</span><br><span class="line">   return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobEdge类，在 <code>StramGraph</code> 中，<code>StreamNode</code> 之间是通过 <code>StreamEdge</code> 建立连接的。在 <code>JobEdge</code> 中，对应的是 <code>JobEdge</code> 。和 <code>StreamEdge</code> 中同时保留了源节点和目标节点 （sourceId 和 targetId）不同，在 <code>JobEdge</code> 中只有源节点的信息。由于 <code>JobVertex</code> 中保存了所有输入的 <code>JobEdge</code> 的信息，因而同样可以在两个节点之间建立连接。更确切地说，<code>JobEdge</code> 是和节点的输出结果相关联的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class JobEdge implements java.io.Serializable &#123;</span><br><span class="line">      </span><br><span class="line">   &#x2F;** The vertex connected to this edge. *&#x2F;</span><br><span class="line">   private final JobVertex target;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The distribution pattern that should be used for this job edge. *&#x2F;</span><br><span class="line">   private final DistributionPattern distributionPattern;</span><br><span class="line">   </span><br><span class="line">   &#x2F;** The data set at the source of the edge, may be null if the edge is not yet connected*&#x2F;</span><br><span class="line">   private IntermediateDataSet source;</span><br><span class="line">   </span><br><span class="line">   &#x2F;** The id of the source intermediate data set *&#x2F;</span><br><span class="line">   private IntermediateDataSetID sourceId;</span><br><span class="line">   </span><br><span class="line">   &#x2F;** Optional name for the data shipping strategy (forward, partition hash, rebalance, ...),</span><br><span class="line">    * to be displayed in the JSON plan *&#x2F;</span><br><span class="line">   private String shipStrategyName;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Optional name for the pre-processing operation (sort, combining sort, ...),</span><br><span class="line">    * to be displayed in the JSON plan *&#x2F;</span><br><span class="line">   private String preProcessingOperationName;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Optional description of the caching inside an operator, to be displayed in the JSON plan *&#x2F;</span><br><span class="line">   private String operatorLevelCachingDescription;</span><br></pre></td></tr></table></figure>

<p>生成IntermediateDataSet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public IntermediateDataSet createAndAddResultDataSet(ResultPartitionType partitionType) &#123;</span><br><span class="line">   return createAndAddResultDataSet(new IntermediateDataSetID(), partitionType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public IntermediateDataSet createAndAddResultDataSet(</span><br><span class="line">      IntermediateDataSetID id,</span><br><span class="line">      ResultPartitionType partitionType) &#123;</span><br><span class="line"></span><br><span class="line">   IntermediateDataSet result &#x3D; new IntermediateDataSet(id, partitionType, this);</span><br><span class="line">   this.results.add(result);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntermediateDataSet代表中间数据流，连接JobVertex和JobEdge</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * An intermediate data set is the data set produced by an operator - either a</span><br><span class="line"> * source or any intermediate operation.</span><br><span class="line"> * </span><br><span class="line"> * Intermediate data sets may be read by other operators, materialized, or</span><br><span class="line"> * discarded.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntermediateDataSet implements java.io.Serializable &#123;</span><br><span class="line">   </span><br><span class="line">   private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   private final IntermediateDataSetID id;       &#x2F;&#x2F; the identifier</span><br><span class="line">   </span><br><span class="line">   private final JobVertex producer;        &#x2F;&#x2F; the operation that produced this data set</span><br><span class="line">   </span><br><span class="line">   private final List&lt;JobEdge&gt; consumers &#x3D; new ArrayList&lt;JobEdge&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The type of partition to use at runtime</span><br><span class="line">   private final ResultPartitionType resultType;</span><br><span class="line"></span><br><span class="line">   public IntermediateDataSet(IntermediateDataSetID id, ResultPartitionType resultType, JobVertex producer) &#123;</span><br><span class="line">      this.id &#x3D; checkNotNull(id);</span><br><span class="line">      this.producer &#x3D; checkNotNull(producer);</span><br><span class="line">      this.resultType &#x3D; checkNotNull(resultType);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/24/StreamGraph%E7%94%9F%E6%88%90/" rel="next" title="StreamGraph生成">
                <i class="fa fa-chevron-left"></i> StreamGraph生成
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/07/ExecutionGraph%E7%94%9F%E6%88%90/" rel="prev" title="ExecutionGraph生成">
                ExecutionGraph生成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HH KKs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HH KKs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
