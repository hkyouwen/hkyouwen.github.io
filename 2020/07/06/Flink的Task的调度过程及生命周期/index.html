<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="回顾之前JobManager的启动过程，创建好JobManagerRunner之后，调用Dispatcher的startJobManagerRunner启动JobManager。 12345678910111213141516171819202122232425262728293031323334private JobManagerRunner startJobManagerRunner(JobM">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink的Task的调度过程及生命周期">
<meta property="og:url" content="http://yoursite.com/2020/07/06/Flink%E7%9A%84Task%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.html">
<meta property="og:site_name" content="HK书屋">
<meta property="og:description" content="回顾之前JobManager的启动过程，创建好JobManagerRunner之后，调用Dispatcher的startJobManagerRunner启动JobManager。 12345678910111213141516171819202122232425262728293031323334private JobManagerRunner startJobManagerRunner(JobM">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-06T02:35:31.552Z">
<meta property="article:modified_time" content="2020-07-14T08:35:25.081Z">
<meta property="article:author" content="HH KKs">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/06/Flink的Task的调度过程及生命周期/"/>





  <title>Flink的Task的调度过程及生命周期 | HK书屋</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HK书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/Flink%E7%9A%84Task%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flink的Task的调度过程及生命周期</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T10:35:31+08:00">
                2020-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>回顾之前JobManager的启动过程，创建好JobManagerRunner之后，调用Dispatcher的startJobManagerRunner启动JobManager。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private JobManagerRunner startJobManagerRunner(JobManagerRunner jobManagerRunner) throws Exception &#123;</span><br><span class="line">   final JobID jobId &#x3D; jobManagerRunner.getJobID();</span><br><span class="line"></span><br><span class="line">   FutureUtils.assertNoException(</span><br><span class="line">      jobManagerRunner.getResultFuture().handleAsync(</span><br><span class="line">         (ArchivedExecutionGraph archivedExecutionGraph, Throwable throwable) -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we are still the active JobManagerRunner by checking the identity</span><br><span class="line">            final JobManagerRunner currentJobManagerRunner &#x3D; Optional.ofNullable(jobManagerRunnerFutures.get(jobId))</span><br><span class="line">               .map(future -&gt; future.getNow(null))</span><br><span class="line">               .orElse(null);</span><br><span class="line">            &#x2F;&#x2F;noinspection ObjectEquality</span><br><span class="line">            if (jobManagerRunner &#x3D;&#x3D; currentJobManagerRunner) &#123;</span><br><span class="line">               if (archivedExecutionGraph !&#x3D; null) &#123;</span><br><span class="line">                  jobReachedGloballyTerminalState(archivedExecutionGraph);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                  final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                  if (strippedThrowable instanceof JobNotFinishedException) &#123;</span><br><span class="line">                     jobNotFinished(jobId);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                     jobMasterFailed(jobId, strippedThrowable);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               log.debug(&quot;There is a newer JobManagerRunner for the job &#123;&#125;.&quot;, jobId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">         &#125;, getMainThreadExecutor()));</span><br><span class="line">&#x2F;&#x2F;启动jobManager</span><br><span class="line">   jobManagerRunner.start();</span><br><span class="line"></span><br><span class="line">   return jobManagerRunner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobManagerRunnerImpl类start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;选举leader节点</span><br><span class="line">      leaderElectionService.start(this);</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      log.error(&quot;Could not start the JobManager because the leader election service did not start.&quot;, e);</span><br><span class="line">      throw new Exception(&quot;Could not start the leader election service.&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功回调JobManagerRunnerImpl类的grantLeadership回调方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void grantLeadership(final UUID leaderSessionID) &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         log.info(&quot;JobManagerRunner already shutdown.&quot;);</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      leadershipOperation &#x3D; leadershipOperation.thenCompose(</span><br><span class="line">         (ignored) -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">               return verifyJobSchedulingStatusAndStartJobManager(leaderSessionID);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">      handleException(leadershipOperation, &quot;Could not start the job manager.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private CompletableFuture&lt;Void&gt; verifyJobSchedulingStatusAndStartJobManager(UUID leaderSessionId) &#123;</span><br><span class="line">		final CompletableFuture&lt;JobSchedulingStatus&gt; jobSchedulingStatusFuture &#x3D; getJobSchedulingStatus();</span><br><span class="line"></span><br><span class="line">		return jobSchedulingStatusFuture.thenCompose(</span><br><span class="line">			jobSchedulingStatus -&gt; &#123;</span><br><span class="line">				if (jobSchedulingStatus &#x3D;&#x3D; JobSchedulingStatus.DONE) &#123;</span><br><span class="line">					return jobAlreadyDone();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F;启动startJobMaster</span><br><span class="line">					return startJobMaster(leaderSessionId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主节点选举成功启动startJobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private CompletionStage&lt;Void&gt; startJobMaster(UUID leaderSessionId) &#123;</span><br><span class="line">   log.info(&quot;JobManager runner for job &#123;&#125; (&#123;&#125;) was granted leadership with session id &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">      jobGraph.getName(), jobGraph.getJobID(), leaderSessionId, jobMasterService.getAddress());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      runningJobsRegistry.setJobRunning(jobGraph.getJobID());</span><br><span class="line">   &#125; catch (IOException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(</span><br><span class="line">         new FlinkException(</span><br><span class="line">            String.format(&quot;Failed to set the job %s to running in the running jobs registry.&quot;, jobGraph.getJobID()),</span><br><span class="line">            e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;Acknowledge&gt; startFuture;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;使用leaderSessionId构建 JobMasterId 启动 JobMaster</span><br><span class="line">      startFuture &#x3D; jobMasterService.start(new JobMasterId(leaderSessionId));</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(new FlinkException(&quot;Failed to start the JobMaster.&quot;, e));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final CompletableFuture&lt;JobMasterGateway&gt; currentLeaderGatewayFuture &#x3D; leaderGatewayFuture;</span><br><span class="line">   return startFuture.thenAcceptAsync(</span><br><span class="line">      (Acknowledge ack) -&gt; confirmLeaderSessionIdIfStillLeader(</span><br><span class="line">         leaderSessionId,</span><br><span class="line">         jobMasterService.getAddress(),</span><br><span class="line">         currentLeaderGatewayFuture),</span><br><span class="line">      executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入JobMaster类start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; start(final JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; make sure we receive RPC and async calls</span><br><span class="line">   &#x2F;&#x2F;启动RpcServer</span><br><span class="line">   start();</span><br><span class="line"></span><br><span class="line">   return callAsyncWithoutFencing(() -&gt; startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   validateRunsInMainThread();</span><br><span class="line"></span><br><span class="line">   checkNotNull(newJobMasterId, &quot;The new JobMasterId must not be null.&quot;);</span><br><span class="line"></span><br><span class="line">   if (Objects.equals(getFencingToken(), newJobMasterId)) &#123;</span><br><span class="line">      log.info(&quot;Already started the job execution with JobMasterId &#123;&#125;.&quot;, newJobMasterId);</span><br><span class="line"></span><br><span class="line">      return Acknowledge.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setNewFencingToken(newJobMasterId);</span><br><span class="line"></span><br><span class="line">   startJobMasterServices();</span><br><span class="line"></span><br><span class="line">   log.info(&quot;Starting execution of job &#123;&#125; (&#123;&#125;) under job master id &#123;&#125;.&quot;, jobGraph.getName(), jobGraph.getJobID(), newJobMasterId);</span><br><span class="line"></span><br><span class="line">   resetAndStartScheduler();</span><br><span class="line"></span><br><span class="line">   return Acknowledge.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startJobMasterServices与ResourceManager建立连接，之后resetAndStartScheduler进入job的调度流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void resetAndStartScheduler() throws Exception &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   schedulerAssignedFuture.thenRun(this::startScheduling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startScheduling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void startScheduling() &#123;</span><br><span class="line">   checkState(jobStatusListener &#x3D;&#x3D; null);</span><br><span class="line">   &#x2F;&#x2F; register self as job status change listener</span><br><span class="line">   &#x2F;&#x2F;状态监听</span><br><span class="line">   jobStatusListener &#x3D; new JobManagerJobStatusListener();</span><br><span class="line">   schedulerNG.registerJobStatusListener(jobStatusListener);</span><br><span class="line"></span><br><span class="line">   schedulerNG.startScheduling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SchedulerBase类startScheduling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void startScheduling() &#123;</span><br><span class="line">   mainThreadExecutor.assertRunningInMainThread();</span><br><span class="line">   &#x2F;&#x2F;注册监控</span><br><span class="line">   registerJobMetrics();</span><br><span class="line">   startSchedulingInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LegacyScheduler类startSchedulingInternal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void startSchedulingInternal() &#123;</span><br><span class="line">   final ExecutionGraph executionGraph &#x3D; getExecutionGraph();</span><br><span class="line">   try &#123;</span><br><span class="line">      executionGraph.scheduleForExecution();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable t) &#123;</span><br><span class="line">      executionGraph.failGlobal(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExecutionGraph类的scheduleForExecution</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleForExecution() throws JobException &#123;</span><br><span class="line"></span><br><span class="line">   assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   if (isLegacyScheduling()) &#123;</span><br><span class="line">      LOG.info(&quot;Job recovers via failover strategy: &#123;&#125;&quot;, failoverStrategy.getStrategyName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long currentGlobalModVersion &#x3D; globalModVersion;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将job状态由CREATED转为RUNNING</span><br><span class="line">   if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</span><br><span class="line"></span><br><span class="line">      final CompletableFuture&lt;Void&gt; newSchedulingFuture &#x3D; SchedulingUtils.schedule(</span><br><span class="line">         scheduleMode,</span><br><span class="line">         getAllExecutionVertices(),</span><br><span class="line">         this);</span><br><span class="line"></span><br><span class="line">      if (state &#x3D;&#x3D; JobStatus.RUNNING &amp;&amp; currentGlobalModVersion &#x3D;&#x3D; globalModVersion) &#123;</span><br><span class="line">         schedulingFuture &#x3D; newSchedulingFuture;</span><br><span class="line">         newSchedulingFuture.whenComplete(</span><br><span class="line">            (Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">               if (throwable !&#x3D; null) &#123;</span><br><span class="line">                  final Throwable strippedThrowable &#x3D; ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                  if (!(strippedThrowable instanceof CancellationException)) &#123;</span><br><span class="line">                     &#x2F;&#x2F; only fail if the scheduling future was not canceled</span><br><span class="line">                     failGlobal(strippedThrowable);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         newSchedulingFuture.cancel(false);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Job may only be scheduled from state &quot; + JobStatus.CREATED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; schedule(</span><br><span class="line">      ScheduleMode scheduleMode,</span><br><span class="line">      final Iterable&lt;ExecutionVertex&gt; vertices,</span><br><span class="line">      final ExecutionGraph executionGraph) &#123;</span><br><span class="line"></span><br><span class="line">   switch (scheduleMode) &#123;</span><br><span class="line">   &#x2F;&#x2F;只运行 source，其它的子任务由source进行通知</span><br><span class="line">      case LAZY_FROM_SOURCES:</span><br><span class="line">      case LAZY_FROM_SOURCES_WITH_BATCH_SLOT_REQUEST:</span><br><span class="line">         return scheduleLazy(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;所有的子任务都立即进行调度，这是 streaming 模式采用的方式</span><br><span class="line">      case EAGER:</span><br><span class="line">         return scheduleEager(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">         throw new IllegalStateException(String.format(&quot;Schedule mode %s is invalid.&quot;, scheduleMode));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleEager调度子任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; scheduleEager(</span><br><span class="line">      final Iterable&lt;ExecutionVertex&gt; vertices,</span><br><span class="line">      final ExecutionGraph executionGraph) &#123;</span><br><span class="line"></span><br><span class="line">   executionGraph.assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   checkState(executionGraph.getState() &#x3D;&#x3D; JobStatus.RUNNING, &quot;job is not running currently&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Important: reserve all the space we need up front.</span><br><span class="line">   &#x2F;&#x2F; that way we do not have any operation that can fail between allocating the slots</span><br><span class="line">   &#x2F;&#x2F; and adding them to the list. If we had a failure in between there, that would</span><br><span class="line">   &#x2F;&#x2F; cause the slots to get lost</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; collecting all the slots may resize and fail in that operation without slots getting lost</span><br><span class="line">   final ArrayList&lt;CompletableFuture&lt;Execution&gt;&gt; allAllocationFutures &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   final SlotProviderStrategy slotProviderStrategy &#x3D; executionGraph.getSlotProviderStrategy();</span><br><span class="line">   final Set&lt;AllocationID&gt; allPreviousAllocationIds &#x3D; Collections.unmodifiableSet(</span><br><span class="line">      computePriorAllocationIdsIfRequiredByScheduling(vertices, slotProviderStrategy.asSlotProvider()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分配已slot资源</span><br><span class="line">   &#x2F;&#x2F; allocate the slots (obtain all their futures)</span><br><span class="line">   for (ExecutionVertex ev : vertices) &#123;</span><br><span class="line">      &#x2F;&#x2F; these calls are not blocking, they only return futures</span><br><span class="line">      CompletableFuture&lt;Execution&gt; allocationFuture &#x3D; ev.getCurrentExecutionAttempt().allocateResourcesForExecution(</span><br><span class="line">         slotProviderStrategy,</span><br><span class="line">         LocationPreferenceConstraint.ALL,</span><br><span class="line">         allPreviousAllocationIds);</span><br><span class="line"></span><br><span class="line">      allAllocationFutures.add(allocationFuture);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; this future is complete once all slot futures are complete.</span><br><span class="line">   &#x2F;&#x2F; the future fails once one slot future fails.</span><br><span class="line">   &#x2F;&#x2F; 等待所有需要调度的子任务都分配到资源</span><br><span class="line">   final ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture &#x3D; FutureUtils.combineAll(allAllocationFutures);</span><br><span class="line"></span><br><span class="line">   return allAllocationsFuture.thenAccept(</span><br><span class="line">      (Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</span><br><span class="line">         for (Execution execution : executionsToDeploy) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F;启动 Execution</span><br><span class="line">               execution.deploy();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">               throw new CompletionException(</span><br><span class="line">                  new FlinkException(</span><br><span class="line">                     String.format(&quot;Could not deploy execution %s.&quot;, execution),</span><br><span class="line">                     t));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F; Generate a more specific failure message for the eager scheduling</span><br><span class="line">      .exceptionally(......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Execution</code> 是 <code>ExecutionVertex</code> 的一次执行，在调度的时候会先生成对任务的描述 <code>TaskDeploymentDescription</code>， <code>TaskDeploymentDescription</code> 包含了对输入的描述 <code>InputGateDeploymentDescriptor</code>, 对输出的描述 <code>ResultPartitionDeploymentDescriptor</code>，以及保存了这个 Task 中运行的所有算子运行时信息的 <code>TaskInformation</code> 和 <code>JobInformation</code>。生成了 <code>TaskDeploymentDescription</code> 通过 RPC 调用提交给 <code>TaskExecutor</code> 执行。</p>
<p>Execution 类的deploy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void deploy() throws JobException &#123;</span><br><span class="line">   assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">   final LogicalSlot slot  &#x3D; assignedResource;</span><br><span class="line"></span><br><span class="line">   checkNotNull(slot, &quot;In order to deploy the execution we first have to assign a resource via tryAssignResource.&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Check if the TaskManager died in the meantime</span><br><span class="line">   &#x2F;&#x2F; This only speeds up the response to TaskManagers failing concurrently to deployments.</span><br><span class="line">   &#x2F;&#x2F; The more general check is the rpcTimeout of the deployment call</span><br><span class="line">   if (!slot.isAlive()) &#123;</span><br><span class="line">      throw new JobException(&quot;Target slot (TaskManager) for deployment is no longer alive.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure exactly one deployment call happens from the correct state</span><br><span class="line">   &#x2F;&#x2F; note: the transition from CREATED to DEPLOYING is for testing purposes only</span><br><span class="line">   ExecutionState previous &#x3D; this.state;</span><br><span class="line">   if (previous &#x3D;&#x3D; SCHEDULED || previous &#x3D;&#x3D; CREATED) &#123;</span><br><span class="line">      if (!transitionState(previous, DEPLOYING)) &#123;</span><br><span class="line">         &#x2F;&#x2F; race condition, someone else beat us to the deploying call.</span><br><span class="line">         &#x2F;&#x2F; this should actually not happen and indicates a race somewhere else</span><br><span class="line">         throw new IllegalStateException(&quot;Cannot deploy task: Concurrent deployment call race.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; vertex may have been cancelled, or it was already scheduled</span><br><span class="line">      throw new IllegalStateException(&quot;The vertex must be in CREATED or SCHEDULED state to be deployed. Found state &quot; + previous);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (this !&#x3D; slot.getPayload()) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">         String.format(&quot;The execution %s has not been assigned to the assigned slot.&quot;, this));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; race double check, did we fail&#x2F;cancel and do we need to release the slot?</span><br><span class="line">      if (this.state !&#x3D; DEPLOYING) &#123;</span><br><span class="line">         slot.releaseSlot(new FlinkException(&quot;Actual state of execution &quot; + this + &quot; (&quot; + state + &quot;) does not match expected state DEPLOYING.&quot;));</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (LOG.isInfoEnabled()) &#123;</span><br><span class="line">         LOG.info(String.format(&quot;Deploying %s (attempt #%d) to %s&quot;, vertex.getTaskNameWithSubtaskIndex(),</span><br><span class="line">               attemptNumber, getAssignedResourceLocation()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;TaskDeploymentDescription 是对任务的描述，包含了task运行需要所以信息</span><br><span class="line">      final TaskDeploymentDescriptor deployment &#x3D; TaskDeploymentDescriptorFactory</span><br><span class="line">         .fromExecutionVertex(vertex, attemptNumber)</span><br><span class="line">         .createDeploymentDescriptor(</span><br><span class="line">            slot.getAllocationId(),</span><br><span class="line">            slot.getPhysicalSlotNumber(),</span><br><span class="line">            taskRestore,</span><br><span class="line">            producedPartitions.values());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; null taskRestore to let it be GC&#39;ed</span><br><span class="line">      taskRestore &#x3D; null;</span><br><span class="line"></span><br><span class="line">      final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">      final ComponentMainThreadExecutor jobMasterMainThreadExecutor &#x3D;</span><br><span class="line">         vertex.getExecutionGraph().getJobMasterMainThreadExecutor();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; We run the submission in the future executor so that the serialization of large TDDs does not block</span><br><span class="line">      &#x2F;&#x2F; the main thread and sync back to the main thread once submission is completed.</span><br><span class="line">      &#x2F;&#x2F;向taskManagerGateway提交job</span><br><span class="line">      CompletableFuture.supplyAsync(() -&gt; taskManagerGateway.submitTask(deployment, rpcTimeout), executor)</span><br><span class="line">         .thenCompose(Function.identity())</span><br><span class="line">         .whenCompleteAsync(</span><br><span class="line">            ......);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>taskManagerGateway最终调用TaskExecutor的submitTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; submitTask(</span><br><span class="line">      TaskDeploymentDescriptor tdd,</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      Time timeout) &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      final JobID jobId &#x3D; tdd.getJobId();</span><br><span class="line">      final JobManagerConnection jobManagerConnection &#x3D; jobManagerTable.get(jobId);</span><br><span class="line"></span><br><span class="line">      if (jobManagerConnection &#x3D;&#x3D; null) &#123;</span><br><span class="line">         final String message &#x3D; &quot;Could not submit task because there is no JobManager &quot; +</span><br><span class="line">            &quot;associated for the job &quot; + jobId + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!Objects.equals(jobManagerConnection.getJobMasterId(), jobMasterId)) &#123;</span><br><span class="line">         final String message &#x3D; &quot;Rejecting the task submission because the job manager leader id &quot; +</span><br><span class="line">            jobMasterId + &quot; does not match the expected job manager leader id &quot; +</span><br><span class="line">            jobManagerConnection.getJobMasterId() + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!taskSlotTable.tryMarkSlotActive(jobId, tdd.getAllocationId())) &#123;</span><br><span class="line">         final String message &#x3D; &quot;No task slot allocated for job ID &quot; + jobId +</span><br><span class="line">            &quot; and allocation ID &quot; + tdd.getAllocationId() + &#39;.&#39;;</span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; re-integrate offloaded data:</span><br><span class="line">      try &#123;</span><br><span class="line">         tdd.loadBigData(blobCacheService.getPermanentBlobService());</span><br><span class="line">      &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not re-integrate offloaded TaskDeploymentDescriptor data.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; deserialize the pre-serialized information</span><br><span class="line">      final JobInformation jobInformation;</span><br><span class="line">      final TaskInformation taskInformation;</span><br><span class="line">      try &#123;</span><br><span class="line">         jobInformation &#x3D; tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">         taskInformation &#x3D; tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">      &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not deserialize the job or task information.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!jobId.equals(jobInformation.getJobId())) &#123;</span><br><span class="line">         throw new TaskSubmissionException(</span><br><span class="line">            &quot;Inconsistent job ID information inside TaskDeploymentDescriptor (&quot; +</span><br><span class="line">               tdd.getJobId() + &quot; vs. &quot; + jobInformation.getJobId() + &quot;)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TaskMetricGroup taskMetricGroup &#x3D; taskManagerMetricGroup.addTaskForJob(</span><br><span class="line">         jobInformation.getJobId(),</span><br><span class="line">         jobInformation.getJobName(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         taskInformation.getTaskName(),</span><br><span class="line">         tdd.getSubtaskIndex(),</span><br><span class="line">         tdd.getAttemptNumber());</span><br><span class="line"></span><br><span class="line">      InputSplitProvider inputSplitProvider &#x3D; new RpcInputSplitProvider(</span><br><span class="line">         jobManagerConnection.getJobManagerGateway(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">      TaskManagerActions taskManagerActions &#x3D; jobManagerConnection.getTaskManagerActions();</span><br><span class="line">      CheckpointResponder checkpointResponder &#x3D; jobManagerConnection.getCheckpointResponder();</span><br><span class="line">      GlobalAggregateManager aggregateManager &#x3D; jobManagerConnection.getGlobalAggregateManager();</span><br><span class="line"></span><br><span class="line">      LibraryCacheManager libraryCache &#x3D; jobManagerConnection.getLibraryCacheManager();</span><br><span class="line">      ResultPartitionConsumableNotifier resultPartitionConsumableNotifier &#x3D; jobManagerConnection.getResultPartitionConsumableNotifier();</span><br><span class="line">      PartitionProducerStateChecker partitionStateChecker &#x3D; jobManagerConnection.getPartitionStateChecker();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Task本地状态保存</span><br><span class="line">      final TaskLocalStateStore localStateStore &#x3D; localStateStoresManager.localStateStoreForSubtask(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getSubtaskIndex());</span><br><span class="line"></span><br><span class="line">      final JobManagerTaskRestore taskRestore &#x3D; tdd.getTaskRestore();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Task状态管理</span><br><span class="line">      final TaskStateManager taskStateManager &#x3D; new TaskStateManagerImpl(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         localStateStore,</span><br><span class="line">         taskRestore,</span><br><span class="line">         checkpointResponder);</span><br><span class="line"></span><br><span class="line">      MemoryManager memoryManager;</span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;task内存管理</span><br><span class="line">         memoryManager &#x3D; taskSlotTable.getTaskMemoryManager(tdd.getAllocationId());</span><br><span class="line">      &#125; catch (SlotNotFoundException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not submit task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;taskmanager初始化task</span><br><span class="line">      Task task &#x3D; new Task(</span><br><span class="line">         jobInformation,</span><br><span class="line">         taskInformation,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         tdd.getSubtaskIndex(),</span><br><span class="line">         tdd.getAttemptNumber(),</span><br><span class="line">         tdd.getProducedPartitions(),</span><br><span class="line">         tdd.getInputGates(),</span><br><span class="line">         tdd.getTargetSlotNumber(),</span><br><span class="line">         memoryManager,</span><br><span class="line">         taskExecutorServices.getIOManager(),</span><br><span class="line">         taskExecutorServices.getShuffleEnvironment(),</span><br><span class="line">         taskExecutorServices.getKvStateService(),</span><br><span class="line">         taskExecutorServices.getBroadcastVariableManager(),</span><br><span class="line">         taskExecutorServices.getTaskEventDispatcher(),</span><br><span class="line">         taskStateManager,</span><br><span class="line">         taskManagerActions,</span><br><span class="line">         inputSplitProvider,</span><br><span class="line">         checkpointResponder,</span><br><span class="line">         aggregateManager,</span><br><span class="line">         blobCacheService,</span><br><span class="line">         libraryCache,</span><br><span class="line">         fileCache,</span><br><span class="line">         taskManagerConfiguration,</span><br><span class="line">         taskMetricGroup,</span><br><span class="line">         resultPartitionConsumableNotifier,</span><br><span class="line">         partitionStateChecker,</span><br><span class="line">         getRpcService().getExecutor());</span><br><span class="line"></span><br><span class="line">      taskMetricGroup.gauge(MetricNames.IS_BACKPRESSURED, task::isBackPressured);</span><br><span class="line"></span><br><span class="line">      log.info(&quot;Received task &#123;&#125;.&quot;, task.getTaskInfo().getTaskNameWithSubtasks());</span><br><span class="line"></span><br><span class="line">      boolean taskAdded;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         taskAdded &#x3D; taskSlotTable.addTask(task);</span><br><span class="line">      &#125; catch (SlotNotFoundException | SlotNotActiveException e) &#123;</span><br><span class="line">         throw new TaskSubmissionException(&quot;Could not submit task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (taskAdded) &#123;</span><br><span class="line">      &#x2F;&#x2F;启动task</span><br><span class="line">         task.startTaskThread();</span><br><span class="line"></span><br><span class="line">         setupResultPartitionBookkeeping(</span><br><span class="line">            tdd.getJobId(),</span><br><span class="line">            tdd.getProducedPartitions(),</span><br><span class="line">            task.getTerminationFuture());</span><br><span class="line">         return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         final String message &#x3D; &quot;TaskManager already contains a task for id &quot; +</span><br><span class="line">            task.getExecutionId() + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">         log.debug(message);</span><br><span class="line">         throw new TaskSubmissionException(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (TaskSubmissionException e) &#123;</span><br><span class="line">      return FutureUtils.completedExceptionally(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化Task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Runnable, TaskSlotPayload, TaskActions, PartitionProducerStateProvider, CheckpointListener, BackPressureSampleableTask &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * &lt;p&gt;&lt;b&gt;IMPORTANT:&lt;&#x2F;b&gt; This constructor may not start any work that would need to</span><br><span class="line">    * be undone in the case of a failing task deployment.&lt;&#x2F;p&gt;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Task(</span><br><span class="line">      JobInformation jobInformation,</span><br><span class="line">      TaskInformation taskInformation,</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      AllocationID slotAllocationId,</span><br><span class="line">      int subtaskIndex,</span><br><span class="line">      int attemptNumber,</span><br><span class="line">      Collection&lt;ResultPartitionDeploymentDescriptor&gt; resultPartitionDeploymentDescriptors,</span><br><span class="line">      Collection&lt;InputGateDeploymentDescriptor&gt; inputGateDeploymentDescriptors,</span><br><span class="line">      int targetSlotNumber,</span><br><span class="line">      MemoryManager memManager,</span><br><span class="line">      IOManager ioManager,</span><br><span class="line">      ShuffleEnvironment&lt;?, ?&gt; shuffleEnvironment,</span><br><span class="line">      KvStateService kvStateService,</span><br><span class="line">      BroadcastVariableManager bcVarManager,</span><br><span class="line">      TaskEventDispatcher taskEventDispatcher,</span><br><span class="line">      TaskStateManager taskStateManager,</span><br><span class="line">      TaskManagerActions taskManagerActions,</span><br><span class="line">      InputSplitProvider inputSplitProvider,</span><br><span class="line">      CheckpointResponder checkpointResponder,</span><br><span class="line">      GlobalAggregateManager aggregateManager,</span><br><span class="line">      BlobCacheService blobService,</span><br><span class="line">      LibraryCacheManager libraryCache,</span><br><span class="line">      FileCache fileCache,</span><br><span class="line">      TaskManagerRuntimeInfo taskManagerConfig,</span><br><span class="line">      @Nonnull TaskMetricGroup metricGroup,</span><br><span class="line">      ResultPartitionConsumableNotifier resultPartitionConsumableNotifier,</span><br><span class="line">      PartitionProducerStateChecker partitionProducerStateChecker,</span><br><span class="line">      Executor executor) &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      this.taskInfo &#x3D; new TaskInfo(</span><br><span class="line">            taskInformation.getTaskName(),</span><br><span class="line">            taskInformation.getMaxNumberOfSubtaks(),</span><br><span class="line">            subtaskIndex,</span><br><span class="line">            taskInformation.getNumberOfSubtasks(),</span><br><span class="line">            attemptNumber,</span><br><span class="line">            String.valueOf(slotAllocationId));</span><br><span class="line"></span><br><span class="line">      this.jobId &#x3D; jobInformation.getJobId();</span><br><span class="line">      this.vertexId &#x3D; taskInformation.getJobVertexId();</span><br><span class="line">      this.executionId  &#x3D; Preconditions.checkNotNull(executionAttemptID);</span><br><span class="line">      this.allocationId &#x3D; Preconditions.checkNotNull(slotAllocationId);</span><br><span class="line">      this.taskNameWithSubtask &#x3D; taskInfo.getTaskNameWithSubtasks();</span><br><span class="line">      this.jobConfiguration &#x3D; jobInformation.getJobConfiguration();</span><br><span class="line">      this.taskConfiguration &#x3D; taskInformation.getTaskConfiguration();</span><br><span class="line">      this.requiredJarFiles &#x3D; jobInformation.getRequiredJarFileBlobKeys();</span><br><span class="line">      this.requiredClasspaths &#x3D; jobInformation.getRequiredClasspathURLs();</span><br><span class="line">      this.nameOfInvokableClass &#x3D; taskInformation.getInvokableClassName();</span><br><span class="line">      this.serializedExecutionConfig &#x3D; jobInformation.getSerializedExecutionConfig();</span><br><span class="line"></span><br><span class="line">      Configuration tmConfig &#x3D; taskManagerConfig.getConfiguration();</span><br><span class="line">      this.taskCancellationInterval &#x3D; tmConfig.getLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL);</span><br><span class="line">      this.taskCancellationTimeout &#x3D; tmConfig.getLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT);</span><br><span class="line"></span><br><span class="line">      this.memoryManager &#x3D; Preconditions.checkNotNull(memManager);</span><br><span class="line">      this.ioManager &#x3D; Preconditions.checkNotNull(ioManager);</span><br><span class="line">      this.broadcastVariableManager &#x3D; Preconditions.checkNotNull(bcVarManager);</span><br><span class="line">      this.taskEventDispatcher &#x3D; Preconditions.checkNotNull(taskEventDispatcher);</span><br><span class="line">      this.taskStateManager &#x3D; Preconditions.checkNotNull(taskStateManager);</span><br><span class="line">      this.accumulatorRegistry &#x3D; new AccumulatorRegistry(jobId, executionId);</span><br><span class="line"></span><br><span class="line">      this.inputSplitProvider &#x3D; Preconditions.checkNotNull(inputSplitProvider);</span><br><span class="line">      this.checkpointResponder &#x3D; Preconditions.checkNotNull(checkpointResponder);</span><br><span class="line">      this.aggregateManager &#x3D; Preconditions.checkNotNull(aggregateManager);</span><br><span class="line">      this.taskManagerActions &#x3D; checkNotNull(taskManagerActions);</span><br><span class="line"></span><br><span class="line">      this.blobService &#x3D; Preconditions.checkNotNull(blobService);</span><br><span class="line">      this.libraryCache &#x3D; Preconditions.checkNotNull(libraryCache);</span><br><span class="line">      this.fileCache &#x3D; Preconditions.checkNotNull(fileCache);</span><br><span class="line">      this.kvStateService &#x3D; Preconditions.checkNotNull(kvStateService);</span><br><span class="line">      this.taskManagerConfig &#x3D; Preconditions.checkNotNull(taskManagerConfig);</span><br><span class="line"></span><br><span class="line">      this.metrics &#x3D; metricGroup;</span><br><span class="line"></span><br><span class="line">      this.partitionProducerStateChecker &#x3D; Preconditions.checkNotNull(partitionProducerStateChecker);</span><br><span class="line">      this.executor &#x3D; Preconditions.checkNotNull(executor);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; create the reader and writer structures</span><br><span class="line"></span><br><span class="line">      final String taskNameWithSubtaskAndId &#x3D; taskNameWithSubtask + &quot; (&quot; + executionId + &#39;)&#39;;</span><br><span class="line"></span><br><span class="line">      final ShuffleIOOwnerContext taskShuffleContext &#x3D; shuffleEnvironment</span><br><span class="line">         .createShuffleIOOwnerContext(taskNameWithSubtaskAndId, executionId, metrics.getIOMetricGroup());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; produced intermediate result partitions</span><br><span class="line">      &#x2F;&#x2F;创建ResultPartition</span><br><span class="line">      final ResultPartitionWriter[] resultPartitionWriters &#x3D; shuffleEnvironment.createResultPartitionWriters(</span><br><span class="line">         taskShuffleContext,</span><br><span class="line">         resultPartitionDeploymentDescriptors).toArray(new ResultPartitionWriter[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">      this.consumableNotifyingPartitionWriters &#x3D; ConsumableNotifyingResultPartitionWriterDecorator.decorate(</span><br><span class="line">         resultPartitionDeploymentDescriptors,</span><br><span class="line">         resultPartitionWriters,</span><br><span class="line">         this,</span><br><span class="line">         jobId,</span><br><span class="line">         resultPartitionConsumableNotifier);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; consumed intermediate result partitions</span><br><span class="line">      &#x2F;&#x2F;创建InputGate</span><br><span class="line">      final InputGate[] gates &#x3D; shuffleEnvironment.createInputGates(</span><br><span class="line">         taskShuffleContext,</span><br><span class="line">         this,</span><br><span class="line">         inputGateDeploymentDescriptors).toArray(new InputGate[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">      this.inputGates &#x3D; new InputGate[gates.length];</span><br><span class="line">      int counter &#x3D; 0;</span><br><span class="line">      for (InputGate gate : gates) &#123;</span><br><span class="line">         inputGates[counter++] &#x3D; new InputGateWithMetrics(gate, metrics.getIOMetricGroup().getNumBytesInCounter());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (shuffleEnvironment instanceof NettyShuffleEnvironment) &#123;</span><br><span class="line">         &#x2F;&#x2F;noinspection deprecation</span><br><span class="line">         ((NettyShuffleEnvironment) shuffleEnvironment)</span><br><span class="line">            .registerLegacyNetworkMetrics(metrics.getIOMetricGroup(), resultPartitionWriters, gates);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      invokableHasBeenCanceled &#x3D; new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; finally, create the executing thread, but do not start it</span><br><span class="line">      executingThread &#x3D; new Thread(TASK_THREADS_GROUP, this, taskNameWithSubtask);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>TaskSlotTable的addTask添加Task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean addTask(T task) throws SlotNotFoundException, SlotNotActiveException &#123;</span><br><span class="line">   checkRunning();</span><br><span class="line">   Preconditions.checkNotNull(task);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取该Task的slot信息</span><br><span class="line">   TaskSlot&lt;T&gt; taskSlot &#x3D; getTaskSlot(task.getAllocationId());</span><br><span class="line"></span><br><span class="line">   if (taskSlot !&#x3D; null) &#123;</span><br><span class="line">      if (taskSlot.isActive(task.getJobID(), task.getAllocationId())) &#123;</span><br><span class="line">         if (taskSlot.add(task)) &#123;</span><br><span class="line">         &#x2F;&#x2F;添加task和slot的映射</span><br><span class="line">            taskSlotMappings.put(task.getExecutionId(), new TaskSlotMapping&lt;&gt;(task, taskSlot));</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         throw new SlotNotActiveException(task.getJobID(), task.getAllocationId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new SlotNotFoundException(task.getAllocationId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>task.startTaskThread()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">public void startTaskThread() &#123;</span><br><span class="line">		executingThread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      doRun();</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      terminationFuture.complete(executionState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doRun() &#123;</span><br><span class="line">   &#x2F;&#x2F; ----------------------------</span><br><span class="line">   &#x2F;&#x2F;  Initial State transition</span><br><span class="line">   &#x2F;&#x2F; ----------------------------</span><br><span class="line">   while (true) &#123;</span><br><span class="line">      ExecutionState current &#x3D; this.executionState;</span><br><span class="line">      if (current &#x3D;&#x3D; ExecutionState.CREATED) &#123;</span><br><span class="line">      &#x2F;&#x2F;把CREATED状态转为DEPLOYING</span><br><span class="line">         if (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</span><br><span class="line">            &#x2F;&#x2F; success, we can start our work</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (current &#x3D;&#x3D; ExecutionState.FAILED) &#123;</span><br><span class="line">         &#x2F;&#x2F; we were immediately failed. tell the TaskManager that we reached our final state</span><br><span class="line">         notifyFinalState();</span><br><span class="line">         if (metrics !&#x3D; null) &#123;</span><br><span class="line">            metrics.close();</span><br><span class="line">         &#125;</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (current &#x3D;&#x3D; ExecutionState.CANCELING) &#123;</span><br><span class="line">         if (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</span><br><span class="line">            &#x2F;&#x2F; we were immediately canceled. tell the TaskManager that we reached our final state</span><br><span class="line">            notifyFinalState();</span><br><span class="line">            if (metrics !&#x3D; null) &#123;</span><br><span class="line">               metrics.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         if (metrics !&#x3D; null) &#123;</span><br><span class="line">            metrics.close();</span><br><span class="line">         &#125;</span><br><span class="line">         throw new IllegalStateException(&quot;Invalid state for beginning of operation of task &quot; + this + &#39;.&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; all resource acquisitions and registrations from here on</span><br><span class="line">   &#x2F;&#x2F; need to be undone in the end</span><br><span class="line">   Map&lt;String, Future&lt;Path&gt;&gt; distributedCacheEntries &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   AbstractInvokable invokable &#x3D; null;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; ----------------------------</span><br><span class="line">      &#x2F;&#x2F;  Task Bootstrap - We periodically</span><br><span class="line">      &#x2F;&#x2F;  check for canceling as a shortcut</span><br><span class="line">      &#x2F;&#x2F; ----------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; activate safety net for task thread</span><br><span class="line">      LOG.info(&quot;Creating FileSystem stream leak safety net for task &#123;&#125;&quot;, this);</span><br><span class="line">      FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line"></span><br><span class="line">      blobService.getPermanentBlobService().registerJob(jobId);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; first of all, get a user-code classloader</span><br><span class="line">      &#x2F;&#x2F; this may involve downloading the job&#39;s JAR files and&#x2F;or classes</span><br><span class="line">      LOG.info(&quot;Loading JAR files for task &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">      userCodeClassLoader &#x3D; createUserCodeClassloader();</span><br><span class="line">      final ExecutionConfig executionConfig &#x3D; serializedExecutionConfig.deserializeValue(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">      if (executionConfig.getTaskCancellationInterval() &gt;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; override task cancellation interval from Flink config if set in ExecutionConfig</span><br><span class="line">         taskCancellationInterval &#x3D; executionConfig.getTaskCancellationInterval();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (executionConfig.getTaskCancellationTimeout() &gt;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; override task cancellation timeout from Flink config if set in ExecutionConfig</span><br><span class="line">         taskCancellationTimeout &#x3D; executionConfig.getTaskCancellationTimeout();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F; register the task with the network stack</span><br><span class="line">      &#x2F;&#x2F; this operation may fail if the system does not have enough</span><br><span class="line">      &#x2F;&#x2F; memory to run the necessary data exchanges</span><br><span class="line">      &#x2F;&#x2F; the registration must also strictly be undone</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      LOG.info(&quot;Registering task at network: &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化ResultPartition和InputGate，注册BufferPool</span><br><span class="line">      setupPartitionsAndGates(consumableNotifyingPartitionWriters, inputGates);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将ResultPartition注册到EventDispatcher，添加接收消息事件的监听</span><br><span class="line">      for (ResultPartitionWriter partitionWriter : consumableNotifyingPartitionWriters) &#123;</span><br><span class="line">         taskEventDispatcher.registerPartition(partitionWriter.getPartitionId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件写入分布式缓存</span><br><span class="line">      &#x2F;&#x2F; next, kick off the background copying of files for the distributed cache</span><br><span class="line">      try &#123;</span><br><span class="line">         for (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; entry :</span><br><span class="line">               DistributedCache.readFileInfoFromConfig(jobConfiguration)) &#123;</span><br><span class="line">            LOG.info(&quot;Obtaining local cache file for &#39;&#123;&#125;&#39;.&quot;, entry.getKey());</span><br><span class="line">            Future&lt;Path&gt; cp &#x3D; fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);</span><br><span class="line">            distributedCacheEntries.put(entry.getKey(), cp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new Exception(</span><br><span class="line">            String.format(&quot;Exception while adding files to distributed cache of task %s (%s).&quot;, taskNameWithSubtask, executionId), e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  call the user code initialization methods</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      TaskKvStateRegistry kvStateRegistry &#x3D; kvStateService.createKvStateTaskRegistry(jobId, getJobVertexId());</span><br><span class="line"></span><br><span class="line">      Environment env &#x3D; new RuntimeEnvironment(</span><br><span class="line">         jobId,</span><br><span class="line">         vertexId,</span><br><span class="line">         executionId,</span><br><span class="line">         executionConfig,</span><br><span class="line">         taskInfo,</span><br><span class="line">         jobConfiguration,</span><br><span class="line">         taskConfiguration,</span><br><span class="line">         userCodeClassLoader,</span><br><span class="line">         memoryManager,</span><br><span class="line">         ioManager,</span><br><span class="line">         broadcastVariableManager,</span><br><span class="line">         taskStateManager,</span><br><span class="line">         aggregateManager,</span><br><span class="line">         accumulatorRegistry,</span><br><span class="line">         kvStateRegistry,</span><br><span class="line">         inputSplitProvider,</span><br><span class="line">         distributedCacheEntries,</span><br><span class="line">         consumableNotifyingPartitionWriters,</span><br><span class="line">         inputGates,</span><br><span class="line">         taskEventDispatcher,</span><br><span class="line">         checkpointResponder,</span><br><span class="line">         taskManagerConfig,</span><br><span class="line">         metrics,</span><br><span class="line">         this);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure the user code classloader is accessible thread-locally.</span><br><span class="line">      &#x2F;&#x2F; We are setting the correct context class loader before instantiating the invokable</span><br><span class="line">      &#x2F;&#x2F; so that it is available to the invokable during its entire lifetime.</span><br><span class="line">      executingThread.setContextClassLoader(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每一个 StreamNode 在添加的时候都会有一个 jobVertexClass 属性</span><br><span class="line">			&#x2F;&#x2F; 对于一个 operator chain，就是 head operator 对应的 invokableClassName，见 StreamingJobGraphGenerator.createChain</span><br><span class="line">			&#x2F;&#x2F; 通过反射创建 AbstractInvokable 对象</span><br><span class="line">			&#x2F;&#x2F; 对于 Stream 任务而言，就是 StreamTask 的子类，SourceStreamTask、OneInputStreamTask、TwoInputStreamTask 等</span><br><span class="line">      &#x2F;&#x2F; now load and instantiate the task&#39;s invokable code</span><br><span class="line">      invokable &#x3D; loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  actual task core work</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we must make strictly sure that the invokable is accessible to the cancel() call</span><br><span class="line">      &#x2F;&#x2F; by the time we switched to running.</span><br><span class="line">      this.invokable &#x3D; invokable;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; switch to the RUNNING state, if that fails, we have been canceled&#x2F;failed in the meantime</span><br><span class="line">      if (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; notify everyone that we switched to running</span><br><span class="line">      taskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure the user code classloader is accessible thread-locally</span><br><span class="line">      executingThread.setContextClassLoader(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; run the invokable</span><br><span class="line">      &#x2F;&#x2F;运行StreamTask</span><br><span class="line">      invokable.invoke();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure, we enter the catch block if the task leaves the invoke() method due</span><br><span class="line">      &#x2F;&#x2F; to the fact that it has been canceled</span><br><span class="line">      if (isCanceledOrFailed()) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">      &#x2F;&#x2F;  finalization of a successful execution</span><br><span class="line">      &#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; finish the produced partitions. if this fails, we consider the execution failed.</span><br><span class="line">      for (ResultPartitionWriter partitionWriter : consumableNotifyingPartitionWriters) &#123;</span><br><span class="line">         if (partitionWriter !&#x3D; null) &#123;</span><br><span class="line">            partitionWriter.finish();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; try to mark the task as finished</span><br><span class="line">      &#x2F;&#x2F; if that fails, the task was canceled&#x2F;failed in the meantime</span><br><span class="line">      if (!transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable t) &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractInvokable的invoke调用StreamTask的invoke，<code>StreamTask</code> 完整的生命周期包括：</p>
<ul>
<li>创建状态存储后端，为 OperatorChain 中的所有算子提供状态</li>
<li>加载 OperatorChain 中的所有算子</li>
<li>所有的 operator 调用 <code>setup</code></li>
<li>task 相关的初始化操作</li>
<li>所有 operator 调用 <code>initializeState</code> 初始化状态</li>
<li>所有的 operator 调用 <code>open</code></li>
<li>runMailboxLoop 方法循环处理数据</li>
<li>所有 operator 调用 <code>close</code></li>
<li>所有 operator 调用 <code>dispose</code></li>
<li>通用的 cleanup 操作</li>
<li>task 相关的 cleanup 操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final void invoke() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      beforeInvoke();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; final check to exit early before starting to run</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; let the task do its work</span><br><span class="line">      isRunning &#x3D; true;</span><br><span class="line">      runMailboxLoop();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; if this left the run() method cleanly despite the fact that this was canceled,</span><br><span class="line">      &#x2F;&#x2F; make sure the &quot;clean shutdown&quot; is not attempted</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">         throw new CancelTaskException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      afterInvoke();</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      cleanUpInvoke();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beforeInvoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void beforeInvoke() throws Exception &#123;</span><br><span class="line">   disposedOperators &#x3D; false;</span><br><span class="line">   LOG.debug(&quot;Initializing &#123;&#125;.&quot;, getName());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;准备异步线程池</span><br><span class="line">   asyncOperationsThreadPool &#x3D; Executors.newCachedThreadPool(new ExecutorThreadFactory(&quot;AsyncOperations&quot;, uncaughtExceptionHandler));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建状态存储后端</span><br><span class="line">   stateBackend &#x3D; createStateBackend();</span><br><span class="line">   checkpointStorage &#x3D; stateBackend.createCheckpointStorage(getEnvironment().getJobID());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; if the clock is not already set, then assign a default TimeServiceProvider</span><br><span class="line">   if (timerService &#x3D;&#x3D; null) &#123;</span><br><span class="line">      ThreadFactory timerThreadFactory &#x3D;</span><br><span class="line">         new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, &quot;Time Trigger for &quot; + getName());</span><br><span class="line"></span><br><span class="line">      timerService &#x3D; new SystemProcessingTimeService(</span><br><span class="line">         this::handleTimerException,</span><br><span class="line">         timerThreadFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 OperatorChain，会加载每一个 operator，并调用 setup 方法</span><br><span class="line">   operatorChain &#x3D; new OperatorChain&lt;&gt;(this, recordWriter);</span><br><span class="line">   headOperator &#x3D; operatorChain.getHeadOperator();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; task specific initialization</span><br><span class="line">   &#x2F;&#x2F; 由具体 StreamTask 子类实现初始化操作</span><br><span class="line">   init();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; save the work of reloading state, etc, if the task is already canceled</span><br><span class="line">   if (canceled) &#123;</span><br><span class="line">      throw new CancelTaskException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; -------- Invoke --------</span><br><span class="line">   LOG.debug(&quot;Invoking &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we need to make sure that any triggers scheduled in open() cannot be</span><br><span class="line">   &#x2F;&#x2F; executed before all operators are opened</span><br><span class="line">   actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; both the following operations are protected by the lock</span><br><span class="line">      &#x2F;&#x2F; so that we avoid race conditions in the case that initializeState()</span><br><span class="line">      &#x2F;&#x2F; registers a timer, that fires before the open() is called.</span><br><span class="line"></span><br><span class="line">      initializeStateAndOpen();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void initializeStateAndOpen() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   StreamOperator&lt;?&gt;[] allOperators &#x3D; operatorChain.getAllOperators();</span><br><span class="line">&#x2F;&#x2F;初始化operatorChain的所有StreamOperator状态并调用open方法</span><br><span class="line">   for (StreamOperator&lt;?&gt; operator : allOperators) &#123;</span><br><span class="line">      if (null !&#x3D; operator) &#123;</span><br><span class="line">         operator.initializeState();</span><br><span class="line">         operator.open();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beforeInvoke初始化之后进入task主流程runMailboxLoop()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void runMailboxLoop() throws Exception &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;进入 mailboxProcessor</span><br><span class="line">      mailboxProcessor.runMailboxLoop();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      Optional&lt;InterruptedException&gt; interruption &#x3D; ExceptionUtils.findThrowable(e, InterruptedException.class);</span><br><span class="line">      if (interruption.isPresent()) &#123;</span><br><span class="line">         if (!canceled) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            throw interruption.get();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else if (canceled) &#123;</span><br><span class="line">         LOG.warn(&quot;Error while canceling task.&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         throw e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MailboxProcessor类,Mailbox的结构用来保证单线程执行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void runMailboxLoop() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   final TaskMailbox localMailbox &#x3D; mailbox;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查当前运行线程是否是 mailbox 线程，只有 mailbox 线程能运行该方法</span><br><span class="line">   Preconditions.checkState(</span><br><span class="line">      localMailbox.isMailboxThread(),</span><br><span class="line">      &quot;Method must be executed by declared mailbox thread!&quot;);</span><br><span class="line"></span><br><span class="line">   assert localMailbox.getState() &#x3D;&#x3D; TaskMailbox.State.OPEN : &quot;Mailbox must be opened!&quot;;</span><br><span class="line"></span><br><span class="line">   final MailboxController defaultActionContext &#x3D; new MailboxController(this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有 mail 需要处理，这里会进行相应的处理，处理完才会进行下面的 event processing，进行 task 的 default action，也就是调用 processInput()</span><br><span class="line">   while (processMail(localMailbox)) &#123;</span><br><span class="line">      mailboxDefaultAction.runDefaultAction(defaultActionContext); &#x2F;&#x2F; lock is acquired inside default action as needed</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processMail会检测 MailBox中是否有 mail 需要处理，如果有的话，就做相应的处理，<strong>一直将全部的 mail 处理完才会返回</strong>，只要 loop 还在进行，这里就会返回 true，否则会返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private boolean processMail(TaskMailbox mailbox) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only</span><br><span class="line">   &#x2F;&#x2F; acquired after this point.</span><br><span class="line">   &#x2F;&#x2F;taskmailbox 会将 queue 中的消息移到 batch，然后从 batch queue 中依次 take；新 mail 写入 queue。从 batch take 时避免加锁</span><br><span class="line">   if (!mailbox.createBatch()) &#123;</span><br><span class="line">      &#x2F;&#x2F; We can also directly return true because all changes to #isMailboxLoopRunning must be connected to</span><br><span class="line">      &#x2F;&#x2F; mailbox.hasMail() &#x3D;&#x3D; true.</span><br><span class="line">      &#x2F;&#x2F; 消息为空时直接返回</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Take mails in a non-blockingly and execute them.</span><br><span class="line">   Optional&lt;Mail&gt; maybeMail;</span><br><span class="line">   &#x2F;&#x2F; 从 batch 获取 mail 执行，直到 batch 中的 mail 处理完</span><br><span class="line">   while (isMailboxLoopRunning() &amp;&amp; (maybeMail &#x3D; mailbox.tryTakeFromBatch()).isPresent()) &#123;</span><br><span class="line">      maybeMail.get().run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; If the default action is currently not available, we can run a blocking mailbox execution until the default</span><br><span class="line">   &#x2F;&#x2F; action becomes available again.</span><br><span class="line">   &#x2F;&#x2F;做一个状态检查，等待mail状态变为available</span><br><span class="line">   while (isDefaultActionUnavailable() &amp;&amp; isMailboxLoopRunning()) &#123;</span><br><span class="line">      mailbox.take(MIN_PRIORITY).run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return isMailboxLoopRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理完Mailbox，进入MailboxDefaultAction类的runDefaultAction，最终进入StreamTask的processInput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.mailboxProcessor &#x3D; new MailboxProcessor(this::processInput, mailbox, actionExecutor);</span><br></pre></td></tr></table></figure>

<p>对于 StreamTask 来说，event-processing 是在 processInput() 方法中实现的，调用StreamInputProcessor的processInput处理数据，StreamInputProcessor是StreamTask的成员变量，子类有StreamOneInputProcessor和StreamTwoInputProcessor，分别对应OneInputStreamTask和TwoInputStreamTask的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void processInput(MailboxDefaultAction.Controller controller) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; event 处理</span><br><span class="line">   InputStatus status &#x3D; inputProcessor.processInput();</span><br><span class="line">   &#x2F;&#x2F; 如果输入还有数据，并且 recordWriter 是可用的(之前的异步操作已经处理完成)，这里就直接返回了</span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.MORE_AVAILABLE &amp;&amp; recordWriter.isAvailable()) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.END_OF_INPUT) &#123;</span><br><span class="line">   &#x2F;&#x2F; 输入已经处理完了</span><br><span class="line">      controller.allActionsCompleted();</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 代码进行到这里说明 input 或 output 没有准备好（比如当前流中没有数据）</span><br><span class="line">   CompletableFuture&lt;?&gt; jointFuture &#x3D; getInputOutputJointFuture(status);</span><br><span class="line">   &#x2F;&#x2F; 告诉 MailBox 先暂停 loop</span><br><span class="line">   MailboxDefaultAction.Suspension suspendedDefaultAction &#x3D; controller.suspendDefaultAction();</span><br><span class="line">   &#x2F;&#x2F; 等待 future 完成后，继续 mailbox loop（等待 input 和 output 可用后，才会继续）</span><br><span class="line">   jointFuture.thenRun(suspendedDefaultAction::resume);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface StreamInputProcessor extends AvailabilityProvider, Closeable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * @return input status to estimate whether more records can be processed immediately or not.</span><br><span class="line">    * If there are no more records available at the moment and the caller should check finished</span><br><span class="line">    * state and&#x2F;or &#123;@link #getAvailableFuture()&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   InputStatus processInput() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以OneInputStreamTask看下StreamOneInputProcessor的处理过程,在调用的时候init会初始化StreamOneInputProcessor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OneInputStreamTask&lt;IN, OUT&gt; extends StreamTask&#123;</span><br><span class="line">@Override</span><br><span class="line">	public void init() throws Exception &#123;</span><br><span class="line">		StreamConfig configuration &#x3D; getConfiguration();</span><br><span class="line">		int numberOfInputs &#x3D; configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">		if (numberOfInputs &gt; 0) &#123;</span><br><span class="line">			CheckpointedInputGate inputGate &#x3D; createCheckpointedInputGate();</span><br><span class="line">			TaskIOMetricGroup taskIOMetricGroup &#x3D; getEnvironment().getMetricGroup().getIOMetricGroup();</span><br><span class="line">			taskIOMetricGroup.gauge(&quot;checkpointAlignmentTime&quot;, inputGate::getAlignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">			DataOutput&lt;IN&gt; output &#x3D; createDataOutput();</span><br><span class="line">			StreamTaskInput&lt;IN&gt; input &#x3D; createTaskInput(inputGate, output);</span><br><span class="line">			&#x2F;&#x2F;初始化StreamOneInputProcessor</span><br><span class="line">			inputProcessor &#x3D; new StreamOneInputProcessor&lt;&gt;(</span><br><span class="line">				input,</span><br><span class="line">				output,</span><br><span class="line">				getCheckpointLock(),</span><br><span class="line">				operatorChain);</span><br><span class="line">		&#125;</span><br><span class="line">		headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge);</span><br><span class="line">		&#x2F;&#x2F; wrap watermark gauge since registered metrics must be unique</span><br><span class="line">		getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge::getValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后在处理数据时调用StreamOneInputProcessor的processInput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public InputStatus processInput() throws Exception &#123;</span><br><span class="line">   InputStatus status &#x3D; input.emitNext(output);</span><br><span class="line"></span><br><span class="line">   if (status &#x3D;&#x3D; InputStatus.END_OF_INPUT) &#123;</span><br><span class="line">      synchronized (lock) &#123;</span><br><span class="line">         operatorChain.endHeadOperatorInput(1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用StreamTaskNetworkInput的emitNext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public InputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; get the stream element from the deserializer</span><br><span class="line">      &#x2F;&#x2F;反序列化</span><br><span class="line">      if (currentRecordDeserializer !&#x3D; null) &#123;</span><br><span class="line">         DeserializationResult result &#x3D; currentRecordDeserializer.getNextRecord(deserializationDelegate);</span><br><span class="line">         if (result.isBufferConsumed()) &#123;</span><br><span class="line">         &#x2F;&#x2F;如果buffer里面的数据已经被消费了，则归还buffer</span><br><span class="line">            currentRecordDeserializer.getCurrentBuffer().recycleBuffer();</span><br><span class="line">            currentRecordDeserializer &#x3D; null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (result.isFullRecord()) &#123;</span><br><span class="line">         &#x2F;&#x2F;得到了一条完整的记录</span><br><span class="line">            processElement(deserializationDelegate.getInstance(), output);</span><br><span class="line">            &#x2F;&#x2F; 处理完一条数据</span><br><span class="line">            return InputStatus.MORE_AVAILABLE;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;获取下一个 BufferOrEvent，这是个阻塞的调用</span><br><span class="line">      Optional&lt;BufferOrEvent&gt; bufferOrEvent &#x3D; checkpointedInputGate.pollNext();</span><br><span class="line">      if (bufferOrEvent.isPresent()) &#123;</span><br><span class="line">         processBufferOrEvent(bufferOrEvent.get());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         if (checkpointedInputGate.isFinished()) &#123;</span><br><span class="line">            checkState(checkpointedInputGate.getAvailableFuture().isDone(), &quot;Finished BarrierHandler should be available&quot;);</span><br><span class="line">            if (!checkpointedInputGate.isEmpty()) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;上游已结束</span><br><span class="line">            return InputStatus.END_OF_INPUT;</span><br><span class="line">         &#125;</span><br><span class="line">         return InputStatus.NOTHING_AVAILABLE;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processElement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void processElement(StreamElement recordOrMark, DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line">   if (recordOrMark.isRecord())&#123;</span><br><span class="line">   &#x2F;&#x2F;是一条正常的记录，调用 operator 的处理方法，最终会调用用户自定义的函数的处理方法</span><br><span class="line">      output.emitRecord(recordOrMark.asRecord());</span><br><span class="line">   &#125; else if (recordOrMark.isWatermark()) &#123;</span><br><span class="line">      statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel);</span><br><span class="line">   &#125; else if (recordOrMark.isLatencyMarker()) &#123;</span><br><span class="line">      output.emitLatencyMarker(recordOrMark.asLatencyMarker());</span><br><span class="line">   &#125; else if (recordOrMark.isStreamStatus()) &#123;</span><br><span class="line">      statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), lastChannel);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;Unknown type of StreamElement&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processBufferOrEvent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void processBufferOrEvent(BufferOrEvent bufferOrEvent) throws IOException &#123;</span><br><span class="line">   if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果是Buffer，要确定是哪个 channel 的，然后用对应 channel 的反序列化器解析</span><br><span class="line">					&#x2F;&#x2F;不同channel在反序列化的时候不能混淆</span><br><span class="line">      lastChannel &#x3D; bufferOrEvent.getChannelIndex();</span><br><span class="line">      checkState(lastChannel !&#x3D; StreamTaskInput.UNSPECIFIED);</span><br><span class="line">      currentRecordDeserializer &#x3D; recordDeserializers[lastChannel];</span><br><span class="line">      checkState(currentRecordDeserializer !&#x3D; null,</span><br><span class="line">         &quot;currentRecordDeserializer has already been released&quot;);</span><br><span class="line"></span><br><span class="line">      currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; Event received</span><br><span class="line">      final AbstractEvent event &#x3D; bufferOrEvent.getEvent();</span><br><span class="line">      &#x2F;&#x2F; TODO: with checkpointedInputGate.isFinished() we might not need to support any events on this level.</span><br><span class="line">      if (event.getClass() !&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">         throw new IOException(&quot;Unexpected event: &quot; + event);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; release the record deserializer immediately,</span><br><span class="line">      &#x2F;&#x2F; which is very valuable in case of bounded stream</span><br><span class="line">      releaseDeserializer(bufferOrEvent.getChannelIndex());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入StreamTaskNetworkOutput的emitRecord</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void emitRecord(StreamRecord&lt;IN&gt; record) throws Exception &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      numRecordsIn.inc();</span><br><span class="line">      operator.setKeyContextElement1(record);</span><br><span class="line">      operator.processElement(record);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 operator 的处理方法，最终会调用用户自定义的函数的处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">   output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SourceStreamTask的实现稍有不同，主要是因为有一个问题：就是 <em>SourceStreamTask</em>，会有一个兼容性的问题，因为在流的 source 端，它的 event prcessing 是来专门产生一个无限流数据，在这个处理中，并不能穿插 MailBox 中的 mail 检测，也就是说，如果只有一个 MailBox 线程处理的话，当这个线程去产生数据的话，它一直运行下去，就无法再去检测 MailBox 中是否有新的 mail 到来（在 Source 未来的版本中，可以完美兼容 MailBox 线程设计，见 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-27%3A+Refactor+Source+Interface" target="_blank" rel="noopener">FLIP-27</a>，但现在的版本还不兼容）。</p>
<p>为了兼容 Source 端，目前的解决方案是：<strong>两个线程操作，一个专门用产生无限流，另一个是 MailBox 线程（处理 Checkpoint、timer 等），这两个线程为了保证线程安全，还是使用 Checkpoint Lock 做排它锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected void processInput(MailboxDefaultAction.Controller controller) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 告诉 MailBox 先暂停 loop</span><br><span class="line">   controller.suspendDefaultAction();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Against the usual contract of this method, this implementation is not step-wise but blocking instead for</span><br><span class="line">   &#x2F;&#x2F; compatibility reasons with the current source interface (source functions run as a loop, not in steps).</span><br><span class="line">   sourceThread.setTaskDescription(getName());</span><br><span class="line">   sourceThread.start();</span><br><span class="line">   sourceThread.getCompletionFuture().whenComplete((Void ignore, Throwable sourceThreadThrowable) -&gt; &#123;</span><br><span class="line">      if (sourceThreadThrowable &#x3D;&#x3D; null || isFinished) &#123;</span><br><span class="line">      &#x2F;&#x2F; sourceThread 完成后，没有抛出异常或 task 完成的情况下</span><br><span class="line">         mailboxProcessor.allActionsCompleted();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 没有完成或者抛出异常的情况下</span><br><span class="line">         mailboxProcessor.reportThrowable(sourceThreadThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private class LegacySourceFunctionThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">		private final CompletableFuture&lt;Void&gt; completionFuture;</span><br><span class="line"></span><br><span class="line">		LegacySourceFunctionThread() &#123;</span><br><span class="line">			this.completionFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				headOperator.run(getCheckpointLock(), getStreamStatusMaintainer(), operatorChain);</span><br><span class="line">				completionFuture.complete(null);</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				&#x2F;&#x2F; Note, t can be also an InterruptedException</span><br><span class="line">				completionFuture.completeExceptionally(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void setTaskDescription(final String taskDescription) &#123;</span><br><span class="line">			setName(&quot;Legacy Source Thread - &quot; + taskDescription);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Void&gt; getCompletionFuture() &#123;</span><br><span class="line">			return completionFuture;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<p>1.<em>LegacySourceFunctionThread</em> 线程在启动时，会先通知一下 MailBox，这个就是上面说的那个状态检查，收到这个信号之后，MailBox 就会在 processMail() 中一直等待并且处理 mail，不会返回（也就是 MailBox 主线程一直在处理 mail 事件）；</p>
<p>2.<em>LegacySourceFunctionThread</em> 线程就是专门生产数据的，跟 MailBox 这两个线程都在运行。</p>
<p>那么两个线程如何保证线程安全呢？如果仔细看上面的代码就会发现，在 SourceStreamTask 中还继续使用了 getCheckpointLock()，虽然这个方法现在已经被标注了将要被废弃，但 Source 没有改造完成之前，Source 的实现还是会继续依赖 checkpoint lock。</p>
<p>数据处理完进入afterInvoke，所有 operator 调用 close，所有 operator 调用 dispose</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void afterInvoke() throws Exception &#123;</span><br><span class="line">   LOG.debug(&quot;Finished task &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure no further checkpoint and notification actions happen.</span><br><span class="line">   &#x2F;&#x2F; we make sure that no other thread is currently in the locked scope before</span><br><span class="line">   &#x2F;&#x2F; we close the operators by trying to acquire the checkpoint scope lock</span><br><span class="line">   &#x2F;&#x2F; we also need to make sure that no triggers fire concurrently with the close logic</span><br><span class="line">   &#x2F;&#x2F; at the same time, this makes sure that during any &quot;regular&quot; exit where still</span><br><span class="line">   actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; this is part of the main logic, so if this fails, the task is considered failed</span><br><span class="line">      closeAllOperators();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure no new timers can come</span><br><span class="line">      timerService.quiesce();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; let mailbox execution reject all new letters from this point</span><br><span class="line">      mailboxProcessor.prepareClose();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; only set the StreamTask to not running after all operators have been closed!</span><br><span class="line">      &#x2F;&#x2F; See FLINK-7430</span><br><span class="line">      isRunning &#x3D; false;</span><br><span class="line">   &#125;);</span><br><span class="line">   &#x2F;&#x2F; processes the remaining mails; no new mails can be enqueued</span><br><span class="line">   mailboxProcessor.drain();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure all timers finish</span><br><span class="line">   timerService.awaitPendingAfterQuiesce();</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Closed operators for task &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make sure all buffered data is flushed</span><br><span class="line">   operatorChain.flushOutputs();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; make an attempt to dispose the operators such that failures in the dispose call</span><br><span class="line">   &#x2F;&#x2F; still let the computation fail</span><br><span class="line">   disposeAllOperators(false);</span><br><span class="line">   disposedOperators &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下beforeinvoke中OperatorChain的初始化过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public OperatorChain(</span><br><span class="line">      StreamTask&lt;OUT, OP&gt; containingTask,</span><br><span class="line">      RecordWriterDelegate&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriterDelegate) &#123;</span><br><span class="line"></span><br><span class="line">   final ClassLoader userCodeClassloader &#x3D; containingTask.getUserCodeClassLoader();</span><br><span class="line">   final StreamConfig configuration &#x3D; containingTask.getConfiguration();</span><br><span class="line"></span><br><span class="line">   StreamOperatorFactory&lt;OUT&gt; operatorFactory &#x3D; configuration.getStreamOperatorFactory(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; we read the chained configs, and the order of record writer registrations by output name</span><br><span class="line">   &#x2F;&#x2F;OperatorChain 内部所有的 operator 的配置</span><br><span class="line">   Map&lt;Integer, StreamConfig&gt; chainedConfigs &#x3D; configuration.getTransitiveChainedTaskConfigsWithSelf(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create the final output stream writers</span><br><span class="line">   &#x2F;&#x2F; we iterate through all the out edges from this job vertex and create a stream output</span><br><span class="line">   &#x2F;&#x2F; 所有的输出边，这是对外输出，不包含内部 operator 之间的的数据传输</span><br><span class="line">   List&lt;StreamEdge&gt; outEdgesInOrder &#x3D; configuration.getOutEdgesInOrder(userCodeClassloader);</span><br><span class="line">   Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputMap &#x3D; new HashMap&lt;&gt;(outEdgesInOrder.size());</span><br><span class="line">   this.streamOutputs &#x3D; new RecordWriterOutput&lt;?&gt;[outEdgesInOrder.size()];</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; from here on, we need to make sure that the output writers are shut down again on failure</span><br><span class="line">   boolean success &#x3D; false;</span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建对外输出的 RecordWriterOutput</span><br><span class="line">      for (int i &#x3D; 0; i &lt; outEdgesInOrder.size(); i++) &#123;</span><br><span class="line">         StreamEdge outEdge &#x3D; outEdgesInOrder.get(i);</span><br><span class="line"></span><br><span class="line">         RecordWriterOutput&lt;?&gt; streamOutput &#x3D; createStreamOutput(</span><br><span class="line">            recordWriterDelegate.getRecordWriter(i),</span><br><span class="line">            outEdge,</span><br><span class="line">            chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">            containingTask.getEnvironment());</span><br><span class="line"></span><br><span class="line">         this.streamOutputs[i] &#x3D; streamOutput;</span><br><span class="line">         streamOutputMap.put(outEdge, streamOutput);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; we create the chain of operators and grab the collector that leads into the chain</span><br><span class="line">      &#x2F;&#x2F;这里会递归调用，为 OperatorChain 内部的所有的 Operator 都创建 output</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOps &#x3D; new ArrayList&lt;&gt;(chainedConfigs.size());</span><br><span class="line">      this.chainEntryPoint &#x3D; createOutputCollector(</span><br><span class="line">         containingTask,</span><br><span class="line">         configuration,</span><br><span class="line">         chainedConfigs,</span><br><span class="line">         userCodeClassloader,</span><br><span class="line">         streamOutputMap,</span><br><span class="line">         allOps,</span><br><span class="line">         containingTask.getMailboxExecutorFactory());</span><br><span class="line"></span><br><span class="line">      if (operatorFactory !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;chainEntryPoint 是 headOperator 的 output</span><br><span class="line">         WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; output &#x3D; getChainEntryPoint();</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;创建headOperator</span><br><span class="line">         headOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">               operatorFactory,</span><br><span class="line">               containingTask,</span><br><span class="line">               configuration,</span><br><span class="line">               output);</span><br><span class="line"></span><br><span class="line">         headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, output.getWatermarkGauge());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         headOperator &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; add head operator to end of chain</span><br><span class="line">      allOps.add(headOperator);</span><br><span class="line"></span><br><span class="line">      this.allOperators &#x3D; allOps.toArray(new StreamOperator&lt;?&gt;[allOps.size()]);</span><br><span class="line"></span><br><span class="line">      success &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      &#x2F;&#x2F; make sure we clean up after ourselves in case of a failure after acquiring</span><br><span class="line">      &#x2F;&#x2F; the first resources</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">         for (RecordWriterOutput&lt;?&gt; output : this.streamOutputs) &#123;</span><br><span class="line">            if (output !&#x3D; null) &#123;</span><br><span class="line">               output.close();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WatermarkAssignerOperatorFactory类的createStreamOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public StreamOperator createStreamOperator(StreamTask containingTask, StreamConfig config, Output output) &#123;</span><br><span class="line">   WatermarkGenerator watermarkGenerator &#x3D; generatedWatermarkGenerator.newInstance(containingTask.getUserCodeClassLoader());</span><br><span class="line">   WatermarkAssignerOperator operator &#x3D; new WatermarkAssignerOperator(rowtimeFieldIndex, watermarkGenerator, idleTimeout);</span><br><span class="line">   &#x2F;&#x2F;调用headoperator的setup</span><br><span class="line">   operator.setup(containingTask, config, output);</span><br><span class="line">   return operator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createStreamOutput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private RecordWriterOutput&lt;OUT&gt; createStreamOutput(</span><br><span class="line">      RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriter,</span><br><span class="line">      StreamEdge edge,</span><br><span class="line">      StreamConfig upStreamConfig,</span><br><span class="line">      Environment taskEnvironment) &#123;</span><br><span class="line">   OutputTag sideOutputTag &#x3D; edge.getOutputTag(); &#x2F;&#x2F; OutputTag, return null if not sideOutput</span><br><span class="line"></span><br><span class="line">   TypeSerializer outSerializer &#x3D; null;</span><br><span class="line"></span><br><span class="line">   if (edge.getOutputTag() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; side output</span><br><span class="line">      &#x2F;&#x2F;拿到side output的反序列化器</span><br><span class="line">      outSerializer &#x3D; upStreamConfig.getTypeSerializerSideOut(</span><br><span class="line">            edge.getOutputTag(), taskEnvironment.getUserClassLoader());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; main output</span><br><span class="line">      &#x2F;&#x2F;拿到main output的反序列化器</span><br><span class="line">      outSerializer &#x3D; upStreamConfig.getTypeSerializerOut(taskEnvironment.getUserClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new RecordWriterOutput&lt;&gt;(recordWriter, outSerializer, sideOutputTag, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createOutputCollector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; createOutputCollector(</span><br><span class="line">      StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   List&lt;Tuple2&lt;WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;, StreamEdge&gt;&gt; allOutputs &#x3D; new ArrayList&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create collectors for the network outputs</span><br><span class="line">   for (StreamEdge outputEdge : operatorConfig.getNonChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      RecordWriterOutput&lt;T&gt; output &#x3D; (RecordWriterOutput&lt;T&gt;) streamOutputs.get(outputEdge);</span><br><span class="line"></span><br><span class="line">      allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Create collectors for the chained outputs</span><br><span class="line">   &#x2F;&#x2F; OperatorChain 内部 Operator 之间的边</span><br><span class="line">   for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) &#123;</span><br><span class="line">      int outputId &#x3D; outputEdge.getTargetId();</span><br><span class="line">      StreamConfig chainedOpConfig &#x3D; chainedConfigs.get(outputId);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;创建当前节点的下游节点，并返回当前节点的 output</span><br><span class="line">	&#x2F;&#x2F;createChainedOperator 在创建 operator 的时候，会调用 createOutputCollector 为 operator 创建 output</span><br><span class="line">	&#x2F;&#x2F;所以会形成递归调用关系，所有的 operator 以及它们的 output 都会被创建出来</span><br><span class="line">      WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; output &#x3D; createChainedOperator(</span><br><span class="line">         containingTask,</span><br><span class="line">         chainedOpConfig,</span><br><span class="line">         chainedConfigs,</span><br><span class="line">         userCodeClassloader,</span><br><span class="line">         streamOutputs,</span><br><span class="line">         allOperators,</span><br><span class="line">         outputEdge.getOutputTag(),</span><br><span class="line">         mailboxExecutorFactory);</span><br><span class="line">      allOutputs.add(new Tuple2&lt;&gt;(output, outputEdge));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; if there are multiple outputs, or the outputs are directed, we need to</span><br><span class="line">   &#x2F;&#x2F; wrap them as one output</span><br><span class="line"></span><br><span class="line">   List&lt;OutputSelector&lt;T&gt;&gt; selectors &#x3D; operatorConfig.getOutputSelectors(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">   if (selectors &#x3D;&#x3D; null || selectors.isEmpty()) &#123;</span><br><span class="line">      &#x2F;&#x2F; simple path, no selector necessary</span><br><span class="line">      &#x2F;&#x2F;只有一个输出</span><br><span class="line">      if (allOutputs.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">         return allOutputs.get(0).f0;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">      &#x2F;&#x2F;不止有一个输出，需要使用 BroadcastingOutputCollector 进行封装</span><br><span class="line">         &#x2F;&#x2F; send to N outputs. Note that this includes the special case</span><br><span class="line">         &#x2F;&#x2F; of sending to zero outputs</span><br><span class="line">         @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">         Output&lt;StreamRecord&lt;T&gt;&gt;[] asArray &#x3D; new Output[allOutputs.size()];</span><br><span class="line">         for (int i &#x3D; 0; i &lt; allOutputs.size(); i++) &#123;</span><br><span class="line">            asArray[i] &#x3D; allOutputs.get(i).f0;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">         &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">         &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">         if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">            return new CopyingBroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">         &#125; else  &#123;</span><br><span class="line">            return new BroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; selector present, more complex routing necessary</span><br><span class="line">     &#x2F;&#x2F; 存在 selector，用 DirectedOutput 进行封装</span><br><span class="line">      &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">      &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">      &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">      if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">         return new CopyingDirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return new DirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createChainedOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">      StreamTask&lt;OUT, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      OutputTag&lt;IN&gt; outputTag,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   &#x2F;&#x2F; create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">   &#x2F;&#x2F; 为当前 Operator 创建 output</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput &#x3D; createOutputCollector(</span><br><span class="line">      containingTask,</span><br><span class="line">      operatorConfig,</span><br><span class="line">      chainedConfigs,</span><br><span class="line">      userCodeClassloader,</span><br><span class="line">      streamOutputs,</span><br><span class="line">      allOperators,</span><br><span class="line">      mailboxExecutorFactory);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; now create the operator and give it the output collector to write its output to</span><br><span class="line">   &#x2F;&#x2F;从 StreamConfig 中取出当前 Operator并调用setup</span><br><span class="line">   OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">         operatorConfig.getStreamOperatorFactory(userCodeClassloader),</span><br><span class="line">         containingTask,</span><br><span class="line">         operatorConfig,</span><br><span class="line">         chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">   allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;这里是在为当前 operator 前向的 operator 创建 output</span><br><span class="line">		&#x2F;&#x2F;所以当前 operator 被传递给前一个 operator 的 output，这样前一个 operator 的输出就可以直接调用当前 operator</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      currentOperatorOutput &#x3D; new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      TypeSerializer&lt;IN&gt; inSerializer &#x3D; operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">      currentOperatorOutput &#x3D; new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; wrap watermark gauges since registered metrics must be unique</span><br><span class="line">   chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, currentOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line">   chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, chainedOperatorOutput.getWatermarkGauge()::getValue);</span><br><span class="line"></span><br><span class="line">   return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/22/JobManager%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" rel="next" title="JobManager启动过程">
                <i class="fa fa-chevron-left"></i> JobManager启动过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/" rel="prev" title="Flink的Task的数据传输过程">
                Flink的Task的数据传输过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HH KKs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HH KKs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
