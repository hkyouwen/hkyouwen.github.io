<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="checkpoint的发起过程，首先在生产jobgraph的过程中会配置Checkpoint。 在StreamingJobGraphGenerator类中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink的checkpoint生成">
<meta property="og:url" content="http://yoursite.com/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/index.html">
<meta property="og:site_name" content="HK书屋">
<meta property="og:description" content="checkpoint的发起过程，首先在生产jobgraph的过程中会配置Checkpoint。 在StreamingJobGraphGenerator类中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/1.png">
<meta property="article:published_time" content="2020-07-15T02:56:16.819Z">
<meta property="article:modified_time" content="2020-07-16T10:58:51.685Z">
<meta property="article:author" content="HH KKs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/15/Flink的checkpoint生成/"/>





  <title>Flink的checkpoint生成 | HK书屋</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HK书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flink的checkpoint生成</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T10:56:16+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>checkpoint的发起过程，首先在生产jobgraph的过程中会配置Checkpoint。</p>
<p>在StreamingJobGraphGenerator类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">private JobGraph createJobGraph() &#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置 checkpoint</span><br><span class="line">   configureCheckpointing();</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">   return jobGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取Checkpoint的所有配置</span><br><span class="line">private void configureCheckpointing() &#123;</span><br><span class="line">		CheckpointConfig cfg &#x3D; streamGraph.getCheckpointConfig();</span><br><span class="line"></span><br><span class="line">		long interval &#x3D; cfg.getCheckpointInterval();</span><br><span class="line">		if (interval &lt; MINIMAL_CHECKPOINT_TIME) &#123;</span><br><span class="line">			&#x2F;&#x2F; interval of max value means disable periodic checkpoint</span><br><span class="line">			interval &#x3D; Long.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure the participating vertices ---</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that receive &quot;trigger checkpoint&quot; messages.</span><br><span class="line">		&#x2F;&#x2F; currently, these are all the sources</span><br><span class="line">		&#x2F;&#x2F; 只包含那些作为 source 的节点</span><br><span class="line">		List&lt;JobVertexID&gt; triggerVertices &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that need to acknowledge the checkpoint</span><br><span class="line">		&#x2F;&#x2F; currently, these are all vertices</span><br><span class="line">		List&lt;JobVertexID&gt; ackVertices &#x3D; new ArrayList&lt;&gt;(jobVertices.size());</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; collect the vertices that receive &quot;commit checkpoint&quot; messages</span><br><span class="line">		&#x2F;&#x2F; currently, these are all vertices</span><br><span class="line">		List&lt;JobVertexID&gt; commitVertices &#x3D; new ArrayList&lt;&gt;(jobVertices.size());</span><br><span class="line"></span><br><span class="line">		for (JobVertex vertex : jobVertices.values()) &#123;</span><br><span class="line">			if (vertex.isInputVertex()) &#123;</span><br><span class="line">				triggerVertices.add(vertex.getID());</span><br><span class="line">			&#125;</span><br><span class="line">			commitVertices.add(vertex.getID());</span><br><span class="line">			ackVertices.add(vertex.getID());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure options ---</span><br><span class="line"></span><br><span class="line">		CheckpointRetentionPolicy retentionAfterTermination;</span><br><span class="line">		if (cfg.isExternalizedCheckpointsEnabled()) &#123;</span><br><span class="line">			CheckpointConfig.ExternalizedCheckpointCleanup cleanup &#x3D; cfg.getExternalizedCheckpointCleanup();</span><br><span class="line">			&#x2F;&#x2F; Sanity check</span><br><span class="line">			if (cleanup &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;Externalized checkpoints enabled, but no cleanup mode configured.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			retentionAfterTermination &#x3D; cleanup.deleteOnCancellation() ?</span><br><span class="line">					CheckpointRetentionPolicy.RETAIN_ON_FAILURE :</span><br><span class="line">					CheckpointRetentionPolicy.RETAIN_ON_CANCELLATION;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			retentionAfterTermination &#x3D; CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CheckpointingMode mode &#x3D; cfg.getCheckpointingMode();</span><br><span class="line"></span><br><span class="line">		boolean isExactlyOnce;</span><br><span class="line">		if (mode &#x3D;&#x3D; CheckpointingMode.EXACTLY_ONCE) &#123;</span><br><span class="line">			isExactlyOnce &#x3D; true;</span><br><span class="line">		&#125; else if (mode &#x3D;&#x3D; CheckpointingMode.AT_LEAST_ONCE) &#123;</span><br><span class="line">			isExactlyOnce &#x3D; false;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;Unexpected checkpointing mode. &quot; +</span><br><span class="line">				&quot;Did not expect there to be another checkpointing mode besides &quot; +</span><br><span class="line">				&quot;exactly-once or at-least-once.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- configure the master-side checkpoint hooks ---</span><br><span class="line"></span><br><span class="line">		final ArrayList&lt;MasterTriggerRestoreHook.Factory&gt; hooks &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		for (StreamNode node : streamGraph.getStreamNodes()) &#123;</span><br><span class="line">			if (node.getOperatorFactory() instanceof UdfStreamOperatorFactory) &#123;</span><br><span class="line">				Function f &#x3D; ((UdfStreamOperatorFactory) node.getOperatorFactory()).getUserFunction();</span><br><span class="line"></span><br><span class="line">				if (f instanceof WithMasterCheckpointHook) &#123;</span><br><span class="line">					hooks.add(new FunctionMasterCheckpointHookFactory((WithMasterCheckpointHook&lt;?&gt;) f));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; because the hooks can have user-defined code, they need to be stored as</span><br><span class="line">		&#x2F;&#x2F; eagerly serialized values</span><br><span class="line">		final SerializedValue&lt;MasterTriggerRestoreHook.Factory[]&gt; serializedHooks;</span><br><span class="line">		if (hooks.isEmpty()) &#123;</span><br><span class="line">			serializedHooks &#x3D; null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				MasterTriggerRestoreHook.Factory[] asArray &#x3D;</span><br><span class="line">						hooks.toArray(new MasterTriggerRestoreHook.Factory[hooks.size()]);</span><br><span class="line">				serializedHooks &#x3D; new SerializedValue&lt;&gt;(asArray);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (IOException e) &#123;</span><br><span class="line">				throw new FlinkRuntimeException(&quot;Trigger&#x2F;restore hook is not serializable&quot;, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; because the state backend can have user-defined code, it needs to be stored as</span><br><span class="line">		&#x2F;&#x2F; eagerly serialized value</span><br><span class="line">		final SerializedValue&lt;StateBackend&gt; serializedStateBackend;</span><br><span class="line">		if (streamGraph.getStateBackend() &#x3D;&#x3D; null) &#123;</span><br><span class="line">			serializedStateBackend &#x3D; null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				serializedStateBackend &#x3D;</span><br><span class="line">					new SerializedValue&lt;StateBackend&gt;(streamGraph.getStateBackend());</span><br><span class="line">			&#125;</span><br><span class="line">			catch (IOException e) &#123;</span><br><span class="line">				throw new FlinkRuntimeException(&quot;State backend is not serializable&quot;, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;  --- done, put it all together ---</span><br><span class="line">       &#x2F;&#x2F;加入jobGraph的配置</span><br><span class="line">		JobCheckpointingSettings settings &#x3D; new JobCheckpointingSettings(</span><br><span class="line">			triggerVertices,</span><br><span class="line">			ackVertices,</span><br><span class="line">			commitVertices,</span><br><span class="line">			new CheckpointCoordinatorConfiguration(</span><br><span class="line">				interval,</span><br><span class="line">				cfg.getCheckpointTimeout(),</span><br><span class="line">				cfg.getMinPauseBetweenCheckpoints(),</span><br><span class="line">				cfg.getMaxConcurrentCheckpoints(),</span><br><span class="line">				retentionAfterTermination,</span><br><span class="line">				isExactlyOnce,</span><br><span class="line">				cfg.isPreferCheckpointForRecovery(),</span><br><span class="line">				cfg.getTolerableCheckpointFailureNumber()),</span><br><span class="line">			serializedStateBackend,</span><br><span class="line">			serializedHooks);</span><br><span class="line"></span><br><span class="line">		jobGraph.setSnapshotSettings(settings);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着jobGraph进入ExecutionGraph的构建过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutionGraph buildGraph(</span><br><span class="line">   @Nullable ExecutionGraph prior,</span><br><span class="line">   JobGraph jobGraph,</span><br><span class="line">   Configuration jobManagerConfig,</span><br><span class="line">   ScheduledExecutorService futureExecutor,</span><br><span class="line">   Executor ioExecutor,</span><br><span class="line">   SlotProvider slotProvider,</span><br><span class="line">   ClassLoader classLoader,</span><br><span class="line">   CheckpointRecoveryFactory recoveryFactory,</span><br><span class="line">   Time rpcTimeout,</span><br><span class="line">   RestartStrategy restartStrategy,</span><br><span class="line">   MetricGroup metrics,</span><br><span class="line">   BlobWriter blobWriter,</span><br><span class="line">   Time allocationTimeout,</span><br><span class="line">   Logger log,</span><br><span class="line">   ShuffleMaster&lt;?&gt; shuffleMaster,</span><br><span class="line">   JobMasterPartitionTracker partitionTracker,</span><br><span class="line">   FailoverStrategy.Factory failoverStrategyFactory) throws JobExecutionException, JobException &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据jobGraph的Checkpoint的配置来配置ExecutionGraph</span><br><span class="line">   &#x2F;&#x2F; configure the state checkpointing</span><br><span class="line">   JobCheckpointingSettings snapshotSettings &#x3D; jobGraph.getCheckpointingSettings();</span><br><span class="line">   if (snapshotSettings !&#x3D; null) &#123;</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; triggerVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToTrigger(), executionGraph);</span><br><span class="line"></span><br><span class="line">      List&lt;ExecutionJobVertex&gt; ackVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToAcknowledge(), executionGraph);</span><br><span class="line"></span><br><span class="line">      List&lt;ExecutionJobVertex&gt; confirmVertices &#x3D;</span><br><span class="line">            idToVertex(snapshotSettings.getVerticesToConfirm(), executionGraph);</span><br><span class="line"></span><br><span class="line">      CompletedCheckpointStore completedCheckpoints;</span><br><span class="line">      CheckpointIDCounter checkpointIdCounter;</span><br><span class="line">      try &#123;</span><br><span class="line">         int maxNumberOfCheckpointsToRetain &#x3D; jobManagerConfig.getInteger(</span><br><span class="line">               CheckpointingOptions.MAX_RETAINED_CHECKPOINTS);</span><br><span class="line"></span><br><span class="line">         if (maxNumberOfCheckpointsToRetain &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; warning and use 1 as the default value if the setting in</span><br><span class="line">            &#x2F;&#x2F; state.checkpoints.max-retained-checkpoints is not greater than 0.</span><br><span class="line">            log.warn(&quot;The setting for &#39;&#123;&#125; : &#123;&#125;&#39; is invalid. Using default value of &#123;&#125;&quot;,</span><br><span class="line">                  CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.key(),</span><br><span class="line">                  maxNumberOfCheckpointsToRetain,</span><br><span class="line">                  CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.defaultValue());</span><br><span class="line"></span><br><span class="line">            maxNumberOfCheckpointsToRetain &#x3D; CheckpointingOptions.MAX_RETAINED_CHECKPOINTS.defaultValue();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         completedCheckpoints &#x3D; recoveryFactory.createCheckpointStore(jobId, maxNumberOfCheckpointsToRetain, classLoader);</span><br><span class="line">         checkpointIdCounter &#x3D; recoveryFactory.createCheckpointIDCounter(jobId);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new JobExecutionException(jobId, &quot;Failed to initialize high-availability checkpoint handler&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Maximum number of remembered checkpoints</span><br><span class="line">      </span><br><span class="line">      int historySize &#x3D; jobManagerConfig.getInteger(WebOptions.CHECKPOINTS_HISTORY_SIZE);</span><br><span class="line"></span><br><span class="line">      CheckpointStatsTracker checkpointStatsTracker &#x3D; new CheckpointStatsTracker(</span><br><span class="line">            historySize,</span><br><span class="line">            ackVertices,</span><br><span class="line">            snapshotSettings.getCheckpointCoordinatorConfiguration(),</span><br><span class="line">            metrics);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; load the state backend from the application settings</span><br><span class="line">      final StateBackend applicationConfiguredBackend;</span><br><span class="line">      final SerializedValue&lt;StateBackend&gt; serializedAppConfigured &#x3D; snapshotSettings.getDefaultStateBackend();</span><br><span class="line"></span><br><span class="line">      if (serializedAppConfigured &#x3D;&#x3D; null) &#123;</span><br><span class="line">         applicationConfiguredBackend &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            applicationConfiguredBackend &#x3D; serializedAppConfigured.deserializeValue(classLoader);</span><br><span class="line">         &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new JobExecutionException(jobId,</span><br><span class="line">                  &quot;Could not deserialize application-defined state backend.&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final StateBackend rootBackend;</span><br><span class="line">      try &#123;</span><br><span class="line">         rootBackend &#x3D; StateBackendLoader.fromApplicationOrConfigOrDefault(</span><br><span class="line">               applicationConfiguredBackend, jobManagerConfig, classLoader, log);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (IllegalConfigurationException | IOException | DynamicCodeLoadingException e) &#123;</span><br><span class="line">         throw new JobExecutionException(jobId, &quot;Could not instantiate configured state backend&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; instantiate the user-defined checkpoint hooks</span><br><span class="line">&#x2F;&#x2F;回调用户自己实现的Checkpoint逻辑</span><br><span class="line">      final SerializedValue&lt;MasterTriggerRestoreHook.Factory[]&gt; serializedHooks &#x3D; snapshotSettings.getMasterHooks();</span><br><span class="line">      final List&lt;MasterTriggerRestoreHook&lt;?&gt;&gt; hooks;</span><br><span class="line"></span><br><span class="line">      if (serializedHooks &#x3D;&#x3D; null) &#123;</span><br><span class="line">         hooks &#x3D; Collections.emptyList();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         final MasterTriggerRestoreHook.Factory[] hookFactories;</span><br><span class="line">         try &#123;</span><br><span class="line">            hookFactories &#x3D; serializedHooks.deserializeValue(classLoader);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new JobExecutionException(jobId, &quot;Could not instantiate user-defined checkpoint hooks&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         final Thread thread &#x3D; Thread.currentThread();</span><br><span class="line">         final ClassLoader originalClassLoader &#x3D; thread.getContextClassLoader();</span><br><span class="line">         thread.setContextClassLoader(classLoader);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">            hooks &#x3D; new ArrayList&lt;&gt;(hookFactories.length);</span><br><span class="line">            for (MasterTriggerRestoreHook.Factory factory : hookFactories) &#123;</span><br><span class="line">               hooks.add(MasterHooks.wrapHook(factory.create(), classLoader));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         finally &#123;</span><br><span class="line">            thread.setContextClassLoader(originalClassLoader);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final CheckpointCoordinatorConfiguration chkConfig &#x3D; snapshotSettings.getCheckpointCoordinatorConfiguration();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开启Checkpoint</span><br><span class="line">      executionGraph.enableCheckpointing(</span><br><span class="line">         chkConfig,</span><br><span class="line">         triggerVertices,</span><br><span class="line">         ackVertices,</span><br><span class="line">         confirmVertices,</span><br><span class="line">         hooks,</span><br><span class="line">         checkpointIdCounter,</span><br><span class="line">         completedCheckpoints,</span><br><span class="line">         rootBackend,</span><br><span class="line">         checkpointStatsTracker);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return executionGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executionGraph.enableCheckpointing开启Checkpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public void enableCheckpointing(</span><br><span class="line">      CheckpointCoordinatorConfiguration chkConfig,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToTrigger,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToWaitFor,</span><br><span class="line">      List&lt;ExecutionJobVertex&gt; verticesToCommitTo,</span><br><span class="line">      List&lt;MasterTriggerRestoreHook&lt;?&gt;&gt; masterHooks,</span><br><span class="line">      CheckpointIDCounter checkpointIDCounter,</span><br><span class="line">      CompletedCheckpointStore checkpointStore,</span><br><span class="line">      StateBackend checkpointStateBackend,</span><br><span class="line">      CheckpointStatsTracker statsTracker) &#123;</span><br><span class="line"></span><br><span class="line">   checkState(state &#x3D;&#x3D; JobStatus.CREATED, &quot;Job must be in CREATED state&quot;);</span><br><span class="line">   checkState(checkpointCoordinator &#x3D;&#x3D; null, &quot;checkpointing already enabled&quot;);</span><br><span class="line"></span><br><span class="line">   ExecutionVertex[] tasksToTrigger &#x3D; collectExecutionVertices(verticesToTrigger);</span><br><span class="line">   ExecutionVertex[] tasksToWaitFor &#x3D; collectExecutionVertices(verticesToWaitFor);</span><br><span class="line">   ExecutionVertex[] tasksToCommitTo &#x3D; collectExecutionVertices(verticesToCommitTo);</span><br><span class="line"></span><br><span class="line">   checkpointStatsTracker &#x3D; checkNotNull(statsTracker, &quot;CheckpointStatsTracker&quot;);</span><br><span class="line"></span><br><span class="line">   CheckpointFailureManager failureManager &#x3D; new CheckpointFailureManager(</span><br><span class="line">      chkConfig.getTolerableCheckpointFailureNumber(),</span><br><span class="line">      new CheckpointFailureManager.FailJobCallback() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void failJob(Throwable cause) &#123;</span><br><span class="line">            getJobMasterMainThreadExecutor().execute(() -&gt; failGlobal(cause));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void failJobDueToTaskFailure(Throwable cause, ExecutionAttemptID failingTask) &#123;</span><br><span class="line">            getJobMasterMainThreadExecutor().execute(() -&gt; failGlobalIfExecutionIsStillRunning(cause, failingTask));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   checkState(checkpointCoordinatorTimer &#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">   checkpointCoordinatorTimer &#x3D; Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">      new DispatcherThreadFactory(</span><br><span class="line">         Thread.currentThread().getThreadGroup(), &quot;Checkpoint Timer&quot;));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create the coordinator that triggers and commits checkpoints and holds the state</span><br><span class="line">   &#x2F;&#x2F;创建 CheckpointCoordinator 对象</span><br><span class="line">   checkpointCoordinator &#x3D; new CheckpointCoordinator(</span><br><span class="line">      jobInformation.getJobId(),</span><br><span class="line">      chkConfig,</span><br><span class="line">      tasksToTrigger,</span><br><span class="line">      tasksToWaitFor,</span><br><span class="line">      tasksToCommitTo,</span><br><span class="line">      checkpointIDCounter,</span><br><span class="line">      checkpointStore,</span><br><span class="line">      checkpointStateBackend,</span><br><span class="line">      ioExecutor,</span><br><span class="line">      new ScheduledExecutorServiceAdapter(checkpointCoordinatorTimer),</span><br><span class="line">      SharedStateRegistry.DEFAULT_FACTORY,</span><br><span class="line">      failureManager);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; register the master hooks on the checkpoint coordinator</span><br><span class="line">   for (MasterTriggerRestoreHook&lt;?&gt; hook : masterHooks) &#123;</span><br><span class="line">      if (!checkpointCoordinator.addMasterHook(hook)) &#123;</span><br><span class="line">         LOG.warn(&quot;Trying to register multiple checkpoint hooks with the name: &#123;&#125;&quot;, hook.getIdentifier());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   checkpointCoordinator.setCheckpointStatsTracker(checkpointStatsTracker);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; interval of max long value indicates disable periodic checkpoint,</span><br><span class="line">   &#x2F;&#x2F; the CheckpointActivatorDeactivator should be created only if the interval is not max value</span><br><span class="line">   if (chkConfig.getCheckpointInterval() !&#x3D; Long.MAX_VALUE) &#123;</span><br><span class="line">      &#x2F;&#x2F; the periodic checkpoint scheduler is activated and deactivated as a result of</span><br><span class="line">      &#x2F;&#x2F; job status changes (running -&gt; on, all other states -&gt; off)</span><br><span class="line">      &#x2F;&#x2F;注册一个作业状态的监听 CheckpointCoordinatorDeActivator</span><br><span class="line">      registerJobStatusListener(checkpointCoordinator.createActivatorDeactivator());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.stateBackendName &#x3D; checkpointStateBackend.getClass().getSimpleName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinatorDeActivator实现JobStatusListener接口，当Job状态变为 RUNNING 时，通过startCheckpointScheduler启动 checkpoint 的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CheckpointCoordinatorDeActivator implements JobStatusListener &#123;</span><br><span class="line"></span><br><span class="line">   private final CheckpointCoordinator coordinator;</span><br><span class="line"></span><br><span class="line">   public CheckpointCoordinatorDeActivator(CheckpointCoordinator coordinator) &#123;</span><br><span class="line">      this.coordinator &#x3D; checkNotNull(coordinator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void jobStatusChanges(JobID jobId, JobStatus newJobStatus, long timestamp, Throwable error) &#123;</span><br><span class="line">      if (newJobStatus &#x3D;&#x3D; JobStatus.RUNNING) &#123;</span><br><span class="line">         &#x2F;&#x2F; start the checkpoint scheduler</span><br><span class="line">         coordinator.startCheckpointScheduler();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; anything else should stop the trigger for now</span><br><span class="line">         coordinator.stopCheckpointScheduler();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void startCheckpointScheduler() &#123;</span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Checkpoint coordinator is shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make sure all prior timers are cancelled</span><br><span class="line">      stopCheckpointScheduler();</span><br><span class="line"></span><br><span class="line">      periodicScheduling &#x3D; true;</span><br><span class="line">      currentPeriodicTrigger &#x3D; scheduleTriggerWithDelay(getRandomInitDelay());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开启定时任务，baseInterval从配置文件getCheckpointInterval获取</span><br><span class="line">private ScheduledFuture&lt;?&gt; scheduleTriggerWithDelay(long initDelay) &#123;</span><br><span class="line">		return timer.scheduleAtFixedRate(</span><br><span class="line">			new ScheduledTrigger(),</span><br><span class="line">			initDelay, baseInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务的内容就是ScheduledTrigger类 的triggerCheckpoint，包括以下几个步骤：</p>
<ul>
<li>检查是否可以触发 checkpoint，包括是否需要强制进行 checkpoint，当前正在排队的并发 checkpoint 的数目是否超过阈值，距离上一次成功 checkpoint 的间隔时间是否过小等，如果这些条件不满足，则当前检查点的触发请求不会执行</li>
<li>检查是否所有需要触发 checkpoint 的 Execution 都是 <code>RUNNING</code> 状态</li>
<li>生成此次 checkpoint 的 checkpointID（id 是严格自增的），并初始化 <code>CheckpointStorageLocation</code>，<code>CheckpointStorageLocation</code> 是此次 checkpoint 存储位置的抽象，通过 <code>CheckpointStorage.initializeLocationForCheckpoint()</code> 创建（<code>CheckpointStorage</code> 目前有两个具体实现，分别为 <code>FsCheckpointStorage</code> 和 <code>MemoryBackendCheckpointStorage</code>），<code>CheckpointStorage</code> 则是从 <code>StateBackend</code> 中创建</li>
<li>生成 <code>PendingCheckpoint</code>，这表示一个处于中间状态的 checkpoint，并保存在 <code>checkpointId -&gt; PendingCheckpoint</code> 这样的映射关系中</li>
<li>注册一个调度任务，在 checkpoint 超时后取消此次 checkpoint，并重新触发一次新的 checkpoint</li>
<li>调用 <code>Execution.triggerCheckpoint()</code> 方法向所有需要 trigger 的 task 发起 checkpoint 请求</li>
</ul>
<p>savepoint 和 checkpoint 的处理逻辑基本一致，只是 savepoint 是强制触发的，需要调用 <code>Execution.triggerSynchronousSavepoint()</code> 进行触发。</p>
<p>在CheckpointCoordinator 内部也有三个列表：</p>
<ul>
<li><code>ExecutionVertex[] tasksToTrigger</code>;</li>
<li><code>ExecutionVertex[] tasksToWaitFor</code>;</li>
<li><code>ExecutionVertex[] tasksToCommitTo</code>;</li>
</ul>
<p>这就对应了前面 <code>JobGraph</code> 中的三个列表，在触发 checkpoint 的时候，只有作为 source 的 Execution 会调用 <code>Execution.triggerCheckpoint()</code> 方法。会通过 RPC 调用通知对应的 <code>RpcTaskManagerGateway</code> 调用 <code>triggerCheckpoint</code>。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">private final class ScheduledTrigger implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         triggerCheckpoint(System.currentTimeMillis(), true);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         LOG.error(&quot;Exception while triggering checkpoint for job &#123;&#125;.&quot;, job, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CompletableFuture&lt;CompletedCheckpoint&gt; triggerCheckpoint(long timestamp, boolean isPeriodic) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;进入triggerCheckpoint</span><br><span class="line">			return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic, false);</span><br><span class="line">		&#125; catch (CheckpointException e) &#123;</span><br><span class="line">			long latestGeneratedCheckpointId &#x3D; getCheckpointIdCounter().get();</span><br><span class="line">			&#x2F;&#x2F; here we can not get the failed pending checkpoint&#39;s id,</span><br><span class="line">			&#x2F;&#x2F; so we pass the negative latest generated checkpoint id as a special flag</span><br><span class="line">			failureManager.handleJobLevelCheckpointException(e, -1 * latestGeneratedCheckpointId);</span><br><span class="line">			return FutureUtils.completedExceptionally(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@VisibleForTesting</span><br><span class="line">	public CompletableFuture&lt;CompletedCheckpoint&gt; triggerCheckpoint(</span><br><span class="line">			long timestamp,</span><br><span class="line">			CheckpointProperties props,</span><br><span class="line">			@Nullable String externalSavepointLocation,</span><br><span class="line">			boolean isPeriodic,</span><br><span class="line">			boolean advanceToEndOfTime) throws CheckpointException &#123;</span><br><span class="line"></span><br><span class="line">		if (advanceToEndOfTime &amp;&amp; !(props.isSynchronous() &amp;&amp; props.isSavepoint())) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; make some eager pre-checks</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">		&#x2F;&#x2F;检查是否可以触发 checkpoint</span><br><span class="line">			preCheckBeforeTriggeringCheckpoint(isPeriodic, props.forceCheckpoint());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; check if all tasks that we need to trigger are running.</span><br><span class="line">		&#x2F;&#x2F; if not, abort the checkpoint</span><br><span class="line">		&#x2F;&#x2F;检查是否所有需要触发 checkpoint 的 Execution 都是 RUNNING 状态</span><br><span class="line">		Execution[] executions &#x3D; new Execution[tasksToTrigger.length];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; tasksToTrigger.length; i++) &#123;</span><br><span class="line">			Execution ee &#x3D; tasksToTrigger[i].getCurrentExecutionAttempt();</span><br><span class="line">			if (ee &#x3D;&#x3D; null) &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not being executed at the moment. Aborting checkpoint.&quot;,</span><br><span class="line">						tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job);</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125; else if (ee.getState() &#x3D;&#x3D; ExecutionState.RUNNING) &#123;</span><br><span class="line">				executions[i] &#x3D; ee;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not in state &#123;&#125; but &#123;&#125; instead. Aborting checkpoint.&quot;,</span><br><span class="line">						tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job,</span><br><span class="line">						ExecutionState.RUNNING,</span><br><span class="line">						ee.getState());</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; next, check if all tasks that need to acknowledge the checkpoint are running.</span><br><span class="line">		&#x2F;&#x2F; if not, abort the checkpoint</span><br><span class="line">		Map&lt;ExecutionAttemptID, ExecutionVertex&gt; ackTasks &#x3D; new HashMap&lt;&gt;(tasksToWaitFor.length);</span><br><span class="line"></span><br><span class="line">		for (ExecutionVertex ev : tasksToWaitFor) &#123;</span><br><span class="line">			Execution ee &#x3D; ev.getCurrentExecutionAttempt();</span><br><span class="line">			if (ee !&#x3D; null) &#123;</span><br><span class="line">				ackTasks.put(ee.getAttemptId(), ev);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.info(&quot;Checkpoint acknowledging task &#123;&#125; of job &#123;&#125; is not being executed at the moment. Aborting checkpoint.&quot;,</span><br><span class="line">						ev.getTaskNameWithSubtaskIndex(),</span><br><span class="line">						job);</span><br><span class="line">				throw new CheckpointException(CheckpointFailureReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; we will actually trigger this checkpoint!</span><br><span class="line"></span><br><span class="line">		final CheckpointStorageLocation checkpointStorageLocation;</span><br><span class="line">		final long checkpointID;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; this must happen outside the coordinator-wide lock, because it communicates</span><br><span class="line">			&#x2F;&#x2F; with external services (in HA mode) and may block for a while.</span><br><span class="line">			&#x2F;&#x2F;checkpointID用CAS递增</span><br><span class="line">			checkpointID &#x3D; checkpointIdCounter.getAndIncrement();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;初始化checkpoint存储位置</span><br><span class="line">			checkpointStorageLocation &#x3D; props.isSavepoint() ?</span><br><span class="line">					checkpointStorage.initializeLocationForSavepoint(checkpointID, externalSavepointLocation) :</span><br><span class="line">					checkpointStorage.initializeLocationForCheckpoint(checkpointID);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable t) &#123;</span><br><span class="line">			int numUnsuccessful &#x3D; numUnsuccessfulCheckpointsTriggers.incrementAndGet();</span><br><span class="line">			LOG.warn(&quot;Failed to trigger checkpoint for job &#123;&#125; (&#123;&#125; consecutive failed attempts so far).&quot;,</span><br><span class="line">					job,</span><br><span class="line">					numUnsuccessful,</span><br><span class="line">					t);</span><br><span class="line">			throw new CheckpointException(CheckpointFailureReason.EXCEPTION, t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化PendingCheckpoint，中间状态的checkpoint</span><br><span class="line">		final PendingCheckpoint checkpoint &#x3D; new PendingCheckpoint(</span><br><span class="line">			job,</span><br><span class="line">			checkpointID,</span><br><span class="line">			timestamp,</span><br><span class="line">			ackTasks,</span><br><span class="line">			masterHooks.keySet(),</span><br><span class="line">			props,</span><br><span class="line">			checkpointStorageLocation,</span><br><span class="line">			executor);</span><br><span class="line"></span><br><span class="line">		if (statsTracker !&#x3D; null) &#123;</span><br><span class="line">			PendingCheckpointStats callback &#x3D; statsTracker.reportPendingCheckpoint(</span><br><span class="line">				checkpointID,</span><br><span class="line">				timestamp,</span><br><span class="line">				props);</span><br><span class="line"></span><br><span class="line">			checkpoint.setStatsCallback(callback);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;定时清除已过期的checkpoints</span><br><span class="line">		&#x2F;&#x2F; schedule the timer that will clean up the expired checkpoints</span><br><span class="line">		final Runnable canceller &#x3D; () -&gt; &#123;</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">				&#x2F;&#x2F; only do the work if the checkpoint is not discarded anyways</span><br><span class="line">				&#x2F;&#x2F; note that checkpoint completion discards the pending checkpoint object</span><br><span class="line">				if (!checkpoint.isDiscarded()) &#123;</span><br><span class="line">					LOG.info(&quot;Checkpoint &#123;&#125; of job &#123;&#125; expired before completing.&quot;, checkpointID, job);</span><br><span class="line"></span><br><span class="line">					failPendingCheckpoint(checkpoint, CheckpointFailureReason.CHECKPOINT_EXPIRED);</span><br><span class="line">					pendingCheckpoints.remove(checkpointID);</span><br><span class="line">					rememberRecentCheckpointId(checkpointID);</span><br><span class="line"></span><br><span class="line">					triggerQueuedRequests();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; re-acquire the coordinator-wide lock</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">			&#x2F;&#x2F;二次检查</span><br><span class="line">				preCheckBeforeTriggeringCheckpoint(isPeriodic, props.forceCheckpoint());</span><br><span class="line"></span><br><span class="line">				LOG.info(&quot;Triggering checkpoint &#123;&#125; @ &#123;&#125; for job &#123;&#125;.&quot;, checkpointID, timestamp, job);</span><br><span class="line"></span><br><span class="line">				pendingCheckpoints.put(checkpointID, checkpoint);</span><br><span class="line"></span><br><span class="line">				ScheduledFuture&lt;?&gt; cancellerHandle &#x3D; timer.schedule(</span><br><span class="line">						canceller,</span><br><span class="line">						checkpointTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">				if (!checkpoint.setCancellerHandle(cancellerHandle)) &#123;</span><br><span class="line">					&#x2F;&#x2F; checkpoint is already disposed!</span><br><span class="line">					cancellerHandle.cancel(false);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; TODO, asynchronously snapshots master hook without waiting here</span><br><span class="line">				&#x2F;&#x2F;回调用户函数</span><br><span class="line">				for (MasterTriggerRestoreHook&lt;?&gt; masterHook : masterHooks.values()) &#123;</span><br><span class="line">					final MasterState masterState &#x3D;</span><br><span class="line">						MasterHooks.triggerHook(masterHook, checkpointID, timestamp, executor)</span><br><span class="line">							.get(checkpointTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">					checkpoint.acknowledgeMasterState(masterHook.getIdentifier(), masterState);</span><br><span class="line">				&#125;</span><br><span class="line">				Preconditions.checkState(checkpoint.areMasterStatesFullyAcknowledged());</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; end of lock scope</span><br><span class="line"></span><br><span class="line">			final CheckpointOptions checkpointOptions &#x3D; new CheckpointOptions(</span><br><span class="line">					props.getCheckpointType(),</span><br><span class="line">					checkpointStorageLocation.getLocationReference());</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; send the messages to the tasks that trigger their checkpoint</span><br><span class="line">			&#x2F;&#x2F;触发tasksToTrigger的task发出checkpoint</span><br><span class="line">			for (Execution execution: executions) &#123;</span><br><span class="line">				if (props.isSynchronous()) &#123;</span><br><span class="line">					execution.triggerSynchronousSavepoint(checkpointID, timestamp, checkpointOptions, advanceToEndOfTime);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			numUnsuccessfulCheckpointsTriggers.set(0);</span><br><span class="line">			return checkpoint.getCompletionFuture();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable t) &#123;</span><br><span class="line">			&#x2F;&#x2F; guard the map against concurrent modifications</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">				pendingCheckpoints.remove(checkpointID);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int numUnsuccessful &#x3D; numUnsuccessfulCheckpointsTriggers.incrementAndGet();</span><br><span class="line">			LOG.warn(&quot;Failed to trigger checkpoint &#123;&#125; for job &#123;&#125;. (&#123;&#125; consecutive failed attempts so far)&quot;,</span><br><span class="line">					checkpointID, job, numUnsuccessful, t);</span><br><span class="line"></span><br><span class="line">			if (!checkpoint.isDiscarded()) &#123;</span><br><span class="line">				failPendingCheckpoint(checkpoint, CheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE, t);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				checkpointStorageLocation.disposeOnFailure();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable t2) &#123;</span><br><span class="line">				LOG.warn(&quot;Cannot dispose failed checkpoint storage location &#123;&#125;&quot;, checkpointStorageLocation, t2);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; rethrow the CheckpointException directly.</span><br><span class="line">			if (t instanceof CheckpointException) &#123;</span><br><span class="line">				throw (CheckpointException) t;</span><br><span class="line">			&#125;</span><br><span class="line">			throw new CheckpointException(CheckpointFailureReason.EXCEPTION, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>tasksToTrigger的task的触发Checkpoint，调用Execution的triggerCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) &#123;</span><br><span class="line">   triggerCheckpointHelper(checkpointId, timestamp, checkpointOptions, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void triggerCheckpointHelper(long checkpointId, long timestamp, CheckpointOptions checkpointOptions, boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">		final CheckpointType checkpointType &#x3D; checkpointOptions.getCheckpointType();</span><br><span class="line">		if (advanceToEndOfEventTime &amp;&amp; !(checkpointType.isSynchronous() &amp;&amp; checkpointType.isSavepoint())) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		final LogicalSlot slot &#x3D; assignedResource;</span><br><span class="line"></span><br><span class="line">		if (slot !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;通过slot资源信息获取TaskManagerGateway并发送triggerCheckpoint请求</span><br><span class="line">			final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			LOG.debug(&quot;The execution has no slot assigned. This indicates that the execution is no longer running.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>TaskManagerGateway转发TaskExecutorGateway，调用Gateway的triggerCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; triggerCheckpoint(</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long checkpointTimestamp,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      boolean advanceToEndOfEventTime) &#123;</span><br><span class="line">   log.debug(&quot;Trigger checkpoint &#123;&#125;@&#123;&#125; for &#123;&#125;.&quot;, checkpointId, checkpointTimestamp, executionAttemptID);</span><br><span class="line"></span><br><span class="line">   final CheckpointType checkpointType &#x3D; checkpointOptions.getCheckpointType();</span><br><span class="line">   if (advanceToEndOfEventTime &amp;&amp; !(checkpointType.isSynchronous() &amp;&amp; checkpointType.isSavepoint())) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Only synchronous savepoints are allowed to advance the watermark to MAX.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为一个 TaskExecutor 中可能有多个 Task 正在运行，所以获取executionAttemptID对应的task</span><br><span class="line">   final Task task &#x3D; taskSlotTable.getTask(executionAttemptID);</span><br><span class="line"></span><br><span class="line">   if (task !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;task发出CheckpointBarrier</span><br><span class="line">      task.triggerCheckpointBarrier(checkpointId, checkpointTimestamp, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line"></span><br><span class="line">      return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final String message &#x3D; &quot;TaskManager received a checkpoint request for unknown task &quot; + executionAttemptID + &#39;.&#39;;</span><br><span class="line"></span><br><span class="line">      log.debug(message);</span><br><span class="line">      return FutureUtils.completedExceptionally(new CheckpointException(message, CheckpointFailureReason.TASK_CHECKPOINT_FAILURE));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task发出CheckpointBarrier，只有作为 source 的 Task 才会触发 <code>triggerCheckpointBarrier()</code> 方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpointBarrier(</span><br><span class="line">			final long checkpointID,</span><br><span class="line">			final long checkpointTimestamp,</span><br><span class="line">			final CheckpointOptions checkpointOptions,</span><br><span class="line">			final boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">		final AbstractInvokable invokable &#x3D; this.invokable;</span><br><span class="line">		final CheckpointMetaData checkpointMetaData &#x3D; new CheckpointMetaData(checkpointID, checkpointTimestamp);</span><br><span class="line"></span><br><span class="line">		if (executionState &#x3D;&#x3D; ExecutionState.RUNNING &amp;&amp; invokable !&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">			&#x2F;&#x2F;异步执行triggerCheckpoint</span><br><span class="line">				invokable.triggerCheckpointAsync(checkpointMetaData, checkpointOptions, advanceToEndOfEventTime);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RejectedExecutionException ex) &#123;</span><br><span class="line">				&#x2F;&#x2F; This may happen if the mailbox is closed. It means that the task is shutting down, so we just ignore it.</span><br><span class="line">				LOG.debug(</span><br><span class="line">					&quot;Triggering checkpoint &#123;&#125; for &#123;&#125; (&#123;&#125;) was rejected by the mailbox&quot;,</span><br><span class="line">					checkpointID, taskNameWithSubtask, executionId);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable t) &#123;</span><br><span class="line">				if (getExecutionState() &#x3D;&#x3D; ExecutionState.RUNNING) &#123;</span><br><span class="line">					failExternally(new Exception(</span><br><span class="line">						&quot;Error while triggering checkpoint &quot; + checkpointID + &quot; for &quot; +</span><br><span class="line">							taskNameWithSubtask, t));</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					LOG.debug(&quot;Encountered error while triggering checkpoint &#123;&#125; for &quot; +</span><br><span class="line">						&quot;&#123;&#125; (&#123;&#125;) while being not in state running.&quot;, checkpointID,</span><br><span class="line">						taskNameWithSubtask, executionId, t);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			LOG.debug(&quot;Declining checkpoint request for non-running task &#123;&#125; (&#123;&#125;).&quot;, taskNameWithSubtask, executionId);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; send back a message that we did not do the checkpoint</span><br><span class="line">			checkpointResponder.declineCheckpoint(jobId, executionId, checkpointID,</span><br><span class="line">					new CheckpointException(&quot;Task name with subtask : &quot; + taskNameWithSubtask, CheckpointFailureReason.CHECKPOINT_DECLINED_TASK_NOT_READY));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>执行AbstractInvokable的triggerCheckpointAsync，最终调用StreamTask的triggerCheckpointAsync，triggerCheckpointAsync向mailboxProcessor发送triggerCheckpoint的事件，从而实现异步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;Boolean&gt; triggerCheckpointAsync(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      boolean advanceToEndOfEventTime) &#123;</span><br><span class="line"></span><br><span class="line">   return mailboxProcessor.getMainMailboxExecutor().submit(</span><br><span class="line">         () -&gt; triggerCheckpoint(checkpointMetaData, checkpointOptions, advanceToEndOfEventTime),</span><br><span class="line">         &quot;checkpoint %s with %s&quot;,</span><br><span class="line">      checkpointMetaData,</span><br><span class="line">      checkpointOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private boolean triggerCheckpoint(</span><br><span class="line">			CheckpointMetaData checkpointMetaData,</span><br><span class="line">			CheckpointOptions checkpointOptions,</span><br><span class="line">			boolean advanceToEndOfEventTime) throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; No alignment if we inject a checkpoint</span><br><span class="line">			CheckpointMetrics checkpointMetrics &#x3D; new CheckpointMetrics()</span><br><span class="line">				.setBytesBufferedInAlignment(0L)</span><br><span class="line">				.setAlignmentDurationNanos(0L);</span><br><span class="line"></span><br><span class="line">			boolean success &#x3D; performCheckpoint(checkpointMetaData, checkpointOptions, checkpointMetrics, advanceToEndOfEventTime);</span><br><span class="line">			if (!success) &#123;</span><br><span class="line">				declineCheckpoint(checkpointMetaData.getCheckpointId());</span><br><span class="line">			&#125;</span><br><span class="line">			return success;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private boolean performCheckpoint(</span><br><span class="line">			CheckpointMetaData checkpointMetaData,</span><br><span class="line">			CheckpointOptions checkpointOptions,</span><br><span class="line">			CheckpointMetrics checkpointMetrics,</span><br><span class="line">			boolean advanceToEndOfTime) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		LOG.debug(&quot;Starting checkpoint (&#123;&#125;) &#123;&#125; on task &#123;&#125;&quot;,</span><br><span class="line">			checkpointMetaData.getCheckpointId(), checkpointOptions.getCheckpointType(), getName());</span><br><span class="line"></span><br><span class="line">		final long checkpointId &#x3D; checkpointMetaData.getCheckpointId();</span><br><span class="line"></span><br><span class="line">		if (isRunning) &#123;</span><br><span class="line">			actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">				if (checkpointOptions.getCheckpointType().isSynchronous()) &#123;</span><br><span class="line">					setSynchronousSavepointId(checkpointId);</span><br><span class="line"></span><br><span class="line">					if (advanceToEndOfTime) &#123;</span><br><span class="line">						advanceToEndOfEventTime();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; All of the following steps happen as an atomic step from the perspective of barriers and</span><br><span class="line">				&#x2F;&#x2F; records&#x2F;watermarks&#x2F;timers&#x2F;callbacks.</span><br><span class="line">				&#x2F;&#x2F; We generally try to emit the checkpoint barrier as soon as possible to not affect downstream</span><br><span class="line">				&#x2F;&#x2F; checkpoint alignments</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (1): Prepare the checkpoint, allow operators to do some pre-barrier work.</span><br><span class="line">				&#x2F;&#x2F;           The pre-barrier work should be nothing or minimal in the common case.</span><br><span class="line">				&#x2F;&#x2F;准备发送Barrier</span><br><span class="line">				operatorChain.prepareSnapshotPreBarrier(checkpointId);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (2): Send the checkpoint barrier downstream</span><br><span class="line">				&#x2F;&#x2F;向下游发送 barrier</span><br><span class="line">				operatorChain.broadcastCheckpointBarrier(</span><br><span class="line">						checkpointId,</span><br><span class="line">						checkpointMetaData.getTimestamp(),</span><br><span class="line">						checkpointOptions);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Step (3): Take the state snapshot. This should be largely asynchronous, to not</span><br><span class="line">				&#x2F;&#x2F;           impact progress of the streaming topology</span><br><span class="line">				&#x2F;&#x2F;存储检查点快照</span><br><span class="line">				checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			actionExecutor.runThrowing(() -&gt; &#123;</span><br><span class="line">				&#x2F;&#x2F; we cannot perform our checkpoint - let the downstream operators know that they</span><br><span class="line">				&#x2F;&#x2F; should not wait for any input from this operator</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; we cannot broadcast the cancellation markers on the &#39;operator chain&#39;, because it may not</span><br><span class="line">				&#x2F;&#x2F; yet be created</span><br><span class="line">				final CancelCheckpointMarker message &#x3D; new CancelCheckpointMarker(checkpointMetaData.getCheckpointId());</span><br><span class="line">				recordWriter.broadcastEvent(message);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>OperatorChain类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void prepareSnapshotPreBarrier(long checkpointId) throws Exception &#123;</span><br><span class="line">   &#x2F;&#x2F; go forward through the operator chain and tell each operator</span><br><span class="line">   &#x2F;&#x2F; to prepare the checkpoint</span><br><span class="line">   final StreamOperator&lt;?&gt;[] operators &#x3D; this.allOperators;</span><br><span class="line">   for (int i &#x3D; operators.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">      final StreamOperator&lt;?&gt; op &#x3D; operators[i];</span><br><span class="line">      if (op !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;用户函数实现</span><br><span class="line">         op.prepareSnapshotPreBarrier(checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void broadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个 CheckpointBarrier</span><br><span class="line">		CheckpointBarrier barrier &#x3D; new CheckpointBarrier(id, timestamp, checkpointOptions);</span><br><span class="line">		for (RecordWriterOutput&lt;?&gt; streamOutput : streamOutputs) &#123;</span><br><span class="line">		&#x2F;&#x2F;向所有的下游发送</span><br><span class="line">			streamOutput.broadcastEvent(barrier);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">RecordWriterOutput:</span><br><span class="line">public void broadcastEvent(AbstractEvent event) throws IOException &#123;</span><br><span class="line">		recordWriter.broadcastEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">RecordWriter:</span><br><span class="line">&#x2F;&#x2F;barrier被发送至ResultPartition</span><br><span class="line">public void broadcastEvent(AbstractEvent event) throws IOException &#123;</span><br><span class="line">		try (BufferConsumer eventBufferConsumer &#x3D; EventSerializer.toBufferConsumer(event)) &#123;</span><br><span class="line">			for (int targetChannel &#x3D; 0; targetChannel &lt; numberOfChannels; targetChannel++) &#123;</span><br><span class="line">				tryFinishCurrentBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Retain the buffer so that it can be recycled by each channel of targetPartition</span><br><span class="line">				targetPartition.addBufferConsumer(eventBufferConsumer.copy(), targetChannel);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (flushAlways) &#123;</span><br><span class="line">				flushAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道，每一个 Task 的通过 <code>InputGate</code> 消费上游 Task 产生的数据，而实际上在 <code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 中会创建 <code>CheckpointBarrierHandler</code>, <code>CheckpointBarrierHandler</code> 有两个具体的实现，即 CheckpointBarrierTracker和 CheckpointBarrierAligner，分别对应 AT_LEAST_ONCE 和 EXACTLY_ONCE 这两种模式。</p>
<p><code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 循环调用 <code>CheckpointBarrierHandler.getNextNonBlocked()</code> 获取新数据，因而在 <code>CheckpointBarrierHandler</code> 获得 <code>CheckpointBarrier</code> 后可以及时地进行 checkpoint 相关的操作。</p>
<p>回顾OneInputStreamTask的初始化过程，会创建CheckpointedInputGate用来接收Checkpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws Exception &#123;</span><br><span class="line">   StreamConfig configuration &#x3D; getConfiguration();</span><br><span class="line">   int numberOfInputs &#x3D; configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">   if (numberOfInputs &gt; 0) &#123;</span><br><span class="line">      CheckpointedInputGate inputGate &#x3D; createCheckpointedInputGate();</span><br><span class="line">      TaskIOMetricGroup taskIOMetricGroup &#x3D; getEnvironment().getMetricGroup().getIOMetricGroup();</span><br><span class="line">      taskIOMetricGroup.gauge(&quot;checkpointAlignmentTime&quot;, inputGate::getAlignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">      DataOutput&lt;IN&gt; output &#x3D; createDataOutput();</span><br><span class="line">      StreamTaskInput&lt;IN&gt; input &#x3D; createTaskInput(inputGate, output);</span><br><span class="line">      inputProcessor &#x3D; new StreamOneInputProcessor&lt;&gt;(</span><br><span class="line">         input,</span><br><span class="line">         output,</span><br><span class="line">         getCheckpointLock(),</span><br><span class="line">         operatorChain);</span><br><span class="line">   &#125;</span><br><span class="line">   headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge);</span><br><span class="line">   &#x2F;&#x2F; wrap watermark gauge since registered metrics must be unique</span><br><span class="line">   getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge::getValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CheckpointedInputGate，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private CheckpointedInputGate createCheckpointedInputGate() throws IOException &#123;</span><br><span class="line">   InputGate[] inputGates &#x3D; getEnvironment().getAllInputGates();</span><br><span class="line">   InputGate inputGate &#x3D; InputGateUtil.createInputGate(inputGates);</span><br><span class="line"></span><br><span class="line">   return InputProcessorUtil.createCheckpointedInputGate(</span><br><span class="line">      this,</span><br><span class="line">      configuration.getCheckpointMode(),</span><br><span class="line">      getEnvironment().getIOManager(),</span><br><span class="line">      inputGate,</span><br><span class="line">      getEnvironment().getTaskManagerInfo().getConfiguration(),</span><br><span class="line">      getTaskNameWithSubtaskAndId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputProcessorUtil.createCheckpointedInputGate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class InputProcessorUtil &#123;</span><br><span class="line"></span><br><span class="line">   public static CheckpointedInputGate createCheckpointedInputGate(</span><br><span class="line">         AbstractInvokable toNotifyOnCheckpoint,</span><br><span class="line">         CheckpointingMode checkpointMode,</span><br><span class="line">         IOManager ioManager,</span><br><span class="line">         InputGate inputGate,</span><br><span class="line">         Configuration taskManagerConfig,</span><br><span class="line">         String taskName) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      int pageSize &#x3D; ConfigurationParserUtils.getPageSize(taskManagerConfig);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建用于barrier对齐的数据缓存</span><br><span class="line">      BufferStorage bufferStorage &#x3D; createBufferStorage(</span><br><span class="line">         checkpointMode, ioManager, pageSize, taskManagerConfig, taskName);</span><br><span class="line">         &#x2F;&#x2F;创建CheckpointBarrierHandler</span><br><span class="line">      CheckpointBarrierHandler barrierHandler &#x3D; createCheckpointBarrierHandler(</span><br><span class="line">         checkpointMode, inputGate.getNumberOfInputChannels(), taskName, toNotifyOnCheckpoint);</span><br><span class="line">      return new CheckpointedInputGate(inputGate, bufferStorage, barrierHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>EXACTLY_ONCE才需要BufferStorage，AT_LEAST_ONCE不需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static BufferStorage createBufferStorage(</span><br><span class="line">      CheckpointingMode checkpointMode,</span><br><span class="line">      IOManager ioManager,</span><br><span class="line">      int pageSize,</span><br><span class="line">      Configuration taskManagerConfig,</span><br><span class="line">      String taskName) &#123;</span><br><span class="line">   switch (checkpointMode) &#123;</span><br><span class="line">      case EXACTLY_ONCE: &#123;</span><br><span class="line">         long maxAlign &#x3D; taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);</span><br><span class="line">         if (!(maxAlign &#x3D;&#x3D; -1 || maxAlign &gt; 0)) &#123;</span><br><span class="line">            throw new IllegalConfigurationException(</span><br><span class="line">               TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()</span><br><span class="line">                  + &quot; must be positive or -1 (infinite)&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         return new CachedBufferStorage(pageSize, maxAlign, taskName);</span><br><span class="line">      &#125;</span><br><span class="line">      case AT_LEAST_ONCE:</span><br><span class="line">         return new EmptyBufferStorage();</span><br><span class="line">      default:</span><br><span class="line">         throw new UnsupportedOperationException(&quot;Unrecognized Checkpointing Mode: &quot; + checkpointMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EXACTLY_ONCE创建CheckpointBarrierAligner，AT_LEAST_ONCE创建CheckpointBarrierTracker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static CheckpointBarrierHandler createCheckpointBarrierHandler(</span><br><span class="line">      CheckpointingMode checkpointMode,</span><br><span class="line">      int numberOfInputChannels,</span><br><span class="line">      String taskName,</span><br><span class="line">      AbstractInvokable toNotifyOnCheckpoint) &#123;</span><br><span class="line">   switch (checkpointMode) &#123;</span><br><span class="line">      case EXACTLY_ONCE:</span><br><span class="line">         return new CheckpointBarrierAligner(</span><br><span class="line">            numberOfInputChannels,</span><br><span class="line">            taskName,</span><br><span class="line">            toNotifyOnCheckpoint);</span><br><span class="line">      case AT_LEAST_ONCE:</span><br><span class="line">         return new CheckpointBarrierTracker(numberOfInputChannels, toNotifyOnCheckpoint);</span><br><span class="line">      default:</span><br><span class="line">         throw new UnsupportedOperationException(&quot;Unrecognized Checkpointing Mode: &quot; + checkpointMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>StreamTwoInputProcessor</code> 的执行阶段会调用checkpointedInputGate.pollNext()循环获取事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public InputStatus processInput() throws Exception &#123;</span><br><span class="line">   InputStatus status &#x3D; input.emitNext(output);</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">   return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public InputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">			Optional&lt;BufferOrEvent&gt; bufferOrEvent &#x3D; checkpointedInputGate.pollNext();</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>pollNext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;BufferOrEvent&gt; pollNext() throws Exception &#123;</span><br><span class="line">   while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; process buffered BufferOrEvents before grabbing new ones</span><br><span class="line">      &#x2F;&#x2F;如果bufferStorage不为空，则优先处理bufferStorage的数据</span><br><span class="line">      Optional&lt;BufferOrEvent&gt; next;</span><br><span class="line">      if (bufferStorage.isEmpty()) &#123;</span><br><span class="line">         next &#x3D; inputGate.pollNext();</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; TODO: FLINK-12536 for non credit-based flow control, getNext method is blocking</span><br><span class="line">         next &#x3D; bufferStorage.pollNext();</span><br><span class="line">         if (!next.isPresent()) &#123;</span><br><span class="line">            return pollNext();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!next.isPresent()) &#123;</span><br><span class="line">         return handleEmptyBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BufferOrEvent bufferOrEvent &#x3D; next.get();</span><br><span class="line">      </span><br><span class="line">      if (barrierHandler.isBlocked(offsetChannelIndex(bufferOrEvent.getChannelIndex()))) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果是EXACTLY_ONCE的CheckpointBarrierAligner，则阻塞，将消息刚入bufferStorage</span><br><span class="line">         &#x2F;&#x2F; if the channel is blocked, we just store the BufferOrEvent</span><br><span class="line">         bufferStorage.add(bufferOrEvent);</span><br><span class="line">         if (bufferStorage.isFull()) &#123;</span><br><span class="line">            barrierHandler.checkpointSizeLimitExceeded(bufferStorage.getMaxBufferedBytes());</span><br><span class="line">            &#x2F;&#x2F;如果bufferStorage满了，则开启一个新的存储队列</span><br><span class="line">            bufferStorage.rollOver();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">         return next;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;如果是CheckpointBarrier数据，则调用barrierHandler.processBarrier</span><br><span class="line">      else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CheckpointBarrier.class) &#123;</span><br><span class="line">         CheckpointBarrier checkpointBarrier &#x3D; (CheckpointBarrier) bufferOrEvent.getEvent();</span><br><span class="line">         if (!endOfInputGate) &#123;</span><br><span class="line">            &#x2F;&#x2F; process barriers only if there is a chance of the checkpoint completing</span><br><span class="line">            if (barrierHandler.processBarrier(checkpointBarrier, offsetChannelIndex(bufferOrEvent.getChannelIndex()), bufferStorage.getPendingBytes())) &#123;</span><br><span class="line">               bufferStorage.rollOver();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CancelCheckpointMarker.class) &#123;</span><br><span class="line">         if (barrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent())) &#123;</span><br><span class="line">            bufferStorage.rollOver();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">            if (barrierHandler.processEndOfPartition()) &#123;</span><br><span class="line">               bufferStorage.rollOver();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return next;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AT_LEAST_ONCE的CheckpointBarrierTracker的processBarrier过程，它仅仅追踪从每一个 input channel 接收到的 barrier，当所有 input channel 的 barrier 都被接收时，就可以触发 checkpoint 了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception &#123;</span><br><span class="line">   final long barrierId &#x3D; receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; fast path for single channel trackers</span><br><span class="line">   if (totalNumberOfInputChannels &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      notifyCheckpoint(receivedBarrier, 0, 0);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; general path for multiple input channels</span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;Received barrier for checkpoint &#123;&#125; from channel &#123;&#125;&quot;, barrierId, channelIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; find the checkpoint barrier in the queue of pending barriers</span><br><span class="line">   CheckpointBarrierCount barrierCount &#x3D; null;</span><br><span class="line">   int pos &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   for (CheckpointBarrierCount next : pendingCheckpoints) &#123;</span><br><span class="line">      if (next.checkpointId &#x3D;&#x3D; barrierId) &#123;</span><br><span class="line">         barrierCount &#x3D; next;</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      pos++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (barrierCount !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; add one to the count to that barrier and check for completion</span><br><span class="line">      int numBarriersNew &#x3D; barrierCount.incrementBarrierCount();</span><br><span class="line">      if (numBarriersNew &#x3D;&#x3D; totalNumberOfInputChannels) &#123;</span><br><span class="line">      &#x2F;&#x2F; 在当前 barrierId 前面的所有未完成的 checkpoint 都可以丢弃了</span><br><span class="line">         &#x2F;&#x2F; checkpoint can be triggered (or is aborted and all barriers have been seen)</span><br><span class="line">         &#x2F;&#x2F; first, remove this checkpoint and all all prior pending</span><br><span class="line">         &#x2F;&#x2F; checkpoints (which are now subsumed)</span><br><span class="line">         for (int i &#x3D; 0; i &lt;&#x3D; pos; i++) &#123;</span><br><span class="line">            pendingCheckpoints.pollFirst();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; notify the listener</span><br><span class="line">         if (!barrierCount.isAborted()) &#123;</span><br><span class="line">            if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">               LOG.debug(&quot;Received all barriers for checkpoint &#123;&#125;&quot;, barrierId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知进行 checkpoint</span><br><span class="line">            notifyCheckpoint(receivedBarrier, 0, 0);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; first barrier for that checkpoint ID</span><br><span class="line">      &#x2F;&#x2F; add it only if it is newer than the latest checkpoint.</span><br><span class="line">      &#x2F;&#x2F; if it is not newer than the latest checkpoint ID, then there cannot be a</span><br><span class="line">      &#x2F;&#x2F; successful checkpoint for that ID anyways</span><br><span class="line">      if (barrierId &gt; latestPendingCheckpointID) &#123;</span><br><span class="line">         latestPendingCheckpointID &#x3D; barrierId;</span><br><span class="line">         pendingCheckpoints.addLast(new CheckpointBarrierCount(barrierId));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; make sure we do not track too many checkpoints</span><br><span class="line">         if (pendingCheckpoints.size() &gt; MAX_CHECKPOINTS_TO_TRACK) &#123;</span><br><span class="line">            pendingCheckpoints.pollFirst();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于 EXACTLY_ONCE 模式下的 <code>BarrierBuffer</code>，它除了要追踪每一个 input channel 接收到的 barrier 之外，在接收到所有的 barrier 之前，先收到 barrier 的 channel 要进入阻塞状态。当然为了避免进入“反压”状态，<code>BarrierBuffer</code> 会继续接收数据，但会对接收到的数据进行缓存，直到所有的 barrier 都到达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception &#123;</span><br><span class="line">   final long barrierId &#x3D; receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; fast path for single channel cases</span><br><span class="line">   &#x2F;&#x2F;只有一个InputChannel，即只有1个barrier</span><br><span class="line">   if (totalNumberOfInputChannels &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">         &#x2F;&#x2F; new checkpoint</span><br><span class="line">         currentCheckpointId &#x3D; barrierId;</span><br><span class="line">         notifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   boolean checkpointAborted &#x3D; false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; -- general code path for multiple input channels --</span><br><span class="line"></span><br><span class="line">   if (numBarriersReceived &gt; 0) &#123;</span><br><span class="line">   &#x2F;&#x2F;已经收到了多个Barriers</span><br><span class="line">      &#x2F;&#x2F; this is only true if some alignment is already progress and was not canceled</span><br><span class="line"></span><br><span class="line">      if (barrierId &#x3D;&#x3D; currentCheckpointId) &#123;</span><br><span class="line">         &#x2F;&#x2F; regular case</span><br><span class="line">         &#x2F;&#x2F;barrierId是当前正在对齐的barrierId</span><br><span class="line">         onBarrier(channelIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">      &#x2F;&#x2F;barrierId比正在对齐的barrierId大，则废除当前正在做的Checkpoint</span><br><span class="line">         &#x2F;&#x2F; we did not complete the current checkpoint, another started before</span><br><span class="line">         LOG.warn(&quot;&#123;&#125;: Received checkpoint barrier for checkpoint &#123;&#125; before completing current checkpoint &#123;&#125;. &quot; +</span><br><span class="line">               &quot;Skipping current checkpoint.&quot;,</span><br><span class="line">            taskName,</span><br><span class="line">            barrierId,</span><br><span class="line">            currentCheckpointId);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; let the task know we are not completing this</span><br><span class="line">         notifyAbort(currentCheckpointId,</span><br><span class="line">            new CheckpointException(</span><br><span class="line">               &quot;Barrier id: &quot; + barrierId,</span><br><span class="line">               CheckpointFailureReason.CHECKPOINT_DECLINED_SUBSUMED));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; abort the current checkpoint</span><br><span class="line">         releaseBlocksAndResetBarriers();</span><br><span class="line">         checkpointAborted &#x3D; true;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; begin a the new checkpoint</span><br><span class="line">         &#x2F;&#x2F;重新开始对齐</span><br><span class="line">         beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; ignore trailing barrier from an earlier checkpoint (obsolete now)</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">      &#x2F;&#x2F; first barrier of a new checkpoint</span><br><span class="line">      &#x2F;&#x2F;收到了第一个barrier并且之前对齐的barrierId大</span><br><span class="line">      beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; either the current checkpoint was canceled (numBarriers &#x3D;&#x3D; 0) or</span><br><span class="line">      &#x2F;&#x2F; this barrier is from an old subsumed checkpoint</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; check if we have all barriers - since canceled checkpoints always have zero barriers</span><br><span class="line">   &#x2F;&#x2F; this can only happen on a non canceled checkpoint</span><br><span class="line">   &#x2F;&#x2F;是否收到了所有InputChannel的barrier</span><br><span class="line">   if (numBarriersReceived + numClosedChannels &#x3D;&#x3D; totalNumberOfInputChannels) &#123;</span><br><span class="line">      &#x2F;&#x2F; actually trigger checkpoint</span><br><span class="line">      if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">         LOG.debug(&quot;&#123;&#125;: Received all barriers, triggering checkpoint &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">            taskName,</span><br><span class="line">            receivedBarrier.getId(),</span><br><span class="line">            receivedBarrier.getTimestamp());</span><br><span class="line">      &#125;</span><br><span class="line">  &#x2F;&#x2F;释放缓存，并通知进行 checkpoint</span><br><span class="line">      releaseBlocksAndResetBarriers();</span><br><span class="line">      notifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return checkpointAborted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;阻塞已收到barrier的InputChannel</span><br><span class="line">protected void onBarrier(int channelIndex) throws IOException &#123;</span><br><span class="line">		if (!blockedChannels[channelIndex]) &#123;</span><br><span class="line">			blockedChannels[channelIndex] &#x3D; true;</span><br><span class="line"></span><br><span class="line">			numBarriersReceived++;</span><br><span class="line"></span><br><span class="line">			if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">				LOG.debug(&quot;&#123;&#125;: Received barrier from channel &#123;&#125;.&quot;, taskName, channelIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			throw new IOException(&quot;Stream corrupt: Repeated barrier for same checkpoint on input &quot; + channelIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;开启新的对齐，更新currentCheckpointId，并阻塞InputChannel</span><br><span class="line">protected void beginNewAlignment(long checkpointId, int channelIndex) throws IOException &#123;</span><br><span class="line">		currentCheckpointId &#x3D; checkpointId;</span><br><span class="line">		onBarrier(channelIndex);</span><br><span class="line"></span><br><span class="line">		startOfAlignmentTimestamp &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">		if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">			LOG.debug(&quot;&#123;&#125;: Starting stream alignment for checkpoint &#123;&#125;.&quot;, taskName, checkpointId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;将InputChannel变为非阻塞，并计算对齐耗时</span><br><span class="line">public void releaseBlocksAndResetBarriers() &#123;</span><br><span class="line">		LOG.debug(&quot;&#123;&#125;: End of stream alignment, feeding buffered data back.&quot;, taskName);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; blockedChannels.length; i++) &#123;</span><br><span class="line">			blockedChannels[i] &#x3D; false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; the next barrier that comes must assume it is the first</span><br><span class="line">		numBarriersReceived &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		if (startOfAlignmentTimestamp &gt; 0) &#123;</span><br><span class="line">			latestAlignmentDurationNanos &#x3D; System.nanoTime() - startOfAlignmentTimestamp;</span><br><span class="line">			startOfAlignmentTimestamp &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用CheckpointBarrierHandler的notifyCheckpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void notifyCheckpoint(CheckpointBarrier checkpointBarrier, long bufferedBytes, long alignmentDurationNanos) throws Exception &#123;</span><br><span class="line">   if (toNotifyOnCheckpoint !&#x3D; null) &#123;</span><br><span class="line">      CheckpointMetaData checkpointMetaData &#x3D;</span><br><span class="line">         new CheckpointMetaData(checkpointBarrier.getId(), checkpointBarrier.getTimestamp());</span><br><span class="line"></span><br><span class="line">      CheckpointMetrics checkpointMetrics &#x3D; new CheckpointMetrics()</span><br><span class="line">         .setBytesBufferedInAlignment(bufferedBytes)</span><br><span class="line">         .setAlignmentDurationNanos(alignmentDurationNanos);</span><br><span class="line"></span><br><span class="line">      toNotifyOnCheckpoint.triggerCheckpointOnBarrier(</span><br><span class="line">         checkpointMetaData,</span><br><span class="line">         checkpointBarrier.getCheckpointOptions(),</span><br><span class="line">         checkpointMetrics);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用AbstractInvokable的triggerCheckpointOnBarrier，即StreamTask的triggerCheckpointOnBarrier，triggerCheckpointOnBarrier与triggerCheckpointAsync基本一样，其中 triggerCheckpointAsync是触发 checkpoint 的源头，会向下游注入 <code>CheckpointBarrier</code>；而下游的其他任务在收到 <code>CheckpointBarrier</code> 后调用 <code>triggerCheckpointOnBarrier</code> 方法。这两个方法的具体实现有一些细微的差异，但主要的逻辑是一致的，在 <code>StreamTask.performCheckpoint()</code> 方法中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void triggerCheckpointOnBarrier(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      CheckpointMetrics checkpointMetrics) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      if (performCheckpoint(checkpointMetaData, checkpointOptions, checkpointMetrics, false)) &#123;</span><br><span class="line">         if (isSynchronousSavepointId(checkpointMetaData.getCheckpointId())) &#123;</span><br><span class="line">            runSynchronousSavepointMailboxLoop();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (CancelTaskException e) &#123;</span><br><span class="line">      LOG.info(&quot;Operator &#123;&#125; was cancelled while performing checkpoint &#123;&#125;.&quot;,</span><br><span class="line">            getName(), checkpointMetaData.getCheckpointId());</span><br><span class="line">      throw e;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      throw new Exception(&quot;Could not perform checkpoint &quot; + checkpointMetaData.getCheckpointId() + &quot; for operator &quot; +</span><br><span class="line">         getName() + &#39;.&#39;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾performCheckpoint方法，发送Checkpoint经历三个步骤，准备发送，向下游发送Checkpoint，存储检查点快照状态。刚才的步骤是向下游发送Checkpoint，接下来看下怎么存储快照，就是StreamTask的checkpointState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void checkpointState(</span><br><span class="line">      CheckpointMetaData checkpointMetaData,</span><br><span class="line">      CheckpointOptions checkpointOptions,</span><br><span class="line">      CheckpointMetrics checkpointMetrics) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 解析得到 CheckpointStorageLocation</span><br><span class="line">   CheckpointStreamFactory storage &#x3D; checkpointStorage.resolveCheckpointStorageLocation(</span><br><span class="line">         checkpointMetaData.getCheckpointId(),</span><br><span class="line">         checkpointOptions.getTargetLocation());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2. 将存储过程封装为 CheckpointingOperation，开始进行检查点存储操作</span><br><span class="line">   CheckpointingOperation checkpointingOperation &#x3D; new CheckpointingOperation(</span><br><span class="line">      this,</span><br><span class="line">      checkpointMetaData,</span><br><span class="line">      checkpointOptions,</span><br><span class="line">      storage,</span><br><span class="line">      checkpointMetrics);</span><br><span class="line"></span><br><span class="line">   checkpointingOperation.executeCheckpointing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查点快照的过程被封装为 <code>CheckpointingOperation</code>，由于每一个 <code>StreamTask</code> 可能包含多个算子，因而内部使用一个 Map 维护 <code>OperatorID -&gt; OperatorSnapshotFutures</code> 的关系。<code>CheckpointingOperation</code>中，快照操作分为两个阶段，第一阶段是同步执行的，第二阶段是异步执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static final class CheckpointingOperation &#123;</span><br><span class="line"></span><br><span class="line">   private final StreamTask&lt;?, ?&gt; owner;</span><br><span class="line"></span><br><span class="line">   private final CheckpointMetaData checkpointMetaData;</span><br><span class="line">   private final CheckpointOptions checkpointOptions;</span><br><span class="line">   private final CheckpointMetrics checkpointMetrics;</span><br><span class="line">   private final CheckpointStreamFactory storageLocation;</span><br><span class="line"></span><br><span class="line">   private final StreamOperator&lt;?&gt;[] allOperators;</span><br><span class="line"></span><br><span class="line">   private long startSyncPartNano;</span><br><span class="line">   private long startAsyncPartNano;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------</span><br><span class="line">&#x2F;&#x2F;每一个算子的快照被抽象为 OperatorSnapshotFutures，包含了 operator state 和 keyed state 的快照结果：</span><br><span class="line">   private final Map&lt;OperatorID, OperatorSnapshotFutures&gt; operatorSnapshotsInProgress;</span><br><span class="line"></span><br><span class="line">   public void executeCheckpointing() throws Exception &#123;</span><br><span class="line">      startSyncPartNano &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;1. 同步执行的部分</span><br><span class="line">         for (StreamOperator&lt;?&gt; op : allOperators) &#123;</span><br><span class="line">            checkpointStreamOperator(op);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;Finished synchronous checkpoints for checkpoint &#123;&#125; on task &#123;&#125;&quot;,</span><br><span class="line">               checkpointMetaData.getCheckpointId(), owner.getName());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         startAsyncPartNano &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">         checkpointMetrics.setSyncDurationMillis((startAsyncPartNano - startSyncPartNano) &#x2F; 1_000_000);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; we are transferring ownership over snapshotInProgressList for cleanup to the thread, active on submit</span><br><span class="line">         &#x2F;&#x2F;2. 异步执行的部分</span><br><span class="line">				&#x2F;&#x2F; checkpoint 可以配置成同步执行，也可以配置成异步执行的</span><br><span class="line">				&#x2F;&#x2F; 如果是同步执行的，在这里实际上所有的 runnable future 都是已经完成的状态</span><br><span class="line">         AsyncCheckpointRunnable asyncCheckpointRunnable &#x3D; new AsyncCheckpointRunnable(</span><br><span class="line">            owner,</span><br><span class="line">            operatorSnapshotsInProgress,</span><br><span class="line">            checkpointMetaData,</span><br><span class="line">            checkpointMetrics,</span><br><span class="line">            startAsyncPartNano);</span><br><span class="line"></span><br><span class="line">         owner.cancelables.registerCloseable(asyncCheckpointRunnable);</span><br><span class="line">         owner.asyncOperationsThreadPool.execute(asyncCheckpointRunnable);</span><br><span class="line"></span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - finished synchronous part of checkpoint &#123;&#125;. &quot; +</span><br><span class="line">                  &quot;Alignment duration: &#123;&#125; ms, snapshot duration &#123;&#125; ms&quot;,</span><br><span class="line">               owner.getName(), checkpointMetaData.getCheckpointId(),</span><br><span class="line">               checkpointMetrics.getAlignmentDurationNanos() &#x2F; 1_000_000,</span><br><span class="line">               checkpointMetrics.getSyncDurationMillis());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>每一个算子的快照被抽象为 <code>OperatorSnapshotFutures</code>，包含了 operator state 和 keyed state 的快照结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorSnapshotFutures &#123;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateManagedFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; keyedStateRawFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateManagedFuture;</span><br><span class="line"></span><br><span class="line">   @Nonnull</span><br><span class="line">   private RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; operatorStateRawFuture;</span><br></pre></td></tr></table></figure>

<p>checkpointStreamOperator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void checkpointStreamOperator(StreamOperator&lt;?&gt; op) throws Exception &#123;</span><br><span class="line">   if (null !&#x3D; op) &#123;</span><br><span class="line">&#x2F;&#x2F; 调用 StreamOperator.snapshotState 方法进行快照</span><br><span class="line">				&#x2F;&#x2F; 返回的结果是 runnable future，可能是已经执行完了，也可能没有执行完</span><br><span class="line">      OperatorSnapshotFutures snapshotInProgress &#x3D; op.snapshotState(</span><br><span class="line">            checkpointMetaData.getCheckpointId(),</span><br><span class="line">            checkpointMetaData.getTimestamp(),</span><br><span class="line">            checkpointOptions,</span><br><span class="line">            storageLocation);</span><br><span class="line">      operatorSnapshotsInProgress.put(op.getOperatorID(), snapshotInProgress);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同步执行阶段，会依次调用每一个算子的 <code>StreamOperator.snapshotState</code>，返回结果是一个 runnable future。根据 checkpoint 配置成同步模式和异步模式的区别，这个 future 可能处于完成状态，也可能处于未完成状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">StreamOperator：</span><br><span class="line">OperatorSnapshotFutures snapshotState(</span><br><span class="line">   long checkpointId,</span><br><span class="line">   long timestamp,</span><br><span class="line">   CheckpointOptions checkpointOptions,</span><br><span class="line">   CheckpointStreamFactory storageLocation) throws Exception;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">AbstractStreamOperator：</span><br><span class="line">@Override</span><br><span class="line">	public final OperatorSnapshotFutures snapshotState(long checkpointId, long timestamp, CheckpointOptions checkpointOptions,</span><br><span class="line">			CheckpointStreamFactory factory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		KeyGroupRange keyGroupRange &#x3D; null !&#x3D; keyedStateBackend ?</span><br><span class="line">				keyedStateBackend.getKeyGroupRange() : KeyGroupRange.EMPTY_KEY_GROUP_RANGE;</span><br><span class="line"></span><br><span class="line">		OperatorSnapshotFutures snapshotInProgress &#x3D; new OperatorSnapshotFutures();</span><br><span class="line"></span><br><span class="line">		StateSnapshotContextSynchronousImpl snapshotContext &#x3D; new StateSnapshotContextSynchronousImpl(</span><br><span class="line">			checkpointId,</span><br><span class="line">			timestamp,</span><br><span class="line">			factory,</span><br><span class="line">			keyGroupRange,</span><br><span class="line">			getContainingTask().getCancelables());</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;对状态进行快照</span><br><span class="line">			snapshotState(snapshotContext);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;raw state，要在子类中自己实现 raw state 的快照写入</span><br><span class="line">			&#x2F;&#x2F;timer 是作为 raw keyed state 写入的snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());</span><br><span class="line">			snapshotInProgress.setOperatorStateRawFuture(snapshotContext.getOperatorStateStreamFuture());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写入 managed state 快照</span><br><span class="line">			if (null !&#x3D; operatorStateBackend) &#123;</span><br><span class="line">				snapshotInProgress.setOperatorStateManagedFuture(</span><br><span class="line">					operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写入 managed keyed state 快照</span><br><span class="line">			if (null !&#x3D; keyedStateBackend) &#123;</span><br><span class="line">				snapshotInProgress.setKeyedStateManagedFuture(</span><br><span class="line">					keyedStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception snapshotException) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				snapshotInProgress.cancel();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				snapshotException.addSuppressed(e);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String snapshotFailMessage &#x3D; &quot;Could not complete snapshot &quot; + checkpointId + &quot; for operator &quot; +</span><br><span class="line">				getOperatorName() + &quot;.&quot;;</span><br><span class="line"></span><br><span class="line">			if (!getContainingTask().isCanceled()) &#123;</span><br><span class="line">				LOG.info(snapshotFailMessage, snapshotException);</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				snapshotContext.closeExceptionally();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				snapshotException.addSuppressed(e);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new CheckpointException(snapshotFailMessage, CheckpointFailureReason.CHECKPOINT_DECLINED, snapshotException);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return snapshotInProgress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void snapshotState(StateSnapshotContext context) throws Exception &#123;</span><br><span class="line">		final KeyedStateBackend&lt;?&gt; keyedStateBackend &#x3D; getKeyedStateBackend();</span><br><span class="line">		&#x2F;&#x2F;TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots</span><br><span class="line">		&#x2F;&#x2F; 所有的 timer 都作为 raw keyed state 写入</span><br><span class="line">		if (keyedStateBackend instanceof AbstractKeyedStateBackend &amp;&amp;</span><br><span class="line">			((AbstractKeyedStateBackend&lt;?&gt;) keyedStateBackend).requiresLegacySynchronousTimerSnapshots()) &#123;</span><br><span class="line"></span><br><span class="line">			KeyedStateCheckpointOutputStream out;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				out &#x3D; context.getRawKeyedOperatorStateOutput();</span><br><span class="line">			&#125; catch (Exception exception) &#123;</span><br><span class="line">				throw new Exception(&quot;Could not open raw keyed operator state stream for &quot; +</span><br><span class="line">					getOperatorName() + &#39;.&#39;, exception);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				KeyGroupsList allKeyGroups &#x3D; out.getKeyGroupList();</span><br><span class="line">				for (int keyGroupIdx : allKeyGroups) &#123;</span><br><span class="line">					out.startNewKeyGroup(keyGroupIdx);</span><br><span class="line"></span><br><span class="line">					timeServiceManager.snapshotStateForKeyGroup(</span><br><span class="line">						new DataOutputViewStreamWrapper(out), keyGroupIdx);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Exception exception) &#123;</span><br><span class="line">				throw new Exception(&quot;Could not write timer service of &quot; + getOperatorName() +</span><br><span class="line">					&quot; to checkpoint state stream.&quot;, exception);</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					out.close();</span><br><span class="line">				&#125; catch (Exception closeException) &#123;</span><br><span class="line">					LOG.warn(&quot;Could not close raw keyed operator state stream for &#123;&#125;. This &quot; +</span><br><span class="line">						&quot;might have prevented deleting some state data.&quot;, getOperatorName(), closeException);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;用户也可以自己实现snapshotState，AbstractUdfStreamOperator继承AbstractStreamOperator</span><br><span class="line">public void snapshotState(StateSnapshotContext context) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;先调用父类AbstractStreamOperator方法，写入timer</span><br><span class="line">		super.snapshotState(context);</span><br><span class="line">		&#x2F;&#x2F;通过反射调用用户函数中的快照操作</span><br><span class="line">		StreamingFunctionUtils.snapshotFunctionState(context, getOperatorStateBackend(), userFunction);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	StreamingFunctionUtils类：</span><br><span class="line">public static void snapshotFunctionState(</span><br><span class="line">			StateSnapshotContext context,</span><br><span class="line">			OperatorStateBackend backend,</span><br><span class="line">			Function userFunction) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		Preconditions.checkNotNull(context);</span><br><span class="line">		Preconditions.checkNotNull(backend);</span><br><span class="line"></span><br><span class="line">		while (true) &#123;</span><br><span class="line"></span><br><span class="line">			if (trySnapshotFunctionState(context, backend, userFunction)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function</span><br><span class="line">			if (userFunction instanceof WrappingFunction) &#123;</span><br><span class="line">				userFunction &#x3D; ((WrappingFunction&lt;?&gt;) userFunction).getWrappedFunction();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private static boolean trySnapshotFunctionState(</span><br><span class="line">			StateSnapshotContext context,</span><br><span class="line">			OperatorStateBackend backend,</span><br><span class="line">			Function userFunction) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果用户函数实现了 CheckpointedFunction 接口，调用 snapshotState 创建快照</span><br><span class="line">		if (userFunction instanceof CheckpointedFunction) &#123;</span><br><span class="line">			((CheckpointedFunction) userFunction).snapshotState(context);</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果用户函数实现了 ListCheckpointed</span><br><span class="line">		if (userFunction instanceof ListCheckpointed) &#123;</span><br><span class="line">		&#x2F;&#x2F;先调用 snapshotState 方法获取当前状态</span><br><span class="line">			@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			List&lt;Serializable&gt; partitionableState &#x3D; ((ListCheckpointed&lt;Serializable&gt;) userFunction).</span><br><span class="line">					snapshotState(context.getCheckpointId(), context.getCheckpointTimestamp());</span><br><span class="line">&#x2F;&#x2F;获取后端存储的状态的引用</span><br><span class="line">			ListState&lt;Serializable&gt; listState &#x3D; backend.</span><br><span class="line">					getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME);</span><br><span class="line">&#x2F;&#x2F;清空当前后端存储的 ListState</span><br><span class="line">			listState.clear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前状态依次加入后端存储</span><br><span class="line">			if (null !&#x3D; partitionableState) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					for (Serializable statePartition : partitionableState) &#123;</span><br><span class="line">						listState.add(statePartition);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					listState.clear();</span><br><span class="line"></span><br><span class="line">					throw new Exception(&quot;Could not write partitionable state to operator &quot; +</span><br><span class="line">						&quot;state backend.&quot;, e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经看到 checkpoint 操作是如何同用户自定义函数建立关联的了，接下来我们来看看由 Flink 托管的状态是如何写入存储系统的。</p>
<p>首先来看看 operator state。<code>DefaultOperatorStateBackend</code> 将实际的工作交给 <code>DefaultOperatorStateBackendSnapshotStrategy</code> 完成。首先，会为对当前注册的所有 operator state（包含 list state 和 broadcast state）做深度拷贝，然后将实际的写入操作封装在一个异步的 FutureTask 中，这个 FutureTask 的主要任务包括： 1）打开输出流 2）写入状态元数据信息 3）写入状态 4）关闭输出流，获得状态句柄。如果不启用异步checkpoint模式，那么这个 FutureTask 在同步阶段就会立刻执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">public RunnableFuture&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; snapshot(</span><br><span class="line">   final long checkpointId,</span><br><span class="line">   final long timestamp,</span><br><span class="line">   @Nonnull final CheckpointStreamFactory streamFactory,</span><br><span class="line">   @Nonnull final CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   if (registeredOperatorStates.isEmpty() &amp;&amp; registeredBroadcastStates.isEmpty()) &#123;</span><br><span class="line">      return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final Map&lt;String, PartitionableListState&lt;?&gt;&gt; registeredOperatorStatesDeepCopies &#x3D;</span><br><span class="line">      new HashMap&lt;&gt;(registeredOperatorStates.size());</span><br><span class="line">   final Map&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; registeredBroadcastStatesDeepCopies &#x3D;</span><br><span class="line">      new HashMap&lt;&gt;(registeredBroadcastStates.size());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得已注册的所有 list state 和 broadcast state 的深拷贝</span><br><span class="line">   ClassLoader snapshotClassLoader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">   Thread.currentThread().setContextClassLoader(userClassLoader);</span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; eagerly create deep copies of the list and the broadcast states (if any)</span><br><span class="line">      &#x2F;&#x2F; in the synchronous phase, so that we can use them in the async writing.</span><br><span class="line"></span><br><span class="line">      if (!registeredOperatorStates.isEmpty()) &#123;</span><br><span class="line">         for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry : registeredOperatorStates.entrySet()) &#123;</span><br><span class="line">            PartitionableListState&lt;?&gt; listState &#x3D; entry.getValue();</span><br><span class="line">            if (null !&#x3D; listState) &#123;</span><br><span class="line">               listState &#x3D; listState.deepCopy();</span><br><span class="line">            &#125;</span><br><span class="line">            registeredOperatorStatesDeepCopies.put(entry.getKey(), listState);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!registeredBroadcastStates.isEmpty()) &#123;</span><br><span class="line">         for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry : registeredBroadcastStates.entrySet()) &#123;</span><br><span class="line">            BackendWritableBroadcastState&lt;?, ?&gt; broadcastState &#x3D; entry.getValue();</span><br><span class="line">            if (null !&#x3D; broadcastState) &#123;</span><br><span class="line">               broadcastState &#x3D; broadcastState.deepCopy();</span><br><span class="line">            &#125;</span><br><span class="line">            registeredBroadcastStatesDeepCopies.put(entry.getKey(), broadcastState);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setContextClassLoader(snapshotClassLoader);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将主要写入操作封装为一个异步的FutureTask</span><br><span class="line">   AsyncSnapshotCallable&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; snapshotCallable &#x3D;</span><br><span class="line">      new AsyncSnapshotCallable&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected SnapshotResult&lt;OperatorStateHandle&gt; callInternal() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 创建状态输出流</span><br><span class="line">            CheckpointStreamFactory.CheckpointStateOutputStream localOut &#x3D;</span><br><span class="line">               streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE);</span><br><span class="line">            snapshotCloseableRegistry.registerCloseable(localOut);</span><br><span class="line">&#x2F;&#x2F; 收集元数据</span><br><span class="line">            &#x2F;&#x2F; get the registered operator state infos ...</span><br><span class="line">            List&lt;StateMetaInfoSnapshot&gt; operatorMetaInfoSnapshots &#x3D;</span><br><span class="line">               new ArrayList&lt;&gt;(registeredOperatorStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry :</span><br><span class="line">               registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">               operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... get the registered broadcast operator state infos ...</span><br><span class="line">            List&lt;StateMetaInfoSnapshot&gt; broadcastMetaInfoSnapshots &#x3D;</span><br><span class="line">               new ArrayList&lt;&gt;(registeredBroadcastStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry :</span><br><span class="line">               registeredBroadcastStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">               broadcastMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... write them all in the checkpoint stream ...</span><br><span class="line">            &#x2F;&#x2F; 写入元数据</span><br><span class="line">            DataOutputView dov &#x3D; new DataOutputViewStreamWrapper(localOut);</span><br><span class="line"></span><br><span class="line">            OperatorBackendSerializationProxy backendSerializationProxy &#x3D;</span><br><span class="line">               new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots);</span><br><span class="line"></span><br><span class="line">            backendSerializationProxy.write(dov);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and then go for the states ...</span><br><span class="line">&#x2F;&#x2F; 写入状态</span><br><span class="line">            &#x2F;&#x2F; we put BOTH normal and broadcast state metadata here</span><br><span class="line">            int initialMapCapacity &#x3D;</span><br><span class="line">               registeredOperatorStatesDeepCopies.size() + registeredBroadcastStatesDeepCopies.size();</span><br><span class="line">            final Map&lt;String, OperatorStateHandle.StateMetaInfo&gt; writtenStatesMetaData &#x3D;</span><br><span class="line">               new HashMap&lt;&gt;(initialMapCapacity);</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry :</span><br><span class="line">               registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">               PartitionableListState&lt;?&gt; value &#x3D; entry.getValue();</span><br><span class="line">               long[] partitionOffsets &#x3D; value.write(localOut);</span><br><span class="line">               OperatorStateHandle.Mode mode &#x3D; value.getStateMetaInfo().getAssignmentMode();</span><br><span class="line">               writtenStatesMetaData.put(</span><br><span class="line">                  entry.getKey(),</span><br><span class="line">                  new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and the broadcast states themselves ...</span><br><span class="line">            for (Map.Entry&lt;String, BackendWritableBroadcastState&lt;?, ?&gt;&gt; entry :</span><br><span class="line">               registeredBroadcastStatesDeepCopies.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">               BackendWritableBroadcastState&lt;?, ?&gt; value &#x3D; entry.getValue();</span><br><span class="line">               long[] partitionOffsets &#x3D; &#123;value.write(localOut)&#125;;</span><br><span class="line">               OperatorStateHandle.Mode mode &#x3D; value.getStateMetaInfo().getAssignmentMode();</span><br><span class="line">               writtenStatesMetaData.put(</span><br><span class="line">                  entry.getKey(),</span><br><span class="line">                  new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ... and, finally, create the state handle.</span><br><span class="line">            OperatorStateHandle retValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">            if (snapshotCloseableRegistry.unregisterCloseable(localOut)) &#123;</span><br><span class="line">&#x2F;&#x2F;关闭输出流，获得状态句柄，后面可以用这个句柄读取状态</span><br><span class="line">               StreamStateHandle stateHandle &#x3D; localOut.closeAndGetHandle();</span><br><span class="line"></span><br><span class="line">               if (stateHandle !&#x3D; null) &#123;</span><br><span class="line">                  retValue &#x3D; new OperatorStreamStateHandle(writtenStatesMetaData, stateHandle);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               return SnapshotResult.of(retValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               throw new IOException(&quot;Stream was already unregistered.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected void cleanupProvidedResources() &#123;</span><br><span class="line">            &#x2F;&#x2F; nothing to do</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected void logAsyncSnapshotComplete(long startTime) &#123;</span><br><span class="line">            if (asynchronousSnapshots) &#123;</span><br><span class="line">               logAsyncCompleted(streamFactory, startTime);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">   final FutureTask&lt;SnapshotResult&lt;OperatorStateHandle&gt;&gt; task &#x3D;</span><br><span class="line">      snapshotCallable.toAsyncSnapshotFutureTask(closeStreamOnCancelRegistry);</span><br><span class="line">&#x2F;&#x2F;如果不是异步 checkpoint 那么在这里直接运行 FutureTask，即在同步阶段就完成了状态的写入</span><br><span class="line">   if (!asynchronousSnapshots) &#123;</span><br><span class="line">      task.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keyed state 写入的基本流程与此相似，但由于 keyed state 在存储时有多种实现，包括基于堆内存和 RocksDB 的不同实现，此外基于 RocksDB 的实现还包括支持<a href="https://flink.apache.org/features/2018/01/30/incremental-checkpointing.html" target="_blank" rel="noopener">增量 checkpoint</a>，因而相比于 operator state 要更复杂一些。另外，Flink 自 1.5.0 版本还引入了一个<a href="https://issues.apache.org/jira/browse/FLINK-8360" target="_blank" rel="noopener">本地状态存储</a>的优化，支持在 TaskManager 的本地保存一份 keyed state，试图优化状态恢复的速度和网络开销。</p>
<p>具体三种 StateBackend 即MemoryStateBackend、FsStateBackend、RocksDBStateBackend对应的 OperatorStateBackend 和 KeyedStateBackend 分别为：</p>
<p><img src="/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/1.png" alt></p>
<p>所谓本地状态存储，即在存储检查点快照时，在 <code>Task</code> 所在的 TaskManager 本地文件系统中存储一份副本，这样在进行状态恢复时可以优先从本地状态进行恢复，从而减少网络数据传输的开销。本地状态存储仅针对 keyed state，我们以较为简单的 <code>HeapKeyedStateBackend</code> 为例，看看本地状态存储时如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; snapshot(</span><br><span class="line">		long checkpointId,</span><br><span class="line">		long timestamp,</span><br><span class="line">		@Nonnull CheckpointStreamFactory primaryStreamFactory,</span><br><span class="line">		@Nonnull CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		if (!hasRegisteredState()) &#123;</span><br><span class="line">			return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int numStates &#x3D; registeredKVStates.size() + registeredPQStates.size();</span><br><span class="line"></span><br><span class="line">		Preconditions.checkState(numStates &lt;&#x3D; Short.MAX_VALUE,</span><br><span class="line">			&quot;Too many states: &quot; + numStates +</span><br><span class="line">				&quot;. Currently at most &quot; + Short.MAX_VALUE + &quot; states are supported&quot;);</span><br><span class="line"></span><br><span class="line">		final List&lt;StateMetaInfoSnapshot&gt; metaInfoSnapshots &#x3D; new ArrayList&lt;&gt;(numStates);</span><br><span class="line">		final Map&lt;StateUID, Integer&gt; stateNamesToId &#x3D;</span><br><span class="line">			new HashMap&lt;&gt;(numStates);</span><br><span class="line">		final Map&lt;StateUID, StateSnapshot&gt; cowStateStableSnapshots &#x3D;</span><br><span class="line">			new HashMap&lt;&gt;(numStates);</span><br><span class="line"></span><br><span class="line">		processSnapshotMetaInfoForAllStates(</span><br><span class="line">			metaInfoSnapshots,</span><br><span class="line">			cowStateStableSnapshots,</span><br><span class="line">			stateNamesToId,</span><br><span class="line">			registeredKVStates,</span><br><span class="line">			StateMetaInfoSnapshot.BackendStateType.KEY_VALUE);</span><br><span class="line"></span><br><span class="line">		processSnapshotMetaInfoForAllStates(</span><br><span class="line">			metaInfoSnapshots,</span><br><span class="line">			cowStateStableSnapshots,</span><br><span class="line">			stateNamesToId,</span><br><span class="line">			registeredPQStates,</span><br><span class="line">			StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE);</span><br><span class="line"></span><br><span class="line">		final KeyedBackendSerializationProxy&lt;K&gt; serializationProxy &#x3D;</span><br><span class="line">			new KeyedBackendSerializationProxy&lt;&gt;(</span><br><span class="line">				&#x2F;&#x2F; TODO: this code assumes that writing a serializer is threadsafe, we should support to</span><br><span class="line">				&#x2F;&#x2F; get a serialized form already at state registration time in the future</span><br><span class="line">				getKeySerializer(),</span><br><span class="line">				metaInfoSnapshots,</span><br><span class="line">				!Objects.equals(UncompressedStreamCompressionDecorator.INSTANCE, keyGroupCompressionDecorator));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 CheckpointStreamWithResultProvider</span><br><span class="line">		final SupplierWithException&lt;CheckpointStreamWithResultProvider, Exception&gt; checkpointStreamSupplier &#x3D;</span><br><span class="line">&#x2F;&#x2F;是否启用本地存储</span><br><span class="line">			localRecoveryConfig.isLocalRecoveryEnabled() ?</span><br><span class="line"></span><br><span class="line">				() -&gt; CheckpointStreamWithResultProvider.createDuplicatingStream(</span><br><span class="line">					checkpointId,</span><br><span class="line">					CheckpointedStateScope.EXCLUSIVE,</span><br><span class="line">					primaryStreamFactory,</span><br><span class="line">					localRecoveryConfig.getLocalStateDirectoryProvider()) :</span><br><span class="line"></span><br><span class="line">				() -&gt; CheckpointStreamWithResultProvider.createSimpleStream(</span><br><span class="line">					CheckpointedStateScope.EXCLUSIVE,</span><br><span class="line">					primaryStreamFactory);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;--------------------------------------------------- this becomes the end of sync part</span><br><span class="line"></span><br><span class="line">		final AsyncSnapshotCallable&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; asyncSnapshotCallable &#x3D;</span><br><span class="line">			new AsyncSnapshotCallable&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected SnapshotResult&lt;KeyedStateHandle&gt; callInternal() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">					final CheckpointStreamWithResultProvider streamWithResultProvider &#x3D;</span><br><span class="line">						checkpointStreamSupplier.get();</span><br><span class="line"></span><br><span class="line">					snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);</span><br><span class="line"></span><br><span class="line">					final CheckpointStreamFactory.CheckpointStateOutputStream localStream &#x3D;</span><br><span class="line">						streamWithResultProvider.getCheckpointOutputStream();</span><br><span class="line"></span><br><span class="line">					final DataOutputViewStreamWrapper outView &#x3D; new DataOutputViewStreamWrapper(localStream);</span><br><span class="line">					serializationProxy.write(outView);</span><br><span class="line"></span><br><span class="line">					final long[] keyGroupRangeOffsets &#x3D; new long[keyGroupRange.getNumberOfKeyGroups()];</span><br><span class="line"></span><br><span class="line">					for (int keyGroupPos &#x3D; 0; keyGroupPos &lt; keyGroupRange.getNumberOfKeyGroups(); ++keyGroupPos) &#123;</span><br><span class="line">						int keyGroupId &#x3D; keyGroupRange.getKeyGroupId(keyGroupPos);</span><br><span class="line">						keyGroupRangeOffsets[keyGroupPos] &#x3D; localStream.getPos();</span><br><span class="line">						outView.writeInt(keyGroupId);</span><br><span class="line"></span><br><span class="line">						for (Map.Entry&lt;StateUID, StateSnapshot&gt; stateSnapshot :</span><br><span class="line">							cowStateStableSnapshots.entrySet()) &#123;</span><br><span class="line">							StateSnapshot.StateKeyGroupWriter partitionedSnapshot &#x3D;</span><br><span class="line"></span><br><span class="line">								stateSnapshot.getValue().getKeyGroupWriter();</span><br><span class="line">							try (</span><br><span class="line">								OutputStream kgCompressionOut &#x3D;</span><br><span class="line">									keyGroupCompressionDecorator.decorateWithCompression(localStream)) &#123;</span><br><span class="line">								DataOutputViewStreamWrapper kgCompressionView &#x3D;</span><br><span class="line">									new DataOutputViewStreamWrapper(kgCompressionOut);</span><br><span class="line">								kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));</span><br><span class="line">								partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);</span><br><span class="line">							&#125; &#x2F;&#x2F; this will just close the outer compression stream</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) &#123;</span><br><span class="line">						KeyGroupRangeOffsets kgOffs &#x3D; new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);</span><br><span class="line">						SnapshotResult&lt;StreamStateHandle&gt; result &#x3D;</span><br><span class="line">							streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();</span><br><span class="line">						return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(result, kgOffs);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						throw new IOException(&quot;Stream already unregistered.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				protected void cleanupProvidedResources() &#123;</span><br><span class="line">					for (StateSnapshot tableSnapshot : cowStateStableSnapshots.values()) &#123;</span><br><span class="line">						tableSnapshot.release();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				protected void logAsyncSnapshotComplete(long startTime) &#123;</span><br><span class="line">					if (snapshotStrategySynchronicityTrait.isAsynchronous()) &#123;</span><br><span class="line">						logAsyncCompleted(primaryStreamFactory, startTime);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">		final FutureTask&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; task &#x3D;</span><br><span class="line">			asyncSnapshotCallable.toAsyncSnapshotFutureTask(cancelStreamRegistry);</span><br><span class="line">		finalizeSnapshotBeforeReturnHook(task);</span><br><span class="line"></span><br><span class="line">		return task;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>所以在启用本地状态存储的情况下，会创建两个输出流，其中 <code>primaryOut</code> 对应外部存储，而 <code>secondaryOut</code> 对应本地存储。状态会输出两份。本地状态句柄会存储在 <code>TaskLocalStateStore</code> 中。</p>
<p>CheckpointStreamWithResultProvider：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static CheckpointStreamWithResultProvider createDuplicatingStream(</span><br><span class="line">   @Nonnegative long checkpointId,</span><br><span class="line">   @Nonnull CheckpointedStateScope checkpointedStateScope,</span><br><span class="line">   @Nonnull CheckpointStreamFactory primaryStreamFactory,</span><br><span class="line">   @Nonnull LocalRecoveryDirectoryProvider secondaryStreamDirProvider) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   CheckpointStreamFactory.CheckpointStateOutputStream primaryOut &#x3D;</span><br><span class="line">      primaryStreamFactory.createCheckpointStateOutputStream(checkpointedStateScope);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      File outFile &#x3D; new File(</span><br><span class="line">         secondaryStreamDirProvider.subtaskSpecificCheckpointDirectory(checkpointId),</span><br><span class="line">         String.valueOf(UUID.randomUUID()));</span><br><span class="line">      Path outPath &#x3D; new Path(outFile.toURI());</span><br><span class="line"></span><br><span class="line">      CheckpointStreamFactory.CheckpointStateOutputStream secondaryOut &#x3D;</span><br><span class="line">         new FileBasedStateOutputStream(outPath.getFileSystem(), outPath);</span><br><span class="line">&#x2F;&#x2F;有两个输出流，primary 和 secondary，secondary 对应本地存储</span><br><span class="line">      return new CheckpointStreamWithResultProvider.PrimaryAndSecondaryStream(primaryOut, secondaryOut);</span><br><span class="line">   &#125; catch (IOException secondaryEx) &#123;</span><br><span class="line">      LOG.warn(&quot;Exception when opening secondary&#x2F;local checkpoint output stream. &quot; +</span><br><span class="line">         &quot;Continue only with the primary stream.&quot;, secondaryEx);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return new CheckpointStreamWithResultProvider.PrimaryStreamOnly(primaryOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而RocksDBSnapshotStrategyBase的doSnapshot分为两种实现情况，RocksIncrementalSnapshotStrategy和RocksFullSnapshotStrategy分别对应增量和全量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; snapshot(</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long timestamp,</span><br><span class="line">      @Nonnull CheckpointStreamFactory streamFactory,</span><br><span class="line">      @Nonnull CheckpointOptions checkpointOptions) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">      if (kvStateInformation.isEmpty()) &#123;</span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;Asynchronous RocksDB snapshot performed on empty keyed state at &#123;&#125;. Returning null.&quot;,</span><br><span class="line">               timestamp);</span><br><span class="line">         &#125;</span><br><span class="line">         return DoneFuture.of(SnapshotResult.empty());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         return doSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method implements the concrete snapshot logic for a non-empty state.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   protected abstract RunnableFuture&lt;SnapshotResult&lt;KeyedStateHandle&gt;&gt; doSnapshot(</span><br><span class="line">      long checkpointId,</span><br><span class="line">      long timestamp,</span><br><span class="line">      CheckpointStreamFactory streamFactory,</span><br><span class="line">      CheckpointOptions checkpointOptions) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们介绍了快照操作的第一个阶段，即同步执行的阶段。异步执行阶段被封装为 <code>AsyncCheckpointRunnable</code>，主要的操作包括 1）执行同步阶段创建的 FutureTask 2）完成后向 CheckpointCoordinator 发送 Ack 响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">protected static final class AsyncCheckpointRunnable implements Runnable, Closeable &#123;</span><br><span class="line"></span><br><span class="line">   private final StreamTask&lt;?, ?&gt; owner;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;OperatorID, OperatorSnapshotFutures&gt; operatorSnapshotsInProgress;</span><br><span class="line"></span><br><span class="line">   private final CheckpointMetaData checkpointMetaData;</span><br><span class="line">   private final CheckpointMetrics checkpointMetrics;</span><br><span class="line"></span><br><span class="line">   private final long asyncStartNanos;</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;CheckpointingOperation.AsyncCheckpointState&gt; asyncCheckpointState &#x3D; new AtomicReference&lt;&gt;(</span><br><span class="line">      CheckpointingOperation.AsyncCheckpointState.RUNNING);</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">         TaskStateSnapshot jobManagerTaskOperatorSubtaskStates &#x3D;</span><br><span class="line">            new TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line"></span><br><span class="line">         TaskStateSnapshot localTaskOperatorSubtaskStates &#x3D;</span><br><span class="line">            new TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 完成每一个 operator 的状态写入</span><br><span class="line">				&#x2F;&#x2F; 如果是同步 checkpoint，那么在此之前状态已经写入完成</span><br><span class="line">				&#x2F;&#x2F; 如果是异步 checkpoint，那么在这里才会写入状态</span><br><span class="line">         for (Map.Entry&lt;OperatorID, OperatorSnapshotFutures&gt; entry : operatorSnapshotsInProgress.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            OperatorID operatorID &#x3D; entry.getKey();</span><br><span class="line">            OperatorSnapshotFutures snapshotInProgress &#x3D; entry.getValue();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; finalize the async part of all by executing all snapshot runnables</span><br><span class="line">            OperatorSnapshotFinalizer finalizedSnapshots &#x3D;</span><br><span class="line">               new OperatorSnapshotFinalizer(snapshotInProgress);</span><br><span class="line"></span><br><span class="line">            jobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">               operatorID,</span><br><span class="line">               finalizedSnapshots.getJobManagerOwnedState());</span><br><span class="line"></span><br><span class="line">            localTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">               operatorID,</span><br><span class="line">               finalizedSnapshots.getTaskLocalState());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         final long asyncEndNanos &#x3D; System.nanoTime();</span><br><span class="line">         final long asyncDurationMillis &#x3D; (asyncEndNanos - asyncStartNanos) &#x2F; 1_000_000L;</span><br><span class="line"></span><br><span class="line">         checkpointMetrics.setAsyncDurationMillis(asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">         if (asyncCheckpointState.compareAndSet(CheckpointingOperation.AsyncCheckpointState.RUNNING,</span><br><span class="line">            CheckpointingOperation.AsyncCheckpointState.COMPLETED)) &#123;</span><br><span class="line">&#x2F;&#x2F;报告 snapshot 完成</span><br><span class="line">            reportCompletedSnapshotStates(</span><br><span class="line">               jobManagerTaskOperatorSubtaskStates,</span><br><span class="line">               localTaskOperatorSubtaskStates,</span><br><span class="line">               asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - asynchronous part of checkpoint &#123;&#125; could not be completed because it was closed before.&quot;,</span><br><span class="line">               owner.getName(),</span><br><span class="line">               checkpointMetaData.getCheckpointId());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">            LOG.debug(&quot;&#123;&#125; - asynchronous part of checkpoint &#123;&#125; could not be completed.&quot;,</span><br><span class="line">               owner.getName(),</span><br><span class="line">               checkpointMetaData.getCheckpointId(),</span><br><span class="line">               e);</span><br><span class="line">         &#125;</span><br><span class="line">         handleExecutionException(e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         owner.cancelables.unregisterCloseable(this);</span><br><span class="line">         FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">private void reportCompletedSnapshotStates(</span><br><span class="line">			TaskStateSnapshot acknowledgedTaskStateSnapshot,</span><br><span class="line">			TaskStateSnapshot localTaskStateSnapshot,</span><br><span class="line">			long asyncDurationMillis) &#123;</span><br><span class="line"></span><br><span class="line">			TaskStateManager taskStateManager &#x3D; owner.getEnvironment().getTaskStateManager();</span><br><span class="line"></span><br><span class="line">			boolean hasAckState &#x3D; acknowledgedTaskStateSnapshot.hasState();</span><br><span class="line">			boolean hasLocalState &#x3D; localTaskStateSnapshot.hasState();</span><br><span class="line"></span><br><span class="line">			Preconditions.checkState(hasAckState || !hasLocalState,</span><br><span class="line">				&quot;Found cached state but no corresponding primary state is reported to the job &quot; +</span><br><span class="line">					&quot;manager. This indicates a problem.&quot;);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; we signal stateless tasks by reporting null, so that there are no attempts to assign empty state</span><br><span class="line">			&#x2F;&#x2F; to stateless tasks on restore. This enables simple job modifications that only concern</span><br><span class="line">			&#x2F;&#x2F; stateless without the need to assign them uids to match their (always empty) states.</span><br><span class="line">			taskStateManager.reportTaskStateSnapshots(</span><br><span class="line">				checkpointMetaData,</span><br><span class="line">				checkpointMetrics,</span><br><span class="line">				hasAckState ? acknowledgedTaskStateSnapshot : null,</span><br><span class="line">				hasLocalState ? localTaskStateSnapshot : null);</span><br><span class="line"></span><br><span class="line">			LOG.debug(&quot;&#123;&#125; - finished asynchronous part of checkpoint &#123;&#125;. Asynchronous duration: &#123;&#125; ms&quot;,</span><br><span class="line">				owner.getName(), checkpointMetaData.getCheckpointId(), asyncDurationMillis);</span><br><span class="line"></span><br><span class="line">			LOG.trace(&quot;&#123;&#125; - reported the following states in snapshot for checkpoint &#123;&#125;: &#123;&#125;.&quot;,</span><br><span class="line">				owner.getName(), checkpointMetaData.getCheckpointId(), acknowledgedTaskStateSnapshot);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		TaskStateManager：</span><br><span class="line">public void reportTaskStateSnapshots(</span><br><span class="line">		@Nonnull CheckpointMetaData checkpointMetaData,</span><br><span class="line">		@Nonnull CheckpointMetrics checkpointMetrics,</span><br><span class="line">		@Nullable TaskStateSnapshot acknowledgedState,</span><br><span class="line">		@Nullable TaskStateSnapshot localState) &#123;</span><br><span class="line"></span><br><span class="line">		long checkpointId &#x3D; checkpointMetaData.getCheckpointId();</span><br><span class="line"></span><br><span class="line">		localStateStore.storeLocalState(checkpointId, localState);</span><br><span class="line">&#x2F;&#x2F;发送 ACK 响应给 CheckpointCoordinator</span><br><span class="line">		checkpointResponder.acknowledgeCheckpoint(</span><br><span class="line">			jobId,</span><br><span class="line">			executionAttemptID,</span><br><span class="line">			checkpointId,</span><br><span class="line">			checkpointMetrics,</span><br><span class="line">			acknowledgedState);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进行Checkpoint 的确认，<code>Task</code> 对 checkpoint 的响应是通过 <code>CheckpointResponder</code> 接口完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void acknowledgeCheckpoint(</span><br><span class="line">   JobID jobID,</span><br><span class="line">   ExecutionAttemptID executionAttemptID,</span><br><span class="line">   long checkpointId,</span><br><span class="line">   CheckpointMetrics checkpointMetrics,</span><br><span class="line">   TaskStateSnapshot subtaskState);</span><br></pre></td></tr></table></figure>

<p><code>RpcCheckpointResponder</code> 作为 <code>CheckpointResponder</code> 的具体实现，主要是通过 RPC 调用通知 <code>CheckpointCoordinatorGateway</code>，即通知给 <code>JobMaster</code>, <code>JobMaster</code> 调用 <code>CheckpointCoordinator.receiveAcknowledgeMessage()</code> 和 <code>CheckpointCoordinator.receiveDeclineMessage()</code> 进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(</span><br><span class="line">      JobID jobID,</span><br><span class="line">      ExecutionAttemptID executionAttemptID,</span><br><span class="line">      long checkpointId,</span><br><span class="line">      CheckpointMetrics checkpointMetrics,</span><br><span class="line">      TaskStateSnapshot subtaskState) &#123;</span><br><span class="line"></span><br><span class="line">   checkpointCoordinatorGateway.acknowledgeCheckpoint(</span><br><span class="line">      jobID,</span><br><span class="line">      executionAttemptID,</span><br><span class="line">      checkpointId,</span><br><span class="line">      checkpointMetrics,</span><br><span class="line">      subtaskState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobMaster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(</span><br><span class="line">      final JobID jobID,</span><br><span class="line">      final ExecutionAttemptID executionAttemptID,</span><br><span class="line">      final long checkpointId,</span><br><span class="line">      final CheckpointMetrics checkpointMetrics,</span><br><span class="line">      final TaskStateSnapshot checkpointState) &#123;</span><br><span class="line"></span><br><span class="line">   schedulerNG.acknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SchedulerBase实现SchedulerNG接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void acknowledgeCheckpoint(final JobID jobID, final ExecutionAttemptID executionAttemptID, final long checkpointId, final CheckpointMetrics checkpointMetrics, final TaskStateSnapshot checkpointState) &#123;</span><br><span class="line">   mainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取CheckpointCoordinator</span><br><span class="line">   final CheckpointCoordinator checkpointCoordinator &#x3D; executionGraph.getCheckpointCoordinator();</span><br><span class="line">   &#x2F;&#x2F;Checkpoint的确定Message</span><br><span class="line">   final AcknowledgeCheckpoint ackMessage &#x3D; new AcknowledgeCheckpoint(</span><br><span class="line">      jobID,</span><br><span class="line">      executionAttemptID,</span><br><span class="line">      checkpointId,</span><br><span class="line">      checkpointMetrics,</span><br><span class="line">      checkpointState);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取发送checkpoint完成信息的TaskManager的Location</span><br><span class="line">   final String taskManagerLocationInfo &#x3D; retrieveTaskManagerLocation(executionAttemptID);</span><br><span class="line"></span><br><span class="line">   if (checkpointCoordinator !&#x3D; null) &#123;</span><br><span class="line">      ioExecutor.execute(() -&gt; &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            checkpointCoordinator.receiveAcknowledgeMessage(ackMessage, taskManagerLocationInfo);</span><br><span class="line">         &#125; catch (Throwable t) &#123;</span><br><span class="line">            log.warn(&quot;Error while processing checkpoint acknowledgement message&quot;, t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      String errorMessage &#x3D; &quot;Received AcknowledgeCheckpoint message for job &#123;&#125; with no CheckpointCoordinator&quot;;</span><br><span class="line">      if (executionGraph.getState() &#x3D;&#x3D; JobStatus.RUNNING) &#123;</span><br><span class="line">         log.error(errorMessage, jobGraph.getJobID());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         log.debug(errorMessage, jobGraph.getJobID());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator的receiveAcknowledgeMessage接收来自Task的确认消息</p>
<p>在一个 <code>Task</code> 完成 checkpoint 操作后，<code>CheckpointCoordinator</code> 接收到 Ack 响应，对 Ack 响应的处理流程主要如下：</p>
<ul>
<li><p>根据 Ack 的 checkpointID 从 <code>Map pendingCheckpoints</code> 中查找对应的 <code>PendingCheckpoint</code></p>
</li>
<li><p>若存在对应的</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>

<ul>
<li>这个</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>



没有被丢弃，调用



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint.acknowledgeTask</span><br></pre></td></tr></table></figure>



方法处理 Ack，根据处理结果的不同：

- SUCCESS：判断是否已经接受了所有需要响应的 Ack，如果是，则调用 `completePendingCheckpoint` 完成此次 checkpoint
- DUPLICATE：Ack 消息重复接收，直接忽略
- UNKNOWN：未知的 Ack 消息，清理上报的 Ack 中携带的状态句柄
- DISCARD：Checkpoint 已经被 discard，清理上报的 Ack 中携带的状态句柄</code></pre><ul>
<li>这个 <code>PendingCheckpoint</code> 已经被丢弃，抛出异常</li>
</ul>
<ul>
<li>若不存在对应的 <code>PendingCheckpoint</code>，则清理上报的 Ack 中携带的状态句柄</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message, String taskManagerLocationInfo) throws CheckpointException &#123;</span><br><span class="line">   if (shutdown || message &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!job.equals(message.getJob())) &#123;</span><br><span class="line">      LOG.error(&quot;Received wrong AcknowledgeCheckpoint message for job &#123;&#125; from &#123;&#125; : &#123;&#125;&quot;, job, taskManagerLocationInfo, message);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long checkpointId &#x3D; message.getCheckpointId();</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      &#x2F;&#x2F; we need to check inside the lock for being shutdown as well, otherwise we</span><br><span class="line">      &#x2F;&#x2F; get races and invalid error log messages</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final PendingCheckpoint checkpoint &#x3D; pendingCheckpoints.get(checkpointId);</span><br><span class="line"></span><br><span class="line">      if (checkpoint !&#x3D; null &amp;&amp; !checkpoint.isDiscarded()) &#123;</span><br><span class="line"></span><br><span class="line">         switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) &#123;</span><br><span class="line">            case SUCCESS:</span><br><span class="line">               LOG.debug(&quot;Received acknowledge message for checkpoint &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               if (checkpoint.areTasksFullyAcknowledged()) &#123;</span><br><span class="line">                  completePendingCheckpoint(checkpoint);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">            case DUPLICATE:</span><br><span class="line">               LOG.debug(&quot;Received a duplicate acknowledge message for checkpoint &#123;&#125;, task &#123;&#125;, job &#123;&#125;, location &#123;&#125;.&quot;,</span><br><span class="line">                  message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">               break;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">               LOG.warn(&quot;Could not acknowledge the checkpoint &#123;&#125; for task &#123;&#125; of job &#123;&#125; at &#123;&#125;, &quot; +</span><br><span class="line">                     &quot;because the task&#39;s execution attempt id was unknown. Discarding &quot; +</span><br><span class="line">                     &quot;the state handle to avoid lingering state.&quot;, message.getCheckpointId(),</span><br><span class="line">                  message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line"></span><br><span class="line">               break;</span><br><span class="line">            case DISCARDED:</span><br><span class="line">               LOG.warn(&quot;Could not acknowledge the checkpoint &#123;&#125; for task &#123;&#125; of job &#123;&#125; at &#123;&#125;, &quot; +</span><br><span class="line">                  &quot;because the pending checkpoint had been discarded. Discarding the &quot; +</span><br><span class="line">                     &quot;state handle tp avoid lingering state.&quot;,</span><br><span class="line">                  message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line"></span><br><span class="line">               discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (checkpoint !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; this should not happen</span><br><span class="line">         throw new IllegalStateException(</span><br><span class="line">               &quot;Received message for discarded but non-removed checkpoint &quot; + checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         boolean wasPendingCheckpoint;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; message is for an unknown checkpoint, or comes too late (checkpoint disposed)</span><br><span class="line">         if (recentPendingCheckpoints.contains(checkpointId)) &#123;</span><br><span class="line">            wasPendingCheckpoint &#x3D; true;</span><br><span class="line">            LOG.warn(&quot;Received late message for now expired checkpoint attempt &#123;&#125; from task &quot; +</span><br><span class="line">               &quot;&#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;, checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            LOG.debug(&quot;Received message for an unknown checkpoint &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">               checkpointId, message.getTaskExecutionId(), message.getJob(), taskManagerLocationInfo);</span><br><span class="line">            wasPendingCheckpoint &#x3D; false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; try to discard the state so that we don&#39;t have lingering state lying around</span><br><span class="line">         discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());</span><br><span class="line"></span><br><span class="line">         return wasPendingCheckpoint;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>一旦 <code>PendingCheckpoint</code> 确认所有 Ack 消息都已经接收，那么就可以完成此次 checkpoint 了，具体包括：</p>
<ul>
<li><p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint.finalizeCheckpoint()</span><br></pre></td></tr></table></figure>

<p>将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingCheckpoint</span><br></pre></td></tr></table></figure>

<p>转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpoint</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 <code>CheckpointMetadataOutputStream</code>，将所有的状态句柄信息通过 <code>CheckpointMetadataOutputStream</code> 写入到存储系统中</li>
<li>创建一个 <code>CompletedCheckpoint</code> 对象</li>
</ul>
</li>
<li><p>将</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpoint</span><br></pre></td></tr></table></figure>



<p>  保存到</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletedCheckpointStore</span><br></pre></td></tr></table></figure>



<p>  中</p>
<ul>
<li><code>CompletedCheckpointStore</code> 有两种实现，分别为 <code>StandaloneCompletedCheckpointStore</code> 和 <code>ZooKeeperCompletedCheckpointStore</code></li>
<li><code>StandaloneCompletedCheckpointStore</code> 简单地将 <code>CompletedCheckpointStore</code> 存放在一个数组中</li>
<li><code>ZooKeeperCompletedCheckpointStore</code> 提供高可用实现：先将 <code>CompletedCheckpointStore</code> 写入到 <code>RetrievableStateStorageHelper</code> 中（通常是文件系统），然后将文件句柄存在 ZK 中</li>
<li>保存的 <code>CompletedCheckpointStore</code> 数量是有限的，会删除旧的快照</li>
</ul>
<ul>
<li><p>移除被越过的 <code>PendingCheckpoint</code>，因为 <code>CheckpointID</code> 是递增的，那么所有比当前完成的 <code>CheckpointID</code> 小的 <code>PendingCheckpoint</code> 都可以被丢弃了</p>
</li>
<li><p>依次调用</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution.notifyCheckpointComplete()</span><br></pre></td></tr></table></figure>



<p>  通知所有的 Task 当前 Checkpoint 已经完成</p>
<ul>
<li>通过 RPC 调用 <code>TaskExecutor.confirmCheckpoint()</code> 告知对应的 Task</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException &#123;</span><br><span class="line">   final long checkpointId &#x3D; pendingCheckpoint.getCheckpointId();</span><br><span class="line">   final CompletedCheckpoint completedCheckpoint;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; As a first step to complete the checkpoint, we register its state with the registry</span><br><span class="line">   Map&lt;OperatorID, OperatorState&gt; operatorStates &#x3D; pendingCheckpoint.getOperatorStates();</span><br><span class="line">   sharedStateRegistry.registerAll(operatorStates.values());</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         completedCheckpoint &#x3D; pendingCheckpoint.finalizeCheckpoint();</span><br><span class="line">         failureManager.handleCheckpointSuccess(pendingCheckpoint.getCheckpointId());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e1) &#123;</span><br><span class="line">         &#x2F;&#x2F; abort the current pending checkpoint if we fails to finalize the pending checkpoint.</span><br><span class="line">         if (!pendingCheckpoint.isDiscarded()) &#123;</span><br><span class="line">            failPendingCheckpoint(pendingCheckpoint, CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         throw new CheckpointException(&quot;Could not finalize the pending checkpoint &quot; + checkpointId + &#39;.&#39;,</span><br><span class="line">            CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; the pending checkpoint must be discarded after the finalization</span><br><span class="line">      Preconditions.checkState(pendingCheckpoint.isDiscarded() &amp;&amp; completedCheckpoint !&#x3D; null);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         completedCheckpointStore.addCheckpoint(completedCheckpoint);</span><br><span class="line">      &#125; catch (Exception exception) &#123;</span><br><span class="line">         &#x2F;&#x2F; we failed to store the completed checkpoint. Let&#39;s clean up</span><br><span class="line">         executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                  completedCheckpoint.discardOnFailedStoring();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                  LOG.warn(&quot;Could not properly discard completed checkpoint &#123;&#125;.&quot;, completedCheckpoint.getCheckpointID(), t);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         throw new CheckpointException(&quot;Could not complete the pending checkpoint &quot; + checkpointId + &#39;.&#39;,</span><br><span class="line">            CheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, exception);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      pendingCheckpoints.remove(checkpointId);</span><br><span class="line"></span><br><span class="line">      triggerQueuedRequests();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rememberRecentCheckpointId(checkpointId);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; drop those pending checkpoints that are at prior to the completed one</span><br><span class="line">   dropSubsumedCheckpoints(checkpointId);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; record the time when this was completed, to calculate</span><br><span class="line">   &#x2F;&#x2F; the &#39;min delay between checkpoints&#39;</span><br><span class="line">   lastCheckpointCompletionRelativeTime &#x3D; clock.relativeTimeMillis();</span><br><span class="line"></span><br><span class="line">   LOG.info(&quot;Completed checkpoint &#123;&#125; for job &#123;&#125; (&#123;&#125; bytes in &#123;&#125; ms).&quot;, checkpointId, job,</span><br><span class="line">      completedCheckpoint.getStateSize(), completedCheckpoint.getDuration());</span><br><span class="line"></span><br><span class="line">   if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">      builder.append(&quot;Checkpoint state: &quot;);</span><br><span class="line">      for (OperatorState state : completedCheckpoint.getOperatorStates().values()) &#123;</span><br><span class="line">         builder.append(state);</span><br><span class="line">         builder.append(&quot;, &quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Remove last two chars &quot;, &quot;</span><br><span class="line">      builder.setLength(builder.length() - 2);</span><br><span class="line"></span><br><span class="line">      LOG.debug(builder.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; send the &quot;notify complete&quot; call to all vertices</span><br><span class="line">   final long timestamp &#x3D; completedCheckpoint.getTimestamp();</span><br><span class="line"></span><br><span class="line">   for (ExecutionVertex ev : tasksToCommitTo) &#123;</span><br><span class="line">      Execution ee &#x3D; ev.getCurrentExecutionAttempt();</span><br><span class="line">      if (ee !&#x3D; null) &#123;</span><br><span class="line">         ee.notifyCheckpointComplete(checkpointId, timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个已经触发但还没有完成的 checkpoint，即 <code>PendingCheckpoint</code>，它是如何处理 Ack 消息的呢？在 <code>PendingCheckpoint</code> 内部维护了两个 Map，分别是：</p>
<ul>
<li><code>Map operatorStates;</code> : 已经接收到 Ack 的算子的状态句柄</li>
<li><code>Map notYetAcknowledgedTasks;</code>: 需要 Ack 但还没有接收到的 Task</li>
</ul>
<p>每当接收到一个 Ack 消息时，<code>PendingCheckpoint</code> 就从 <code>notYetAcknowledgedTasks</code> 中移除对应的 Task，并保存 Ack 携带的状态句柄保存。当 <code>notYetAcknowledgedTasks</code> 为空时，表明所有的 Ack 消息都接收到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PendingCheckpoint &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Result of the &#123;@link PendingCheckpoint#acknowledgedTasks&#125; method.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public enum TaskAcknowledgeResult &#123;</span><br><span class="line">      SUCCESS, &#x2F;&#x2F; successful acknowledge of the task</span><br><span class="line">      DUPLICATE, &#x2F;&#x2F; acknowledge message is a duplicate</span><br><span class="line">      UNKNOWN, &#x2F;&#x2F; unknown task acknowledged</span><br><span class="line">      DISCARDED &#x2F;&#x2F; pending checkpoint has been discarded</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** The PendingCheckpoint logs to the same logger as the CheckpointCoordinator. *&#x2F;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(CheckpointCoordinator.class);</span><br><span class="line"></span><br><span class="line">   private final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">   private final JobID jobId;</span><br><span class="line"></span><br><span class="line">   private final long checkpointId;</span><br><span class="line"></span><br><span class="line">   private final long checkpointTimestamp;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;OperatorID, OperatorState&gt; operatorStates;</span><br><span class="line"></span><br><span class="line">   private final Map&lt;ExecutionAttemptID, ExecutionVertex&gt; notYetAcknowledgedTasks;</span><br><span class="line"></span><br><span class="line">   private final List&lt;MasterState&gt; masterStates;</span><br><span class="line"></span><br><span class="line">   private final Set&lt;String&gt; notYetAcknowledgedMasterStates;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Set of acknowledged tasks. *&#x2F;</span><br><span class="line">   private final Set&lt;ExecutionAttemptID&gt; acknowledgedTasks;</span><br></pre></td></tr></table></figure>

<p>其中 <code>OperatorState</code> 是算子状态句柄的一层封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorState implements CompositeStateHandle &#123;</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; -4845578005863201810L;</span><br><span class="line"></span><br><span class="line">   &#x2F;** id of the operator *&#x2F;</span><br><span class="line">   private final OperatorID operatorID;</span><br><span class="line"></span><br><span class="line">   &#x2F;** handles to non-partitioned states, subtaskindex -&gt; subtaskstate *&#x2F;</span><br><span class="line">   private final Map&lt;Integer, OperatorSubtaskState&gt; operatorSubtaskStates;</span><br><span class="line"></span><br><span class="line">   &#x2F;** parallelism of the operator when it was checkpointed *&#x2F;</span><br><span class="line">   private final int parallelism;</span><br><span class="line"></span><br><span class="line">   &#x2F;** maximum parallelism of the operator when the job was first created *&#x2F;</span><br><span class="line">   private final int maxParallelism;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorSubtaskState implements CompositeStateHandle &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(OperatorSubtaskState.class);</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; -2394696997971923995L;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot from the &#123;@link org.apache.flink.runtime.state.OperatorStateBackend&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;OperatorStateHandle&gt; managedOperatorState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot written using &#123;@link org.apache.flink.runtime.state.OperatorStateCheckpointOutputStream&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;OperatorStateHandle&gt; rawOperatorState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot from &#123;@link org.apache.flink.runtime.state.KeyedStateBackend&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;KeyedStateHandle&gt; managedKeyedState;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Snapshot written using &#123;@link org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream&#125;.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final StateObjectCollection&lt;KeyedStateHandle&gt; rawKeyedState;</span><br></pre></td></tr></table></figure>

<p>在 Task 进行 checkpoint 的过程，可能会发生异常导致 checkpoint 失败，在这种情况下会通过 <code>CheckpointResponder</code> 发出回绝的消息。当 <code>CheckpointCoordinator</code> 接收到 <code>DeclineCheckpoint</code> 消息后会移除 <code>PendingCheckpoint</code>，并尝试丢弃已经接收到的 Ack 消息中已完成的状态句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void receiveDeclineMessage(DeclineCheckpoint message, String taskManagerLocationInfo) &#123;</span><br><span class="line">   if (shutdown || message &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!job.equals(message.getJob())) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Received DeclineCheckpoint message for job &quot; +</span><br><span class="line">         message.getJob() + &quot; from &quot; + taskManagerLocationInfo + &quot; while this coordinator handles job &quot; + job);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long checkpointId &#x3D; message.getCheckpointId();</span><br><span class="line">   final String reason &#x3D; (message.getReason() !&#x3D; null ? message.getReason().getMessage() : &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   PendingCheckpoint checkpoint;</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      &#x2F;&#x2F; we need to check inside the lock for being shutdown as well, otherwise we</span><br><span class="line">      &#x2F;&#x2F; get races and invalid error log messages</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      checkpoint &#x3D; pendingCheckpoints.remove(checkpointId);</span><br><span class="line"></span><br><span class="line">      if (checkpoint !&#x3D; null &amp;&amp; !checkpoint.isDiscarded()) &#123;</span><br><span class="line">         LOG.info(&quot;Decline checkpoint &#123;&#125; by task &#123;&#125; of job &#123;&#125; at &#123;&#125;.&quot;,</span><br><span class="line">            checkpointId,</span><br><span class="line">            message.getTaskExecutionId(),</span><br><span class="line">            job,</span><br><span class="line">            taskManagerLocationInfo);</span><br><span class="line">         discardCheckpoint(checkpoint, message.getReason(), message.getTaskExecutionId());</span><br><span class="line">      &#125;</span><br><span class="line">      else if (checkpoint !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; this should not happen</span><br><span class="line">         throw new IllegalStateException(</span><br><span class="line">               &quot;Received message for discarded but non-removed checkpoint &quot; + checkpointId);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">         if (recentPendingCheckpoints.contains(checkpointId)) &#123;</span><br><span class="line">            &#x2F;&#x2F; message is for an unknown checkpoint, or comes too late (checkpoint disposed)</span><br><span class="line">            LOG.debug(&quot;Received another decline message for now expired checkpoint attempt &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125; : &#123;&#125;&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), job, taskManagerLocationInfo, reason);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; message is for an unknown checkpoint. might be so old that we don&#39;t even remember it any more</span><br><span class="line">            LOG.debug(&quot;Received decline message for unknown (too old?) checkpoint attempt &#123;&#125; from task &#123;&#125; of job &#123;&#125; at &#123;&#125; : &#123;&#125;&quot;,</span><br><span class="line">                  checkpointId, message.getTaskExecutionId(), job, taskManagerLocationInfo, reason);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Flink 作业失败重启或者从指定 SavePoint 启动时，需要将整个作业恢复到上一次成功 checkpoint 的状态。这里主要分为两个阶段：</p>
<ul>
<li><code>CheckpointCoordinator</code> 加载最近一次成功的 <code>CompletedCheckpoint</code>，并将状态重新分配到不同的 <code>Execution</code>（<code>Task</code>）中</li>
<li><code>Task</code> 启动时进行状态初始化</li>
</ul>
<p>首先，<code>JobMaster</code> 在创建 <code>ExecutionGraph</code> 后会尝试恢复状态到最近一次成功的 checkpoint，或者加载 SavePoint，最终都会调用 <code>CheckpointCoordinator.restoreLatestCheckpointedState()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">JobMaster:</span><br><span class="line">private SchedulerNG createScheduler(final JobManagerJobMetricGroup jobManagerJobMetricGroup) throws Exception &#123;</span><br><span class="line">   return schedulerNGFactory.createInstance(</span><br><span class="line">      log,</span><br><span class="line">      jobGraph,</span><br><span class="line">      backPressureStatsTracker,</span><br><span class="line">      scheduledExecutorService,</span><br><span class="line">      jobMasterConfiguration.getConfiguration(),</span><br><span class="line">      scheduler,</span><br><span class="line">      scheduledExecutorService,</span><br><span class="line">      userCodeLoader,</span><br><span class="line">      highAvailabilityServices.getCheckpointRecoveryFactory(),</span><br><span class="line">      rpcTimeout,</span><br><span class="line">      blobWriter,</span><br><span class="line">      jobManagerJobMetricGroup,</span><br><span class="line">      jobMasterConfiguration.getSlotRequestTimeout(),</span><br><span class="line">      shuffleMaster,</span><br><span class="line">      partitionTracker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SchedulerBase:</span><br><span class="line">private ExecutionGraph createAndRestoreExecutionGraph(</span><br><span class="line">		JobManagerJobMetricGroup currentJobManagerJobMetricGroup,</span><br><span class="line">		ShuffleMaster&lt;?&gt; shuffleMaster,</span><br><span class="line">		JobMasterPartitionTracker partitionTracker) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		ExecutionGraph newExecutionGraph &#x3D; createExecutionGraph(currentJobManagerJobMetricGroup, shuffleMaster, partitionTracker);</span><br><span class="line"></span><br><span class="line">		final CheckpointCoordinator checkpointCoordinator &#x3D; newExecutionGraph.getCheckpointCoordinator();</span><br><span class="line"></span><br><span class="line">		if (checkpointCoordinator !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F; check whether we find a valid checkpoint</span><br><span class="line">			if (!checkpointCoordinator.restoreLatestCheckpointedState(</span><br><span class="line">				new HashSet&lt;&gt;(newExecutionGraph.getAllVertices().values()),</span><br><span class="line">				false,</span><br><span class="line">				false)) &#123;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; check whether we can restore from a savepoint</span><br><span class="line">				tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return newExecutionGraph;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointCoordinator.restoreLatestCheckpointedState()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public boolean restoreLatestCheckpointedState(</span><br><span class="line">      final Set&lt;ExecutionJobVertex&gt; tasks,</span><br><span class="line">      final boolean errorIfNoCheckpoint,</span><br><span class="line">      final boolean allowNonRestoredState) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   synchronized (lock) &#123;</span><br><span class="line">      if (shutdown) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;CheckpointCoordinator is shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; We create a new shared state registry object, so that all pending async disposal requests from previous</span><br><span class="line">      &#x2F;&#x2F; runs will go against the old object (were they can do no harm).</span><br><span class="line">      &#x2F;&#x2F; This must happen under the checkpoint lock.</span><br><span class="line">      sharedStateRegistry.close();</span><br><span class="line">      sharedStateRegistry &#x3D; sharedStateRegistryFactory.create(executor);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Recover the checkpoints, TODO this could be done only when there is a new leader, not on each recovery</span><br><span class="line">      completedCheckpointStore.recover();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Now, we re-register all (shared) states from the checkpoint store with the new registry</span><br><span class="line">      for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) &#123;</span><br><span class="line">         completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;Status of the shared state registry of job &#123;&#125; after restore: &#123;&#125;.&quot;, job, sharedStateRegistry);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Restore from the latest checkpoint</span><br><span class="line">      CompletedCheckpoint latest &#x3D; completedCheckpointStore.getLatestCheckpoint(isPreferCheckpointForRecovery);</span><br><span class="line"></span><br><span class="line">      if (latest &#x3D;&#x3D; null) &#123;</span><br><span class="line">         if (errorIfNoCheckpoint) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No completed checkpoint available&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;Resetting the master hooks.&quot;);</span><br><span class="line">            MasterHooks.reset(masterHooks.values(), LOG);</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.info(&quot;Restoring job &#123;&#125; from latest valid checkpoint: &#123;&#125;.&quot;, job, latest);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; re-assign the task states</span><br><span class="line">      final Map&lt;OperatorID, OperatorState&gt; operatorStates &#x3D; latest.getOperatorStates();</span><br><span class="line"></span><br><span class="line">      StateAssignmentOperation stateAssignmentOperation &#x3D;</span><br><span class="line">            new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState);</span><br><span class="line"></span><br><span class="line">      stateAssignmentOperation.assignStates();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; call master hooks for restore</span><br><span class="line"></span><br><span class="line">      MasterHooks.restoreMasterHooks(</span><br><span class="line">            masterHooks,</span><br><span class="line">            latest.getMasterHookStates(),</span><br><span class="line">            latest.getCheckpointID(),</span><br><span class="line">            allowNonRestoredState,</span><br><span class="line">            LOG);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; update metrics</span><br><span class="line"></span><br><span class="line">      if (statsTracker !&#x3D; null) &#123;</span><br><span class="line">         long restoreTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">         RestoredCheckpointStats restored &#x3D; new RestoredCheckpointStats(</span><br><span class="line">            latest.getCheckpointID(),</span><br><span class="line">            latest.getProperties(),</span><br><span class="line">            restoreTimestamp,</span><br><span class="line">            latest.getExternalPointer());</span><br><span class="line"></span><br><span class="line">         statsTracker.reportRestoredCheckpoint(restored);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态的分配过程被封装在 <code>StateAssignmentOperation</code> 中。在状态恢复的过程中，假如任务的并行度发生变化，那么每个子任务的状态和先前必然是不一致的，这其中就涉及到状态的平均重新分配问题，关于状态分配的细节，可以参考 Flink 团队的博文 <a href="https://flink.apache.org/features/2017/07/04/flink-rescalable-state.html#reassigning-operator-state-when-rescaling" target="_blank" rel="noopener">A Deep Dive into Rescalable State in Apache Flink</a>，里面给出了 operator state 和 keyed state 重新分配的详细介绍。</p>
<p>最终，每个 <code>Task</code> 分配的状态被封装在 <code>JobManagerTaskRestore</code> 中，并通过 <code>Execution.setInitialState()</code> 关联到 <code>Execution</code> 中。<code>JobManagerTaskRestore</code> 回作为 <code>TaskDeploymentDescriptor</code> 的一个属性下发到 <code>TaskExecutor</code> 中。</p>
<p>当 <code>TaskDeploymentDescriptor</code> 被提交给 <code>TaskExecutor</code> 之后，<code>TaskExecutor</code> 会 <code>TaskStateManager</code> 用于管理当前 <code>Task</code> 的状态，<code>TaskStateManager</code> 对象会基于分配的 <code>JobManagerTaskRestore</code> 和本地状态存储 <code>TaskLocalStateStore</code> 进行创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;Acknowledge&gt; submitTask(</span><br><span class="line">      TaskDeploymentDescriptor tdd,</span><br><span class="line">      JobMasterId jobMasterId,</span><br><span class="line">      Time timeout) &#123;</span><br><span class="line">......</span><br><span class="line">   &#x2F;&#x2F;本地状态存储</span><br><span class="line">      final TaskLocalStateStore localStateStore &#x3D; localStateStoresManager.localStateStoreForSubtask(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getAllocationId(),</span><br><span class="line">         taskInformation.getJobVertexId(),</span><br><span class="line">         tdd.getSubtaskIndex());</span><br><span class="line">&#x2F;&#x2F;由 JobManager 分配的用于恢复的状态</span><br><span class="line">      final JobManagerTaskRestore taskRestore &#x3D; tdd.getTaskRestore();</span><br><span class="line">&#x2F;&#x2F;创建 TaskStateManager</span><br><span class="line">      final TaskStateManager taskStateManager &#x3D; new TaskStateManagerImpl(</span><br><span class="line">         jobId,</span><br><span class="line">         tdd.getExecutionAttemptId(),</span><br><span class="line">         localStateStore,</span><br><span class="line">         taskRestore,</span><br><span class="line">         checkpointResponder);</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Task</code> 启动后，<code>StreamTask</code> 会先调用 <code>initializeState</code> 方法，这样每一个算子都会调用 <code>StreamOperator.initializeState()</code> 进行状态的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">StreamTask:</span><br><span class="line">private void initializeStateAndOpen() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   StreamOperator&lt;?&gt;[] allOperators &#x3D; operatorChain.getAllOperators();</span><br><span class="line"></span><br><span class="line">   for (StreamOperator&lt;?&gt; operator : allOperators) &#123;</span><br><span class="line">      if (null !&#x3D; operator) &#123;</span><br><span class="line">         operator.initializeState();</span><br><span class="line">         operator.open();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStreamOperator:</span><br><span class="line">public final void initializeState() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		final TypeSerializer&lt;?&gt; keySerializer &#x3D; config.getStateKeySerializer(getUserCodeClassloader());</span><br><span class="line"></span><br><span class="line">		final StreamTask&lt;?, ?&gt; containingTask &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(getContainingTask());</span><br><span class="line">		final CloseableRegistry streamTaskCloseableRegistry &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(containingTask.getCancelables());</span><br><span class="line">		final StreamTaskStateInitializer streamTaskStateManager &#x3D;</span><br><span class="line">			Preconditions.checkNotNull(containingTask.createStreamTaskStateInitializer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 StreamOperatorStateContext，这一步会进行状态的恢复，</span><br><span class="line">		&#x2F;&#x2F;这样 operatorStateBackend 和 keyedStateBackend 就可以恢复到到最后一次 checkpoint 的状态</span><br><span class="line">		&#x2F;&#x2F;timeServiceManager 也会恢复</span><br><span class="line">		final StreamOperatorStateContext context &#x3D;</span><br><span class="line">			streamTaskStateManager.streamOperatorStateContext(</span><br><span class="line">				getOperatorID(),</span><br><span class="line">				getClass().getSimpleName(),</span><br><span class="line">				getProcessingTimeService(),</span><br><span class="line">				this,</span><br><span class="line">				keySerializer,</span><br><span class="line">				streamTaskCloseableRegistry,</span><br><span class="line">				metrics);</span><br><span class="line"></span><br><span class="line">		this.operatorStateBackend &#x3D; context.operatorStateBackend();</span><br><span class="line">		this.keyedStateBackend &#x3D; context.keyedStateBackend();</span><br><span class="line"></span><br><span class="line">		if (keyedStateBackend !&#x3D; null) &#123;</span><br><span class="line">			this.keyedStateStore &#x3D; new DefaultKeyedStateStore(keyedStateBackend, getExecutionConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		timeServiceManager &#x3D; context.internalTimerServiceManager();</span><br><span class="line"></span><br><span class="line">		CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; keyedStateInputs &#x3D; context.rawKeyedStateInputs();</span><br><span class="line">		CloseableIterable&lt;StatePartitionStreamProvider&gt; operatorStateInputs &#x3D; context.rawOperatorStateInputs();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;StateInitializationContext 对外暴露了 state backend，timer service manager 等，operator 可以借助它来进行状态初始化</span><br><span class="line">			StateInitializationContext initializationContext &#x3D; new StateInitializationContextImpl(</span><br><span class="line">				context.isRestored(), &#x2F;&#x2F; information whether we restore or start for the first time</span><br><span class="line">				operatorStateBackend, &#x2F;&#x2F; access to operator state backend</span><br><span class="line">				keyedStateStore, &#x2F;&#x2F; access to keyed state backend</span><br><span class="line">				keyedStateInputs, &#x2F;&#x2F; access to keyed state stream</span><br><span class="line">				operatorStateInputs); &#x2F;&#x2F; access to operator state stream</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进行状态初始化，在子类中实现，比如调用 UDF 的状态初始化方法</span><br><span class="line">			initializeState(initializationContext);</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			closeFromRegistry(operatorStateInputs, streamTaskCloseableRegistry);</span><br><span class="line">			closeFromRegistry(keyedStateInputs, streamTaskCloseableRegistry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">public void initializeState(StateInitializationContext context) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">AbstractUdfStreamOperator:</span><br><span class="line">public void initializeState(StateInitializationContext context) throws Exception &#123;</span><br><span class="line">		super.initializeState(context);</span><br><span class="line">		StreamingFunctionUtils.restoreFunctionState(context, userFunction);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>状态恢复的关键操作在于通过 <code>StreamTaskStateInitializer.streamOperatorStateContext()</code> 生成 <code>StreamOperatorStateContext</code>, 通过 <code>StreamOperatorStateContext</code> 可以获取 state backend，timer service manager 等：</p>
<p>streamTaskStateManager.streamOperatorStateContext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">StreamTaskStateInitializer:</span><br><span class="line">StreamOperatorStateContext streamOperatorStateContext(</span><br><span class="line">   @Nonnull OperatorID operatorID,</span><br><span class="line">   @Nonnull String operatorClassName,</span><br><span class="line">   @Nonnull ProcessingTimeService processingTimeService,</span><br><span class="line">   @Nonnull KeyContext keyContext,</span><br><span class="line">   @Nullable TypeSerializer&lt;?&gt; keySerializer,</span><br><span class="line">   @Nonnull CloseableRegistry streamTaskCloseableRegistry,</span><br><span class="line">   @Nonnull MetricGroup metricGroup) throws Exception;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> public interface StreamOperatorStateContext &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns true, the states provided by this context are restored from a checkpoint&#x2F;savepoint.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	boolean isRestored();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the operator state backend for the stream operator.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	OperatorStateBackend operatorStateBackend();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the keyed state backend for the stream operator. This method returns null for non-keyed operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	AbstractKeyedStateBackend&lt;?&gt; keyedStateBackend();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns the internal timer service manager for the stream operator. This method returns null for non-keyed</span><br><span class="line">	 * operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	InternalTimeServiceManager&lt;?&gt; internalTimerServiceManager();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns an iterable to obtain input streams for previously stored operator state partitions that are assigned to</span><br><span class="line">	 * this stream operator.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	CloseableIterable&lt;StatePartitionStreamProvider&gt; rawOperatorStateInputs();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Returns an iterable to obtain input streams for previously stored keyed state partitions that are assigned to</span><br><span class="line">	 * this operator. This method returns null for non-keyed operators.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; rawKeyedStateInputs();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StreamTaskStateInitializerImpl实现了StreamTaskStateInitializer接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public StreamOperatorStateContext streamOperatorStateContext(</span><br><span class="line">   @Nonnull OperatorID operatorID,</span><br><span class="line">   @Nonnull String operatorClassName,</span><br><span class="line">   @Nonnull ProcessingTimeService processingTimeService,</span><br><span class="line">   @Nonnull KeyContext keyContext,</span><br><span class="line">   @Nullable TypeSerializer&lt;?&gt; keySerializer,</span><br><span class="line">   @Nonnull CloseableRegistry streamTaskCloseableRegistry,</span><br><span class="line">   @Nonnull MetricGroup metricGroup) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   TaskInfo taskInfo &#x3D; environment.getTaskInfo();</span><br><span class="line">   OperatorSubtaskDescriptionText operatorSubtaskDescription &#x3D;</span><br><span class="line">      new OperatorSubtaskDescriptionText(</span><br><span class="line">         operatorID,</span><br><span class="line">         operatorClassName,</span><br><span class="line">         taskInfo.getIndexOfThisSubtask(),</span><br><span class="line">         taskInfo.getNumberOfParallelSubtasks());</span><br><span class="line"></span><br><span class="line">   final String operatorIdentifierText &#x3D; operatorSubtaskDescription.toString();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先获取用于恢复状态的 PrioritizedOperatorSubtaskState</span><br><span class="line">   final PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates &#x3D;</span><br><span class="line">      taskStateManager.prioritizedOperatorState(operatorID);</span><br><span class="line"></span><br><span class="line">   AbstractKeyedStateBackend&lt;?&gt; keyedStatedBackend &#x3D; null;</span><br><span class="line">   OperatorStateBackend operatorStateBackend &#x3D; null;</span><br><span class="line">   CloseableIterable&lt;KeyGroupStatePartitionStreamProvider&gt; rawKeyedStateInputs &#x3D; null;</span><br><span class="line">   CloseableIterable&lt;StatePartitionStreamProvider&gt; rawOperatorStateInputs &#x3D; null;</span><br><span class="line">   InternalTimeServiceManager&lt;?&gt; timeServiceManager;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Keyed State Backend --------------</span><br><span class="line">      keyedStatedBackend &#x3D; keyedStatedBackend(</span><br><span class="line">         keySerializer,</span><br><span class="line">         operatorIdentifierText,</span><br><span class="line">         prioritizedOperatorSubtaskStates,</span><br><span class="line">         streamTaskCloseableRegistry,</span><br><span class="line">         metricGroup);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Operator State Backend --------------</span><br><span class="line">      operatorStateBackend &#x3D; operatorStateBackend(</span><br><span class="line">         operatorIdentifierText,</span><br><span class="line">         prioritizedOperatorSubtaskStates,</span><br><span class="line">         streamTaskCloseableRegistry);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Raw State Streams --------------</span><br><span class="line">      rawKeyedStateInputs &#x3D; rawKeyedStateInputs(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedRawKeyedState().iterator());</span><br><span class="line">      streamTaskCloseableRegistry.registerCloseable(rawKeyedStateInputs);</span><br><span class="line"></span><br><span class="line">      rawOperatorStateInputs &#x3D; rawOperatorStateInputs(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedRawOperatorState().iterator());</span><br><span class="line">      streamTaskCloseableRegistry.registerCloseable(rawOperatorStateInputs);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Internal Timer Service Manager --------------</span><br><span class="line">      timeServiceManager &#x3D; internalTimeServiceManager(keyedStatedBackend, keyContext, processingTimeService, rawKeyedStateInputs);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; -------------- Preparing return value --------------</span><br><span class="line"></span><br><span class="line">      return new StreamOperatorStateContextImpl(</span><br><span class="line">         prioritizedOperatorSubtaskStates.isRestored(),</span><br><span class="line">         operatorStateBackend,</span><br><span class="line">         keyedStatedBackend,</span><br><span class="line">         timeServiceManager,</span><br><span class="line">         rawOperatorStateInputs,</span><br><span class="line">         rawKeyedStateInputs);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态恢复和创建创建 state backend 耦合在一起，借助 <code>BackendRestorerProcedure</code> 来完成，具体的逻辑在 <code>BackendRestorerProcedure.createAndRestore</code> 方法中。</p>
<p>以operatorStateBackend为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected OperatorStateBackend operatorStateBackend(</span><br><span class="line">   String operatorIdentifierText,</span><br><span class="line">   PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates,</span><br><span class="line">   CloseableRegistry backendCloseableRegistry) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   String logDescription &#x3D; &quot;operator state backend for &quot; + operatorIdentifierText;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Now restore processing is included in backend building&#x2F;constructing process, so we need to make sure</span><br><span class="line">   &#x2F;&#x2F; each stream constructed in restore could also be closed in case of task cancel, for example the data</span><br><span class="line">   &#x2F;&#x2F; input stream opened for serDe during restore.</span><br><span class="line">   CloseableRegistry cancelStreamRegistryForRestore &#x3D; new CloseableRegistry();</span><br><span class="line">   backendCloseableRegistry.registerCloseable(cancelStreamRegistryForRestore);</span><br><span class="line">   BackendRestorerProcedure&lt;OperatorStateBackend, OperatorStateHandle&gt; backendRestorer &#x3D;</span><br><span class="line">      new BackendRestorerProcedure&lt;&gt;(</span><br><span class="line">         (stateHandles) -&gt; stateBackend.createOperatorStateBackend(</span><br><span class="line">            environment,</span><br><span class="line">            operatorIdentifierText,</span><br><span class="line">            stateHandles,</span><br><span class="line">            cancelStreamRegistryForRestore),</span><br><span class="line">         backendCloseableRegistry,</span><br><span class="line">         logDescription);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建及恢复状态</span><br><span class="line">      return backendRestorer.createAndRestore(</span><br><span class="line">         prioritizedOperatorSubtaskStates.getPrioritizedManagedOperatorState());</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      if (backendCloseableRegistry.unregisterCloseable(cancelStreamRegistryForRestore)) &#123;</span><br><span class="line">         IOUtils.closeQuietly(cancelStreamRegistryForRestore);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BackendRestorerProcedure的createAndRestore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public T createAndRestore(@Nonnull List&lt;? extends Collection&lt;S&gt;&gt; restoreOptions) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   if (restoreOptions.isEmpty()) &#123;</span><br><span class="line">      restoreOptions &#x3D; Collections.singletonList(Collections.emptyList());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int alternativeIdx &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   Exception collectedException &#x3D; null;</span><br><span class="line"></span><br><span class="line">   while (alternativeIdx &lt; restoreOptions.size()) &#123;</span><br><span class="line"></span><br><span class="line">      Collection&lt;S&gt; restoreState &#x3D; restoreOptions.get(alternativeIdx);</span><br><span class="line"></span><br><span class="line">      ++alternativeIdx;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; IMPORTANT: please be careful when modifying the log statements because they are used for validation in</span><br><span class="line">      &#x2F;&#x2F; the automatic end-to-end tests. Those tests might fail if they are not aligned with the log message!</span><br><span class="line">      if (restoreState.isEmpty()) &#123;</span><br><span class="line">         LOG.debug(&quot;Creating &#123;&#125; with empty state.&quot;, logDescription);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(&quot;Creating &#123;&#125; and restoring with state &#123;&#125; from alternative (&#123;&#125;&#x2F;&#123;&#125;).&quot;,</span><br><span class="line">               logDescription, restoreState, alternativeIdx, restoreOptions.size());</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            LOG.debug(&quot;Creating &#123;&#125; and restoring with state from alternative (&#123;&#125;&#x2F;&#123;&#125;).&quot;,</span><br><span class="line">               logDescription, alternativeIdx, restoreOptions.size());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         return attemptCreateAndRestore(restoreState);</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">         collectedException &#x3D; ExceptionUtils.firstOrSuppressed(ex, collectedException);</span><br><span class="line"></span><br><span class="line">         LOG.warn(&quot;Exception while restoring &#123;&#125; from alternative (&#123;&#125;&#x2F;&#123;&#125;), will retry while more &quot; +</span><br><span class="line">            &quot;alternatives are available.&quot;, logDescription, alternativeIdx, restoreOptions.size(), ex);</span><br><span class="line"></span><br><span class="line">         if (backendCloseableRegistry.isClosed()) &#123;</span><br><span class="line">            throw new FlinkException(&quot;Stopping restore attempts for already cancelled task.&quot;, collectedException);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new FlinkException(&quot;Could not restore &quot; + logDescription + &quot; from any of the &quot; + restoreOptions.size() +</span><br><span class="line">      &quot; provided restore options.&quot;, collectedException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T attemptCreateAndRestore(Collection&lt;S&gt; restoreState) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; create a new backend with necessary initialization.</span><br><span class="line">   &#x2F;&#x2F;创建及恢复状态</span><br><span class="line">   &#x2F;&#x2F;instanceSupplier有具体状态后端实现，就是StateBackend接口的createOperatorStateBackend方法</span><br><span class="line">   final T backendInstance &#x3D; instanceSupplier.apply(restoreState);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; register the backend with the registry to participate in task lifecycle w.r.t. cancellation.</span><br><span class="line">      backendCloseableRegistry.registerCloseable(backendInstance);</span><br><span class="line">      return backendInstance;</span><br><span class="line">   &#125; catch (Exception ex) &#123;</span><br><span class="line">      &#x2F;&#x2F; dispose the backend, e.g. to release native resources, if failed to register it into registry.</span><br><span class="line">      try &#123;</span><br><span class="line">         backendInstance.dispose();</span><br><span class="line">      &#125; catch (Exception disposeEx) &#123;</span><br><span class="line">         ex &#x3D; ExceptionUtils.firstOrSuppressed(disposeEx, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throw ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskStateManagerImpl的prioritizedOperatorState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public PrioritizedOperatorSubtaskState prioritizedOperatorState(OperatorID operatorID) &#123;</span><br><span class="line"></span><br><span class="line">   if (jobManagerTaskRestore &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return PrioritizedOperatorSubtaskState.emptyNotRestored();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;从 JobManager 获取的状态快照</span><br><span class="line">   TaskStateSnapshot jobManagerStateSnapshot &#x3D;</span><br><span class="line">      jobManagerTaskRestore.getTaskStateSnapshot();</span><br><span class="line"></span><br><span class="line">   OperatorSubtaskState jobManagerSubtaskState &#x3D;</span><br><span class="line">      jobManagerStateSnapshot.getSubtaskStateByOperatorID(operatorID);</span><br><span class="line"></span><br><span class="line">   if (jobManagerSubtaskState &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return PrioritizedOperatorSubtaskState.emptyNotRestored();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;本地状态快照作为备选</span><br><span class="line">   long restoreCheckpointId &#x3D; jobManagerTaskRestore.getRestoreCheckpointId();</span><br><span class="line"></span><br><span class="line">   TaskStateSnapshot localStateSnapshot &#x3D;</span><br><span class="line">      localStateStore.retrieveLocalState(restoreCheckpointId);</span><br><span class="line"></span><br><span class="line">   localStateStore.pruneMatchingCheckpoints((long checkpointId) -&gt; checkpointId !&#x3D; restoreCheckpointId);</span><br><span class="line"></span><br><span class="line">   List&lt;OperatorSubtaskState&gt; alternativesByPriority &#x3D; Collections.emptyList();</span><br><span class="line"></span><br><span class="line">   if (localStateSnapshot !&#x3D; null) &#123;</span><br><span class="line">      OperatorSubtaskState localSubtaskState &#x3D; localStateSnapshot.getSubtaskStateByOperatorID(operatorID);</span><br><span class="line"></span><br><span class="line">      if (localSubtaskState !&#x3D; null) &#123;</span><br><span class="line">         alternativesByPriority &#x3D; Collections.singletonList(localSubtaskState);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Operator &#123;&#125; has remote state &#123;&#125; from job manager and local state alternatives &#123;&#125; from local &quot; +</span><br><span class="line">         &quot;state store &#123;&#125;.&quot;, operatorID, jobManagerSubtaskState, alternativesByPriority, localStateStore);</span><br><span class="line">&#x2F;&#x2F;构建 PrioritizedOperatorSubtaskState</span><br><span class="line">   PrioritizedOperatorSubtaskState.Builder builder &#x3D; new PrioritizedOperatorSubtaskState.Builder(</span><br><span class="line">      jobManagerSubtaskState,</span><br><span class="line">      alternativesByPriority,</span><br><span class="line">      true);</span><br><span class="line"></span><br><span class="line">   return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了生成 <code>StreamOperatorStateContext</code>，首先要通过 <code>TaskStateManager.prioritizedOperatorState()</code> 方法获得每个 Operator 需要恢复的状态句柄；然后使用获得的状态句柄创建并还原 state backend 和 timer。这里引入了 <code>PrioritizedOperatorSubtaskState</code>, 它封装了多个备选的 OperatorSubtaskState (快照)，这些快照相互之间是可以（部分）替换的，并按照优先级排序。列表中的最后一项是包含了这个子任务的所有状态，但是优先级最低。在进行状态恢复的时候，优先从高优先级的状态句柄中读取状态。</p>
<p>PrioritizedOperatorSubtaskState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Ground truth of state, provided by job manager. *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final OperatorSubtaskState jobManagerState;</span><br><span class="line"></span><br><span class="line">   &#x2F;** (Local) alternatives to the job manager state. *&#x2F;</span><br><span class="line">   @Nonnull</span><br><span class="line">   private final List&lt;OperatorSubtaskState&gt; alternativesByPriority;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag if the states have been restored. *&#x2F;</span><br><span class="line">   private final boolean restored;</span><br><span class="line"></span><br><span class="line">   public Builder(</span><br><span class="line">      @Nonnull OperatorSubtaskState jobManagerState,</span><br><span class="line">      @Nonnull List&lt;OperatorSubtaskState&gt; alternativesByPriority) &#123;</span><br><span class="line">      this(jobManagerState, alternativesByPriority, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Builder(</span><br><span class="line">      @Nonnull OperatorSubtaskState jobManagerState,</span><br><span class="line">      @Nonnull List&lt;OperatorSubtaskState&gt; alternativesByPriority,</span><br><span class="line">      boolean restored) &#123;</span><br><span class="line"></span><br><span class="line">      this.jobManagerState &#x3D; jobManagerState;</span><br><span class="line">      this.alternativesByPriority &#x3D; alternativesByPriority;</span><br><span class="line">      this.restored &#x3D; restored;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public PrioritizedOperatorSubtaskState build() &#123;</span><br><span class="line">      int size &#x3D; alternativesByPriority.size();</span><br><span class="line">      List&lt;StateObjectCollection&lt;OperatorStateHandle&gt;&gt; managedOperatorAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;KeyedStateHandle&gt;&gt; managedKeyedAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;OperatorStateHandle&gt;&gt; rawOperatorAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line">      List&lt;StateObjectCollection&lt;KeyedStateHandle&gt;&gt; rawKeyedAlternatives &#x3D; new ArrayList&lt;&gt;(size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按照优先级添加SubtaskState</span><br><span class="line">      for (OperatorSubtaskState subtaskState : alternativesByPriority) &#123;</span><br><span class="line"></span><br><span class="line">         if (subtaskState !&#x3D; null) &#123;</span><br><span class="line">            managedKeyedAlternatives.add(subtaskState.getManagedKeyedState());</span><br><span class="line">            rawKeyedAlternatives.add(subtaskState.getRawKeyedState());</span><br><span class="line">            managedOperatorAlternatives.add(subtaskState.getManagedOperatorState());</span><br><span class="line">            rawOperatorAlternatives.add(subtaskState.getRawOperatorState());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Key-groups should match.</span><br><span class="line">      BiFunction&lt;KeyedStateHandle, KeyedStateHandle, Boolean&gt; keyedStateApprover &#x3D;</span><br><span class="line">         (ref, alt) -&gt; ref.getKeyGroupRange().equals(alt.getKeyGroupRange());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; State meta data should match.</span><br><span class="line">      BiFunction&lt;OperatorStateHandle, OperatorStateHandle, Boolean&gt; operatorStateApprover &#x3D;</span><br><span class="line">         (ref, alt) -&gt; ref.getStateNameToPartitionOffsets().equals(alt.getStateNameToPartitionOffsets());</span><br><span class="line"></span><br><span class="line">      return new PrioritizedOperatorSubtaskState(</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getManagedKeyedState(),</span><br><span class="line">            managedKeyedAlternatives,</span><br><span class="line">            keyedStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getRawKeyedState(),</span><br><span class="line">            rawKeyedAlternatives,</span><br><span class="line">            keyedStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getManagedOperatorState(),</span><br><span class="line">            managedOperatorAlternatives,</span><br><span class="line">            operatorStateApprover),</span><br><span class="line">         resolvePrioritizedAlternatives(</span><br><span class="line">            jobManagerState.getRawOperatorState(),</span><br><span class="line">            rawOperatorAlternatives,</span><br><span class="line">            operatorStateApprover),</span><br><span class="line">         restored);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> protected &lt;T extends StateObject&gt; List&lt;StateObjectCollection&lt;T&gt;&gt; resolvePrioritizedAlternatives(</span><br><span class="line">			StateObjectCollection&lt;T&gt; jobManagerState,</span><br><span class="line">			List&lt;StateObjectCollection&lt;T&gt;&gt; alternativesByPriority,</span><br><span class="line">			BiFunction&lt;T, T, Boolean&gt; approveFun) &#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Nothing to resolve if there are no alternatives, or the ground truth has already no state, or if we can</span><br><span class="line">			&#x2F;&#x2F; assume that a rescaling happened because we find more than one handle in the JM state (this is more a sanity</span><br><span class="line">			&#x2F;&#x2F; check).</span><br><span class="line">			if (alternativesByPriority &#x3D;&#x3D; null</span><br><span class="line">				|| alternativesByPriority.isEmpty()</span><br><span class="line">				|| !jobManagerState.hasState()</span><br><span class="line">				|| jobManagerState.size() !&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">				return Collections.singletonList(jobManagerState);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; As we know size is &#x3D;&#x3D; 1</span><br><span class="line">			T reference &#x3D; jobManagerState.iterator().next();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; This will contain the end result, we initialize it with the potential max. size.</span><br><span class="line">			List&lt;StateObjectCollection&lt;T&gt;&gt; approved &#x3D;</span><br><span class="line">				new ArrayList&lt;&gt;(1 + alternativesByPriority.size());</span><br><span class="line"></span><br><span class="line">			for (StateObjectCollection&lt;T&gt; alternative : alternativesByPriority) &#123;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; We found an alternative to the JM state if it has state, we have a 1:1 relationship, and the</span><br><span class="line">				&#x2F;&#x2F; approve-function signaled true.</span><br><span class="line">				if (alternative !&#x3D; null</span><br><span class="line">					&amp;&amp; alternative.hasState()</span><br><span class="line">					&amp;&amp; alternative.size() &#x3D;&#x3D; 1</span><br><span class="line">					&amp;&amp; BooleanUtils.isTrue(approveFun.apply(reference, alternative.iterator().next()))) &#123;</span><br><span class="line"></span><br><span class="line">					approved.add(alternative);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Of course we include the ground truth as last alternative.</span><br><span class="line">			&#x2F;&#x2F; 从 JobManager 获取的状态作为最低优先级的备选</span><br><span class="line">			approved.add(jobManagerState);</span><br><span class="line">			return Collections.unmodifiableList(approved);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/" rel="next" title="Flink的Task的数据传输过程">
                <i class="fa fa-chevron-left"></i> Flink的Task的数据传输过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HH KKs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HH KKs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
