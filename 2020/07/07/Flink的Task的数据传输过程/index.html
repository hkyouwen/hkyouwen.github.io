<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Task的数据传输包括Task内部传输和Task之间的传输。 Task内部传输是 Task 内部包含的多个不同的算子之间的数据传递，通过函数调用的参数来传递数据。 首先，要看一下 Output 接口，Output 接口继承自 Collector 接口，用于接受 Operator 提交的数据 1234567891011121314151617181920public interface Output">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink的Task的数据传输过程">
<meta property="og:url" content="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="HK书屋">
<meta property="og:description" content="Task的数据传输包括Task内部传输和Task之间的传输。 Task内部传输是 Task 内部包含的多个不同的算子之间的数据传递，通过函数调用的参数来传递数据。 首先，要看一下 Output 接口，Output 接口继承自 Collector 接口，用于接受 Operator 提交的数据 1234567891011121314151617181920public interface Output">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeSending.png">
<meta property="og:image" content="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeReceiving.png">
<meta property="article:published_time" content="2020-07-07T11:39:38.718Z">
<meta property="article:modified_time" content="2020-07-15T02:05:56.476Z">
<meta property="article:author" content="HH KKs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeSending.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/07/Flink的Task的数据传输过程/"/>





  <title>Flink的Task的数据传输过程 | HK书屋</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HK书屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HH KKs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HK书屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flink的Task的数据传输过程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-07T19:39:38+08:00">
                2020-07-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Task的数据传输包括Task内部传输和Task之间的传输。</p>
<p>Task内部传输是 Task 内部包含的多个不同的算子之间的数据传递，通过函数调用的参数来传递数据。</p>
<p>首先，要看一下 <code>Output</code> 接口，<code>Output</code> 接口继承自 <code>Collector</code> 接口，用于接受 Operator 提交的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Output&lt;T&gt; extends Collector&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Emits a &#123;@link Watermark&#125; from an operator. This watermark is broadcast to all downstream</span><br><span class="line">    * operators.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;A watermark specifies that no element with a timestamp lower or equal to the watermark</span><br><span class="line">    * timestamp will be emitted in the future.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void emitWatermark(Watermark mark);</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Emits a record the side output identified by the given &#123;@link OutputTag&#125;.</span><br><span class="line">    *</span><br><span class="line">    * @param record The record to collect.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record);</span><br><span class="line"></span><br><span class="line">   void emitLatencyMarker(LatencyMarker latencyMarker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>OperatorChain</code> 内部还有一个 <code>WatermarkGaugeExposingOutput</code> 接口继承自 <code>Output</code>，它主要是额外提供了一个获取 watermark 值的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface WatermarkGaugeExposingOutput&lt;T&gt; extends Output&lt;T&gt; &#123;</span><br><span class="line">   Gauge&lt;Long&gt; getWatermarkGauge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说过，在OperatorChain内部创建当前节点的下游节点时，会调用 createOutputCollector 为当前节点创建 output， ExecutionConfig有一个配置项，即 objectReuse，在默认情况下会禁止对象重用。如果不允许对象重用，则不会使用 ChainingOutput，而是会使用 CopyingChainingOutput。顾名思义，它和 ChainingOutput的区别在于，它会对记录进行拷贝后传递给下游算子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">      StreamTask&lt;OUT, ?&gt; containingTask,</span><br><span class="line">      StreamConfig operatorConfig,</span><br><span class="line">      Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">      ClassLoader userCodeClassloader,</span><br><span class="line">      Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">      List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">      OutputTag&lt;IN&gt; outputTag,</span><br><span class="line">      MailboxExecutorFactory mailboxExecutorFactory) &#123;</span><br><span class="line">   &#x2F;&#x2F; create the output that the operator writes to first. this may recursively create more operators</span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput &#x3D; createOutputCollector(</span><br><span class="line">      containingTask,</span><br><span class="line">      operatorConfig,</span><br><span class="line">      chainedConfigs,</span><br><span class="line">      userCodeClassloader,</span><br><span class="line">      streamOutputs,</span><br><span class="line">      allOperators,</span><br><span class="line">      mailboxExecutorFactory);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; now create the operator and give it the output collector to write its output to</span><br><span class="line">   OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator &#x3D; StreamOperatorFactoryUtil.createOperator(</span><br><span class="line">         operatorConfig.getStreamOperatorFactory(userCodeClassloader),</span><br><span class="line">         containingTask,</span><br><span class="line">         operatorConfig,</span><br><span class="line">         chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">   allOperators.add(chainedOperator);</span><br><span class="line"></span><br><span class="line">   WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; currentOperatorOutput;</span><br><span class="line">   &#x2F;&#x2F;判断objectReuse</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      currentOperatorOutput &#x3D; new ChainingOutput&lt;&gt;(chainedOperator, this, outputTag);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      TypeSerializer&lt;IN&gt; inSerializer &#x3D; operatorConfig.getTypeSerializerIn1(userCodeClassloader);</span><br><span class="line">      currentOperatorOutput &#x3D; new CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   return currentOperatorOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createOutputCollector将createChainedOperator返回的Output封装为一组outputs。<code>BroadcastingOutputCollector</code> 封装了一组 <code>Output</code>, 即 <code>Output&lt;StreamRecord&lt;T&gt;&gt;[] outputs</code>, 在接收到 <code>StreamRecord</code> 时，会将消息提交到所有的 内部所有的 <code>Output</code> 中。<code>BroadcastingOutputCollector</code>主要用在当前算子有多个下游算子的情况下。与此对应的还有一个 <code>CopyingBroadcastingOutputCollector</code>。</p>
<p><code>DirectedOutput</code> 基于 <code>OutputSelector&lt;OUT&gt;[] outputSelectors</code> 选择要转发的目标 <code>Output</code>，主要是在 split/select 的情况下使用。与 <code>DirectedOutput</code> 对应的也有一个 <code>CopyingDirectedOutput</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (selectors &#x3D;&#x3D; null || selectors.isEmpty()) &#123;</span><br><span class="line">   &#x2F;&#x2F; simple path, no selector necessary</span><br><span class="line">   if (allOutputs.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return allOutputs.get(0).f0;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; send to N outputs. Note that this includes the special case</span><br><span class="line">      &#x2F;&#x2F; of sending to zero outputs</span><br><span class="line">      @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">      Output&lt;StreamRecord&lt;T&gt;&gt;[] asArray &#x3D; new Output[allOutputs.size()];</span><br><span class="line">      for (int i &#x3D; 0; i &lt; allOutputs.size(); i++) &#123;</span><br><span class="line">         asArray[i] &#x3D; allOutputs.get(i).f0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">      &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">      &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">      if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">         return new CopyingBroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">      &#125; else  &#123;</span><br><span class="line">         return new BroadcastingOutputCollector&lt;&gt;(asArray, this);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">   &#x2F;&#x2F; selector present, more complex routing necessary</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; This is the inverse of creating the normal ChainingOutput.</span><br><span class="line">   &#x2F;&#x2F; If the chaining output does not copy we need to copy in the broadcast output,</span><br><span class="line">   &#x2F;&#x2F; otherwise multi-chaining would not work correctly.</span><br><span class="line">   if (containingTask.getExecutionConfig().isObjectReuseEnabled()) &#123;</span><br><span class="line">      return new CopyingDirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return new DirectedOutput&lt;&gt;(selectors, allOutputs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从之前的文章知道StreamOperator的processElement是调用StreamOperator的output的collect方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StreamMap&lt;IN, OUT&gt;</span><br><span class="line">      extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt;</span><br><span class="line">      implements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</span><br><span class="line"></span><br><span class="line">   private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">   public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) &#123;</span><br><span class="line">      super(mapper);</span><br><span class="line">      chainingStrategy &#x3D; ChainingStrategy.ALWAYS;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">      output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以OperatorChain内部数据传递是就是调用ChainingOutput的collect，当 <code>ChainingOutput</code> 接收到当前算子提交的数据时，直接将调用下游算子的 <code>processElement</code> 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static class ChainingOutput&lt;T&gt; implements WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void collect(StreamRecord&lt;T&gt; record) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果有 OutputTag， 则要求 OutputTag 匹配才会转发记录</span><br><span class="line">      if (this.outputTag !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; we are not responsible for emitting to the main output.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pushToOperator(record);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">      if (this.outputTag &#x3D;&#x3D; null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">         &#x2F;&#x2F; we are not responsible for emitting to the side-output specified by this</span><br><span class="line">         &#x2F;&#x2F; OutputTag.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pushToOperator(record);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; we know that the given outputTag matches our OutputTag so the record</span><br><span class="line">         &#x2F;&#x2F; must be of the type that our operator expects.</span><br><span class="line">         @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">         StreamRecord&lt;T&gt; castRecord &#x3D; (StreamRecord&lt;T&gt;) record;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接调用下游算子的 processElement 方法</span><br><span class="line">         numRecordsIn.inc();</span><br><span class="line">         operator.setKeyContextElement1(castRecord);</span><br><span class="line">         operator.processElement(castRecord);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception e) &#123;</span><br><span class="line">         throw new ExceptionInChainedOperatorException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于位于 <code>OperatorChain</code> 末尾的算子，它处理过的记录需要被其它 <code>Task</code> 消费，因此它的记录需要被写入 <code>ResultPartition</code> 。因此，Flink 提供了 <code>RecordWriterOutput</code>，它也实现了 <code>WatermarkGaugeExposingOutput</code>， 但是它是通过 <code>RecordWriter</code> 输出接收到的消息记录。<code>RecordWriter</code> 是 <code>ResultPartitionWriter</code> 的一层包装，提供了将记录序列化到 buffer 中的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RecordWriterOutput&lt;?&gt; streamOutput &#x3D; createStreamOutput(</span><br><span class="line">   recordWriterDelegate.getRecordWriter(i),</span><br><span class="line">   outEdge,</span><br><span class="line">   chainedConfigs.get(outEdge.getSourceId()),</span><br><span class="line">   containingTask.getEnvironment());</span><br></pre></td></tr></table></figure>

<p>task之间的数据传递调用RecordWriterOutput的collect方法，最终调用RecordWriter的emit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public RecordWriterOutput(</span><br><span class="line">      RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; recordWriter,</span><br><span class="line">      TypeSerializer&lt;OUT&gt; outSerializer,</span><br><span class="line">      OutputTag outputTag,</span><br><span class="line">      StreamStatusProvider streamStatusProvider) &#123;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void collect(StreamRecord&lt;OUT&gt; record) &#123;</span><br><span class="line">   if (this.outputTag !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; we are not responsible for emitting to the main output.</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;X&gt; void collect(OutputTag&lt;X&gt; outputTag, StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">   if (this.outputTag &#x3D;&#x3D; null || !this.outputTag.equals(outputTag)) &#123;</span><br><span class="line">      &#x2F;&#x2F; we are not responsible for emitting to the side-output specified by this</span><br><span class="line">      &#x2F;&#x2F; OutputTag.</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) &#123;</span><br><span class="line">   serializationDelegate.setInstance(record);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      recordWriter.emit(serializationDelegate);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e) &#123;</span><br><span class="line">      throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task 通过 <code>RecordWriter</code> 将结果写入 <code>ResultPartition</code> 中。<code>RecordWriter</code> 是对 <code>ResultPartitionWriter</code>的一层封装，并负责将记录对象序列化到 buffer 中。先来看一下 <code>RecordWriter</code> 的成员变量和构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RecordWriter&lt;T extends IOReadableWritable&gt; implements AvailabilityProvider &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Default name for the output flush thread, if no name with a task reference is given. *&#x2F;</span><br><span class="line">   @VisibleForTesting</span><br><span class="line">   public static final String DEFAULT_OUTPUT_FLUSH_THREAD_NAME &#x3D; &quot;OutputFlusher&quot;;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(RecordWriter.class);</span><br><span class="line">&#x2F;&#x2F;底层的 ResultPartition</span><br><span class="line">   protected final ResultPartitionWriter targetPartition;</span><br><span class="line">&#x2F;&#x2F;channel的数量，即 sub-partition的数量</span><br><span class="line">   protected final int numberOfChannels;</span><br><span class="line">&#x2F;&#x2F;序列化</span><br><span class="line">   protected final RecordSerializer&lt;T&gt; serializer;</span><br><span class="line"></span><br><span class="line">   protected final Random rng &#x3D; new XORShiftRandom();</span><br><span class="line"></span><br><span class="line">   private Counter numBytesOut &#x3D; new SimpleCounter();</span><br><span class="line"></span><br><span class="line">   private Counter numBuffersOut &#x3D; new SimpleCounter();</span><br><span class="line"></span><br><span class="line">   private final boolean flushAlways;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The thread that periodically flushes the output, to give an upper latency bound. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;定时强制 flush 输出buffer</span><br><span class="line">   @Nullable</span><br><span class="line">   private final OutputFlusher outputFlusher;</span><br><span class="line"></span><br><span class="line">   &#x2F;** To avoid synchronization overhead on the critical path, best-effort error tracking is enough here.*&#x2F;</span><br><span class="line">   private Throwable flusherException;</span><br><span class="line"></span><br><span class="line">   RecordWriter(ResultPartitionWriter writer, long timeout, String taskName) &#123;</span><br><span class="line">      this.targetPartition &#x3D; writer;</span><br><span class="line">      this.numberOfChannels &#x3D; writer.getNumberOfSubpartitions();</span><br><span class="line">&#x2F;&#x2F;序列化器，用于将一条记录序列化到多个buffer中</span><br><span class="line">      this.serializer &#x3D; new SpanningRecordSerializer&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">      checkArgument(timeout &gt;&#x3D; -1);</span><br><span class="line">      this.flushAlways &#x3D; (timeout &#x3D;&#x3D; 0);</span><br><span class="line">      if (timeout &#x3D;&#x3D; -1 || timeout &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         outputFlusher &#x3D; null;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;根据超时时间创建一个定时 flush 输出 buffer 的线程</span><br><span class="line">         String threadName &#x3D; taskName &#x3D;&#x3D; null ?</span><br><span class="line">            DEFAULT_OUTPUT_FLUSH_THREAD_NAME :</span><br><span class="line">            DEFAULT_OUTPUT_FLUSH_THREAD_NAME + &quot; for &quot; + taskName;</span><br><span class="line"></span><br><span class="line">         outputFlusher &#x3D; new OutputFlusher(threadName, timeout);</span><br><span class="line">         outputFlusher.start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>  buffer的分配在task启动的时候，调用ResultPartitionWriter的setup，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void setupPartitionsAndGates(</span><br><span class="line">   ResultPartitionWriter[] producedPartitions, InputGate[] inputGates) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   for (ResultPartitionWriter partition : producedPartitions) &#123;</span><br><span class="line">      partition.setup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; InputGates must be initialized after the partitions, since during InputGate#setup</span><br><span class="line">   &#x2F;&#x2F; we are requesting partitions</span><br><span class="line">   for (InputGate gate : inputGates) &#123;</span><br><span class="line">      gate.setup();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition的setup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setup() throws IOException &#123;</span><br><span class="line">   checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in result partition setup logic: Already registered buffer pool.&quot;);</span><br><span class="line"></span><br><span class="line">   BufferPool bufferPool &#x3D; checkNotNull(bufferPoolFactory.apply(this));</span><br><span class="line">   &#x2F;&#x2F;创建一个 LocalBufferPool，请求的最少的 MemeorySegment 数量和 sub-partition 一致</span><br><span class="line">   checkArgument(bufferPool.getNumberOfRequiredMemorySegments() &gt;&#x3D; getNumberOfSubpartitions(),</span><br><span class="line">      &quot;Bug in result partition setup logic: Buffer pool has not enough guaranteed buffers for this result partition.&quot;);</span><br><span class="line"></span><br><span class="line">   this.bufferPool &#x3D; bufferPool;</span><br><span class="line">   &#x2F;&#x2F;向 ResultPartitionManager 注册</span><br><span class="line">   partitionManager.registerResultPartition(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartitionManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void registerResultPartition(ResultPartition partition) &#123;</span><br><span class="line">   synchronized (registeredPartitions) &#123;</span><br><span class="line">      checkState(!isShutdown, &quot;Result partition manager already shut down.&quot;);</span><br><span class="line"></span><br><span class="line">      ResultPartition previous &#x3D; registeredPartitions.put(partition.getPartitionId(), partition);</span><br><span class="line"></span><br><span class="line">      if (previous !&#x3D; null) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Result partition already registered.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.debug(&quot;Registered &#123;&#125;.&quot;, partition);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Task 通过 <code>RecordWriter</code> 输出一条记录时，主要流程为：</p>
<ol>
<li><p>通过 ChannelSelector 确定写入的目标 channel</p>
</li>
<li><p>使用 RecordSerializer 对记录进行序列化</p>
</li>
<li><p>向 ResultPartition 请求 BufferBuilder，用于写入序列化结果</p>
</li>
<li><p>向 ResultPartition 添加 BufferConsumer，用于读取写入 Buffer 的数据</p>
</li>
</ol>
<p>   RecordWriter类 emit，前面调用recordWriter.emit会区分BroadcastRecordWriter类的emit和ChannelSelectorRecordWriter的emit，最终都会调用RecordWriter类 的emit</p>
<p>ChannelSelectorRecordWriter，选择channel发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final class ChannelSelectorRecordWriter&lt;T extends IOReadableWritable&gt; extends RecordWriter&lt;T&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;决定一条记录应该写入哪一个channel， 即 sub-partition</span><br><span class="line">   private final ChannelSelector&lt;T&gt; channelSelector;</span><br><span class="line">&#x2F;&#x2F;供每一个 channel 写入数据使用</span><br><span class="line">   &#x2F;** Every subpartition maintains a separate buffer builder which might be null. *&#x2F;</span><br><span class="line">   private final BufferBuilder[] bufferBuilders;</span><br><span class="line"></span><br><span class="line">   ChannelSelectorRecordWriter(</span><br><span class="line">         ResultPartitionWriter writer,</span><br><span class="line">         ChannelSelector&lt;T&gt; channelSelector,</span><br><span class="line">         long timeout,</span><br><span class="line">         String taskName) &#123;</span><br><span class="line">      super(writer, timeout, taskName);</span><br><span class="line"></span><br><span class="line">      this.channelSelector &#x3D; checkNotNull(channelSelector);</span><br><span class="line">      this.channelSelector.setup(numberOfChannels);</span><br><span class="line"></span><br><span class="line">      this.bufferBuilders &#x3D; new BufferBuilder[numberOfChannels];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void emit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">      emit(record, channelSelector.selectChannel(record));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>BroadcastRecordWriter，发送给所有channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final class BroadcastRecordWriter&lt;T extends IOReadableWritable&gt; extends RecordWriter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;供每一个 channel 写入数据使用</span><br><span class="line">   &#x2F;** The current buffer builder shared for all the channels. *&#x2F;</span><br><span class="line">   @Nullable</span><br><span class="line">   private BufferBuilder bufferBuilder;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * The flag for judging whether &#123;@link #requestNewBufferBuilder(int)&#125; and &#123;@link #flushTargetPartition(int)&#125;</span><br><span class="line">    * is triggered by &#123;@link #randomEmit(IOReadableWritable)&#125; or not.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private boolean randomTriggered;</span><br><span class="line"></span><br><span class="line">   BroadcastRecordWriter(</span><br><span class="line">         ResultPartitionWriter writer,</span><br><span class="line">         long timeout,</span><br><span class="line">         String taskName) &#123;</span><br><span class="line">      super(writer, timeout, taskName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void emit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">      broadcastEmit(record);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void broadcastEmit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">		&#x2F;&#x2F; We could actually select any target channel here because all the channels</span><br><span class="line">		&#x2F;&#x2F; are sharing the same BufferBuilder in broadcast mode.</span><br><span class="line">		emit(record, 0);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RecordWriter类 的emit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected void emit(T record, int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">      checkErroneous();</span><br><span class="line">&#x2F;&#x2F;序列化</span><br><span class="line">      serializer.serializeRecord(record);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure we don&#39;t hold onto the large intermediate serialization buffer for too long</span><br><span class="line">      &#x2F;&#x2F;将序列化结果写入buffer</span><br><span class="line">       if (copyFromSerializerToTargetChannel(targetChannel)) &#123;</span><br><span class="line">       &#x2F;&#x2F;清除序列化使用的buffer（这个是序列化时临时写入的byte[]）,减少内存占用</span><br><span class="line">        serializer.prune();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">   * @param targetChannel</span><br><span class="line"></span><br><span class="line">     * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if the intermediate serialization buffer should be pruned</span><br><span class="line">       *&#x2F;</span><br><span class="line">       protected boolean copyFromSerializerToTargetChannel(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; We should reset the initial position of the intermediate serialization buffer before</span><br><span class="line">       &#x2F;&#x2F; copying, so the serialization results can be copied to multiple target buffers.</span><br><span class="line">       serializer.reset();</span><br><span class="line"></span><br><span class="line">     boolean pruneTriggered &#x3D; false;</span><br><span class="line">     BufferBuilder bufferBuilder &#x3D; getBufferBuilder(targetChannel);</span><br><span class="line">     SerializationResult result &#x3D; serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">     while (result.isFullBuffer()) &#123;</span><br><span class="line">     &#x2F;&#x2F;buffer 写满了，调用 bufferBuilder.finish 方法</span><br><span class="line">        finishBufferBuilder(bufferBuilder);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If this was a full record, we are done. Not breaking out of the loop at this point</span><br><span class="line">        &#x2F;&#x2F; will lead to another buffer request before breaking out (that would not be a</span><br><span class="line">        &#x2F;&#x2F; problem per se, but it can lead to stalls in the pipeline).</span><br><span class="line">        if (result.isFullRecord()) &#123;</span><br><span class="line">           pruneTriggered &#x3D; true;</span><br><span class="line">           &#x2F;&#x2F;如果当前这条记录也完整输出了，清空bufferBuilder</span><br><span class="line">           emptyCurrentBufferBuilder(targetChannel);</span><br><span class="line">           break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前这条记录没有写完，申请新的 buffer 写入</span><br><span class="line">        bufferBuilder &#x3D; requestNewBufferBuilder(targetChannel);</span><br><span class="line">        result &#x3D; serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">     &#125;</span><br><span class="line">     checkState(!serializer.hasSerializedData(), &quot;All data should be written at once&quot;);</span><br><span class="line"></span><br><span class="line">     if (flushAlways) &#123;</span><br><span class="line">     &#x2F;&#x2F;强制刷新结果</span><br><span class="line">        flushTargetPartition(targetChannel);</span><br><span class="line">     &#125;</span><br><span class="line">     return pruneTriggered;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void finishBufferBuilder(BufferBuilder bufferBuilder) &#123;</span><br><span class="line">   numBytesOut.inc(bufferBuilder.finish());</span><br><span class="line">   numBuffersOut.inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChannelSelectorRecordWriter：</span><br><span class="line">public BufferBuilder getBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">   if (bufferBuilders[targetChannel] !&#x3D; null) &#123;</span><br><span class="line">      return bufferBuilders[targetChannel];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return requestNewBufferBuilder(targetChannel);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BroadcastRecordWriter：</span><br><span class="line">public BufferBuilder getBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		return bufferBuilder !&#x3D; null ? bufferBuilder : requestNewBufferBuilder(targetChannel);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>//请求新的 BufferBuilder，用于写入数据 如果当前没有可用的 buffer，会阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ChannelSelectorRecordWriter：</span><br><span class="line">public BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(bufferBuilders[targetChannel] &#x3D;&#x3D; null || bufferBuilders[targetChannel].isFinished());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从 LocalBufferPool 中请求 BufferBuilder</span><br><span class="line">		BufferBuilder bufferBuilder &#x3D; targetPartition.getBufferBuilder();</span><br><span class="line">		&#x2F;&#x2F;添加一个BufferConsumer，用于读取写入到 MemorySegment 的数据</span><br><span class="line">		targetPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(), targetChannel);</span><br><span class="line">		bufferBuilders[targetChannel] &#x3D; bufferBuilder;</span><br><span class="line">		return bufferBuilder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BroadcastRecordWriter：</span><br><span class="line">public BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(bufferBuilder &#x3D;&#x3D; null || bufferBuilder.isFinished());</span><br><span class="line"></span><br><span class="line">		BufferBuilder builder &#x3D; targetPartition.getBufferBuilder();</span><br><span class="line">		if (randomTriggered) &#123;</span><br><span class="line">			targetPartition.addBufferConsumer(builder.createBufferConsumer(), targetChannel);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try (BufferConsumer bufferConsumer &#x3D; builder.createBufferConsumer()) &#123;</span><br><span class="line">				for (int channel &#x3D; 0; channel &lt; numberOfChannels; channel++) &#123;</span><br><span class="line">					targetPartition.addBufferConsumer(bufferConsumer.copy(), channel);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bufferBuilder &#x3D; builder;</span><br><span class="line">		return builder;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>//从 LocalBufferPool 中请求 BufferBuilder调用ResultPartition的getBufferBuilder，ResultPartition实现了ResultPartitionWriter接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ResultPartition implements ResultPartitionWriter, BufferPoolOwner &#123;</span><br><span class="line"></span><br><span class="line">   protected static final Logger LOG &#x3D; LoggerFactory.getLogger(ResultPartition.class);</span><br><span class="line"></span><br><span class="line">   private final String owningTaskName;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionID partitionId;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Type of this partition. Defines the concrete subpartition implementation to use. *&#x2F;</span><br><span class="line">   protected final ResultPartitionType partitionType;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The subpartitions of this partition. At least one. *&#x2F;</span><br><span class="line">   protected final ResultSubpartition[] subpartitions;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionManager partitionManager;</span><br><span class="line"></span><br><span class="line">   public final int numTargetKeyGroups;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Runtime state --------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   private final AtomicBoolean isReleased &#x3D; new AtomicBoolean();</span><br><span class="line"></span><br><span class="line">   private BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">   private boolean isFinished;</span><br><span class="line"></span><br><span class="line">   private volatile Throwable cause;</span><br><span class="line"></span><br><span class="line">   private final FunctionWithException&lt;BufferPoolOwner, BufferPool, IOException&gt; bufferPoolFactory;</span><br></pre></td></tr></table></figure>

<p>ResultPartition.getBufferBuilder()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BufferBuilder getBufferBuilder() throws IOException, InterruptedException &#123;</span><br><span class="line">   checkInProduceState();</span><br><span class="line"></span><br><span class="line">   return bufferPool.requestBufferBuilderBlocking();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalBufferPool .requestBufferBuilderBlocking,请求MemorySegment内存资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BufferBuilder requestBufferBuilderBlocking() throws IOException, InterruptedException &#123;</span><br><span class="line">   return toBufferBuilder(requestMemorySegmentBlocking());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BufferBuilder toBufferBuilder(MemorySegment memorySegment) &#123;</span><br><span class="line">   if (memorySegment &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return new BufferBuilder(memorySegment, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private MemorySegment requestMemorySegmentBlocking() throws InterruptedException, IOException &#123;</span><br><span class="line">		MemorySegment segment;</span><br><span class="line">		while ((segment &#x3D; requestMemorySegment()) &#x3D;&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F; wait until available</span><br><span class="line">				getAvailableFuture().get();</span><br><span class="line">			&#125; catch (ExecutionException e) &#123;</span><br><span class="line">				LOG.error(&quot;The available future is completed exceptionally.&quot;, e);</span><br><span class="line">				ExceptionUtils.rethrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return segment;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition.addBufferConsumer()，向指定的 subpartition 添加一个 buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean addBufferConsumer(BufferConsumer bufferConsumer, int subpartitionIndex) throws IOException &#123;</span><br><span class="line">   checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">   ResultSubpartition subpartition;</span><br><span class="line">   try &#123;</span><br><span class="line">      checkInProduceState();</span><br><span class="line">      subpartition &#x3D; subpartitions[subpartitionIndex];</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception ex) &#123;</span><br><span class="line">      bufferConsumer.close();</span><br><span class="line">      throw ex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加 BufferConsumer，说明已经有数据生成了</span><br><span class="line">   return subpartition.add(bufferConsumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultPartition转交给ResultSubpartition添加bufferConsumer，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResultSubpartition &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** The index of the subpartition at the parent partition. *&#x2F;</span><br><span class="line">	protected final int index;</span><br><span class="line"></span><br><span class="line">	&#x2F;** The parent partition this subpartition belongs to. *&#x2F;</span><br><span class="line">	protected final ResultPartition parent;</span><br><span class="line"></span><br><span class="line">   public abstract boolean add(BufferConsumer bufferConsumer) throws IOException;</span><br></pre></td></tr></table></figure>

<p>对于stream的任务，实现类是PipelinedSubpartition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">class PipelinedSubpartition extends ResultSubpartition &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(PipelinedSubpartition.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** All buffers of this subpartition. Access to the buffers is synchronized on this object. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;当前 subpartiion 堆积的所有的 Buffer 的队列</span><br><span class="line">   private final ArrayDeque&lt;BufferConsumer&gt; buffers &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The number of non-event buffers currently in this subpartition. *&#x2F;</span><br><span class="line">   @GuardedBy(&quot;buffers&quot;)</span><br><span class="line">   &#x2F;&#x2F;当前 subpartiion 中堆积的 buffer 的数量</span><br><span class="line">   private int buffersInBacklog;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The read view to consume this subpartition. *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;用于消费写入的 Buffer</span><br><span class="line">   private PipelinedSubpartitionView readView;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether the subpartition has been finished. *&#x2F;</span><br><span class="line">   private boolean isFinished;</span><br><span class="line"></span><br><span class="line">   @GuardedBy(&quot;buffers&quot;)</span><br><span class="line">   private boolean flushRequested;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether the subpartition has been released. *&#x2F;</span><br><span class="line">   private volatile boolean isReleased;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The total number of buffers (both data and event buffers). *&#x2F;</span><br><span class="line">   private long totalNumberOfBuffers;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The total number of bytes (both data and event buffers). *&#x2F;</span><br><span class="line">   private long totalNumberOfBytes;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;index 是当前 sub-paritition 的索引</span><br><span class="line">   PipelinedSubpartition(int index, ResultPartition parent) &#123;</span><br><span class="line">      super(index, parent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean add(BufferConsumer bufferConsumer) &#123;</span><br><span class="line">      return add(bufferConsumer, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void finish() throws IOException &#123;</span><br><span class="line">      add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true);</span><br><span class="line">      LOG.debug(&quot;&#123;&#125;: Finished &#123;&#125;.&quot;, parent.getOwningTaskName(), this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加一个新的BufferConsumer</span><br><span class="line">	&#x2F;&#x2F;这个参数里的 finish 指的是整个 subpartition 都完成了</span><br><span class="line">   private boolean add(BufferConsumer bufferConsumer, boolean finish) &#123;</span><br><span class="line">      checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">      final boolean notifyDataAvailable;</span><br><span class="line">      synchronized (buffers) &#123;</span><br><span class="line">         if (isFinished || isReleased) &#123;</span><br><span class="line">            bufferConsumer.close();</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Add the bufferConsumer and update the stats</span><br><span class="line">         buffers.add(bufferConsumer);</span><br><span class="line">         updateStatistics(bufferConsumer);</span><br><span class="line">         &#x2F;&#x2F;更新 backlog 的数量，只有 buffer 才会使得 buffersInBacklog + 1，事件不会增加 buffersInBacklog</span><br><span class="line">         increaseBuffersInBacklog(bufferConsumer);</span><br><span class="line">         notifyDataAvailable &#x3D; shouldNotifyDataAvailable() || finish;</span><br><span class="line"></span><br><span class="line">         isFinished |&#x3D; finish;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (notifyDataAvailable) &#123;</span><br><span class="line">      &#x2F;&#x2F;通知数据可以被消费</span><br><span class="line">         notifyDataAvailable();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;只在第一个 buffer 为 finish 的时候才通知</span><br><span class="line">   private boolean shouldNotifyDataAvailable() &#123;</span><br><span class="line">		&#x2F;&#x2F; Notify only when we added first finished buffer.</span><br><span class="line">		return readView !&#x3D; null &amp;&amp; !flushRequested &amp;&amp; getNumberOfFinishedBuffers() &#x3D;&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知readView，有数据可用了</span><br><span class="line">	private void notifyDataAvailable() &#123;</span><br><span class="line">		if (readView !&#x3D; null) &#123;</span><br><span class="line">			readView.notifyDataAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">     public void flush() &#123;</span><br><span class="line">		final boolean notifyDataAvailable;</span><br><span class="line">		synchronized (buffers) &#123;</span><br><span class="line">			if (buffers.isEmpty()) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; if there is more then 1 buffer, we already notified the reader</span><br><span class="line">			&#x2F;&#x2F; (at the latest when adding the second buffer)</span><br><span class="line">			notifyDataAvailable &#x3D; !flushRequested &amp;&amp; buffers.size() &#x3D;&#x3D; 1 &amp;&amp; buffers.peek().isDataAvailable();</span><br><span class="line">			flushRequested &#x3D; flushRequested || buffers.size() &gt; 1 || notifyDataAvailable;</span><br><span class="line">		&#125;</span><br><span class="line">		if (notifyDataAvailable) &#123;</span><br><span class="line">			notifyDataAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在强制进行 flush 的时候，也会发出数据可用的通知。这是因为，假如产出的数据记录较少无法完整地填充一个 <code>MemorySegment</code>，那么 <code>ResultSubpartition</code> 可能会一直处于不可被消费的状态。而为了保证产出的记录能够及时被消费，就需要及时进行 flush，从而确保下游能更及时地处理数据。在 <code>RecordWriter</code> 中有一个 <code>OutputFlusher</code> 会定时触发 flush，间隔可以通过 <code>DataStream.setBufferTimeout()</code> 来控制。</p>
<p>写入的 Buffer 最终被保存在 <code>ResultSubpartition</code> 中维护的一个队列中，如果需要消费这些 Buffer，就需要依赖 <code>ResultSubpartitionView</code>。当需要消费一个 <code>ResultSubpartition</code> 的结果时，需要创建一个 <code>ResultSubpartitionView</code> 对象，并关联到 <code>ResultSubpartition</code> 中；当数据可以被消费时，会通过对应的回调接口告知 <code>ResultSubpartitionView</code></p>
<p>对于stream，PipelinedSubpartitionView实现了ResultSubpartitionView的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class PipelinedSubpartitionView implements ResultSubpartitionView &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The subpartition this view belongs to. *&#x2F;</span><br><span class="line">   private final PipelinedSubpartition parent;</span><br><span class="line"></span><br><span class="line">   private final BufferAvailabilityListener availabilityListener;</span><br><span class="line"></span><br><span class="line">   &#x2F;** Flag indicating whether this view has been released. *&#x2F;</span><br><span class="line">   private final AtomicBoolean isReleased;</span><br><span class="line"></span><br><span class="line">   PipelinedSubpartitionView(PipelinedSubpartition parent, BufferAvailabilityListener listener) &#123;</span><br><span class="line">      this.parent &#x3D; checkNotNull(parent);</span><br><span class="line">      this.availabilityListener &#x3D; checkNotNull(listener);</span><br><span class="line">      this.isReleased &#x3D; new AtomicBoolean();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Nullable</span><br><span class="line">   @Override</span><br><span class="line">   public BufferAndBacklog getNextBuffer() &#123;</span><br><span class="line">      return parent.pollBuffer();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void notifyDataAvailable() &#123;</span><br><span class="line">   &#x2F;&#x2F;回调接口</span><br><span class="line">      availabilityListener.notifyDataAvailable();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们已经了解了一个 Task 如何输出结果到 <code>ResultPartition</code> 中，以及如何去消费不同 <code>ResultSubpartition</code> 中的这些用于保存序列化结果的 Buffer。</p>
<p>继续看task的数据输入，availabilityListener.notifyDataAvailable()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface BufferAvailabilityListener &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Called whenever there might be new data available.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void notifyDataAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferAvailabilityListener有多种实现，如果一个 <code>InputChannel</code> 和其消费的上游 <code>ResultPartition</code> 所属 Task 都在同一个 TaskManager 中运行，那么它们之间的数据交换就在同一个 JVM 进程内不同线程之间进行，无需通过网络交换。也就是<code>LocalInputChannel</code>，LocalInputChannel继承自BufferAvailabilityListener</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInputChannel extends InputChannel implements BufferAvailabilityListener &#123;  </span><br><span class="line">   public void notifyDataAvailable() &#123;</span><br><span class="line">		notifyChannelNonEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后回调了InputChannel的notifyChannelNonEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void notifyChannelNonEmpty() &#123;</span><br><span class="line">   inputGate.notifyChannelNonEmpty(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>InputChannel</code> 和该 Task 需要消费的 <code>ResultSubpartition</code> 是一一对应的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputChannel &#123;</span><br><span class="line"></span><br><span class="line">   protected final int channelIndex;</span><br><span class="line"></span><br><span class="line">   protected final ResultPartitionID partitionId;</span><br><span class="line"></span><br><span class="line">   protected final SingleInputGate inputGate;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Asynchronous error notification --------------------------------------</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;Throwable&gt; cause &#x3D; new AtomicReference&lt;Throwable&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; - Partition request backoff --------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;** The initial backoff (in ms). *&#x2F;</span><br><span class="line">   private final int initialBackoff;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The maximum backoff (in ms). *&#x2F;</span><br><span class="line">   private final int maxBackoff;</span><br><span class="line"></span><br><span class="line">   protected final Counter numBytesIn;</span><br><span class="line"></span><br><span class="line">   protected final Counter numBuffersIn;</span><br><span class="line"></span><br><span class="line">   &#x2F;** The current backoff (in ms). *&#x2F;</span><br><span class="line">   private int currentBackoff;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   protected void notifyChannelNonEmpty() &#123;</span><br><span class="line">      inputGate.notifyChannelNonEmpty(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再调用inputGate的notifyChannelNonEmpty，Task 的输入被抽象为 <code>InputGate</code>, 而 <code>InputGate</code> 则由 <code>InputChannel</code> 组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputGate implements PullingAsyncDataInput&lt;BufferOrEvent&gt;, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">   protected final AvailabilityHelper availabilityHelper &#x3D; new AvailabilityHelper();</span><br><span class="line"></span><br><span class="line">   public abstract int getNumberOfInputChannels();</span><br><span class="line"></span><br><span class="line">   public abstract boolean isFinished();</span><br><span class="line">阻塞调用</span><br><span class="line">   public abstract Optional&lt;BufferOrEvent&gt; getNext() throws IOException, InterruptedException;</span><br><span class="line">非阻塞调用</span><br><span class="line">   public abstract Optional&lt;BufferOrEvent&gt; pollNext() throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line">   public abstract void sendTaskEvent(TaskEvent event) throws IOException;</span><br></pre></td></tr></table></figure>

<p>InputGate的实现类是SingleInputGate，进入SingleInputGate的notifyChannelNonEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInputGate extends InputGate &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;该 InputGate 包含的所有 InputChannel</span><br><span class="line">	private final Map&lt;IntermediateResultPartitionID, InputChannel&gt; inputChannels;</span><br><span class="line"></span><br><span class="line">	&#x2F;** Channels, which notified this input gate about available data. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;InputChannel 构成的队列，这些 InputChannel 中都有有可供消费的数据</span><br><span class="line">	private final ArrayDeque&lt;InputChannel&gt; inputChannelsWithData &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;用于接收输入的缓冲池</span><br><span class="line">	private BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当一个 InputChannel 有数据时的回调</span><br><span class="line">    void notifyChannelNonEmpty(InputChannel channel) &#123;</span><br><span class="line">        queueChannel(checkNotNull(channel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将新的channel加入队列</span><br><span class="line">    private void queueChannel(InputChannel channel) &#123;</span><br><span class="line">		int availableChannels;</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;?&gt; toNotify &#x3D; null;</span><br><span class="line"></span><br><span class="line">		synchronized (inputChannelsWithData) &#123;</span><br><span class="line">		&#x2F;&#x2F;判断这个channel是否已经在队列中</span><br><span class="line">			if (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			availableChannels &#x3D; inputChannelsWithData.size();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;加入队列</span><br><span class="line">			inputChannelsWithData.add(channel);</span><br><span class="line">			enqueuedInputChannelsWithData.set(channel.getChannelIndex());</span><br><span class="line"></span><br><span class="line">			if (availableChannels &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果之前队列中没有channel，这个channel加入后，通知等待的线程</span><br><span class="line">				inputChannelsWithData.notifyAll();</span><br><span class="line">				toNotify &#x3D; availabilityHelper.getUnavailableToResetAvailable();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (toNotify !&#x3D; null) &#123;</span><br><span class="line">			toNotify.complete(null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;在task启动的setupPartitionsAndGates里调用</span><br><span class="line">@Override</span><br><span class="line">	public void setup() throws IOException, InterruptedException &#123;</span><br><span class="line">		checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in input gate setup logic: Already registered buffer pool.&quot;);</span><br><span class="line">		&#x2F;&#x2F; assign exclusive buffers to input channels directly and use the rest for floating buffers</span><br><span class="line">		assignExclusiveSegments();</span><br><span class="line"></span><br><span class="line">		BufferPool bufferPool &#x3D; bufferPoolFactory.get();</span><br><span class="line">		setBufferPool(bufferPool);</span><br><span class="line"></span><br><span class="line">		requestPartitions();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@VisibleForTesting</span><br><span class="line">	void requestPartitions() throws IOException, InterruptedException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">		&#x2F;&#x2F;只请求一次</span><br><span class="line">			if (!requestedPartitionsFlag) &#123;</span><br><span class="line">				if (closeFuture.isDone()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Already released.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Sanity checks</span><br><span class="line">				if (numberOfInputChannels !&#x3D; inputChannels.size()) &#123;</span><br><span class="line">					throw new IllegalStateException(String.format(</span><br><span class="line">						&quot;Bug in input gate setup logic: mismatch between &quot; +</span><br><span class="line">						&quot;number of total input channels [%s] and the currently set number of input &quot; +</span><br><span class="line">						&quot;channels [%s].&quot;,</span><br><span class="line">						inputChannels.size(),</span><br><span class="line">						numberOfInputChannels));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">				&#x2F;&#x2F;每一个channel都请求对应的子分区</span><br><span class="line">					inputChannel.requestSubpartition(consumedSubpartitionIndex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			requestedPartitionsFlag &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>回调之后开启了InputChannel的消费周期，requestSubpartition，getNextBuffer，releaseAllResources</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException, InterruptedException;</span><br><span class="line"></span><br><span class="line">abstract void releaseAllResources() throws IOException;</span><br></pre></td></tr></table></figure>

<p>在LocalInputChannel中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求消费对应的子分区</span><br><span class="line">void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   boolean retriggerRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The lock is required to request only once in the presence of retriggered requests.</span><br><span class="line">   synchronized (requestLock) &#123;</span><br><span class="line">      checkState(!isReleased, &quot;LocalInputChannel has been released already&quot;);</span><br><span class="line"></span><br><span class="line">      if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">         LOG.debug(&quot;&#123;&#125;: Requesting LOCAL subpartition &#123;&#125; of partition &#123;&#125;.&quot;,</span><br><span class="line">            this, subpartitionIndex, partitionId);</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">         &#x2F;&#x2F;Local，无需网络通信，通过 ResultPartitionManager 创建一个 ResultSubpartitionView</span><br><span class="line">					&#x2F;&#x2F;LocalInputChannel 实现了 BufferAvailabilityListener</span><br><span class="line">					&#x2F;&#x2F;在有数据时会得到通知，notifyDataAvailable 会被调用，进而将当前 channel 加到 InputGate 的可用 Channel 队列中</span><br><span class="line">            ResultSubpartitionView subpartitionView &#x3D; partitionManager.createSubpartitionView(</span><br><span class="line">               partitionId, subpartitionIndex, this);</span><br><span class="line"></span><br><span class="line">            if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">               throw new IOException(&quot;Error requesting subpartition.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; make the subpartition view visible</span><br><span class="line">            this.subpartitionView &#x3D; subpartitionView;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; check if the channel was released in the meantime</span><br><span class="line">            if (isReleased) &#123;</span><br><span class="line">               subpartitionView.releaseAllResources();</span><br><span class="line">               this.subpartitionView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; catch (PartitionNotFoundException notFound) &#123;</span><br><span class="line">            if (increaseBackoff()) &#123;</span><br><span class="line">               retriggerRequest &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               throw notFound;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Do this outside of the lock scope as this might lead to a</span><br><span class="line">   &#x2F;&#x2F; deadlock with a concurrent release of the channel via the</span><br><span class="line">   &#x2F;&#x2F; input gate.</span><br><span class="line">   if (retriggerRequest) &#123;</span><br><span class="line">      inputGate.retriggerPartitionRequest(partitionId.getPartitionId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取数据，借助 ResultSubparitionView 消费 ResultSubparition 中的数据</span><br><span class="line">Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException, InterruptedException &#123;</span><br><span class="line">		checkError();</span><br><span class="line"></span><br><span class="line">		ResultSubpartitionView subpartitionView &#x3D; this.subpartitionView;</span><br><span class="line">		if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F; There is a possible race condition between writing a EndOfPartitionEvent (1) and flushing (3) the Local</span><br><span class="line">			&#x2F;&#x2F; channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush notification (4). When</span><br><span class="line">			&#x2F;&#x2F; they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue LocalInputChannel after (or</span><br><span class="line">			&#x2F;&#x2F; during) it was released during reading the EndOfPartitionEvent (2).</span><br><span class="line">			if (isReleased) &#123;</span><br><span class="line">				return Optional.empty();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; this can happen if the request for the partition was triggered asynchronously</span><br><span class="line">			&#x2F;&#x2F; by the time trigger</span><br><span class="line">			&#x2F;&#x2F; would be good to avoid that, by guaranteeing that the requestPartition() and</span><br><span class="line">			&#x2F;&#x2F; getNextBuffer() always come from the same thread</span><br><span class="line">			&#x2F;&#x2F; we could do that by letting the timer insert a special &quot;requesting channel&quot; into the input gate&#39;s queue</span><br><span class="line">			subpartitionView &#x3D; checkAndWaitForSubpartitionView();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过 ResultSubparitionView 获取</span><br><span class="line">		BufferAndBacklog next &#x3D; subpartitionView.getNextBuffer();</span><br><span class="line"></span><br><span class="line">		if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (subpartitionView.isReleased()) &#123;</span><br><span class="line">				throw new CancelTaskException(&quot;Consumed partition &quot; + subpartitionView + &quot; has been released.&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return Optional.empty();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		numBytesIn.inc(next.buffer().getSize());</span><br><span class="line">		numBuffersIn.inc();</span><br><span class="line">		return Optional.of(new BufferAndAvailability(next.buffer(), next.isMoreAvailable(), next.buffersInBacklog()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用PipelinedSubpartitionView的getNextBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   @Override</span><br><span class="line">   public BufferAndBacklog getNextBuffer() &#123;</span><br><span class="line">      return parent.pollBuffer();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">BufferAndBacklog pollBuffer() &#123;</span><br><span class="line">   synchronized (buffers) &#123;</span><br><span class="line">      Buffer buffer &#x3D; null;</span><br><span class="line"></span><br><span class="line">      if (buffers.isEmpty()) &#123;</span><br><span class="line">         flushRequested &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      while (!buffers.isEmpty()) &#123;</span><br><span class="line">         BufferConsumer bufferConsumer &#x3D; buffers.peek();</span><br><span class="line"></span><br><span class="line">         buffer &#x3D; bufferConsumer.build();</span><br><span class="line"></span><br><span class="line">         checkState(bufferConsumer.isFinished() || buffers.size() &#x3D;&#x3D; 1,</span><br><span class="line">            &quot;When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.&quot;);</span><br><span class="line"></span><br><span class="line">         if (buffers.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; turn off flushRequested flag if we drained all of the available data</span><br><span class="line">            flushRequested &#x3D; false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (bufferConsumer.isFinished()) &#123;</span><br><span class="line">            buffers.pop().close();</span><br><span class="line">            decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (buffer.readableBytes() &gt; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">         buffer.recycleBuffer();</span><br><span class="line">         buffer &#x3D; null;</span><br><span class="line">         if (!bufferConsumer.isFinished()) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (buffer &#x3D;&#x3D; null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      updateStatistics(buffer);</span><br><span class="line">      &#x2F;&#x2F; Do not report last remaining buffer on buffers as available to read (assuming it&#39;s unfinished).</span><br><span class="line">      &#x2F;&#x2F; It will be reported for reading either on flush or when the number of buffers in the queue</span><br><span class="line">      &#x2F;&#x2F; will be 2 or more.</span><br><span class="line">      return new BufferAndBacklog(</span><br><span class="line">         buffer,</span><br><span class="line">         isAvailableUnsafe(),</span><br><span class="line">         getBuffersInBacklog(),</span><br><span class="line">         nextBufferIsEventUnsafe());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已上是task内部的数据传递，再看下task之间的数据传递，涉及到网络协议</p>
<p>在Task启动的时候，会调用inputgate的setup方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void setupPartitionsAndGates(</span><br><span class="line">   ResultPartitionWriter[] producedPartitions, InputGate[] inputGates) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">   for (ResultPartitionWriter partition : producedPartitions) &#123;</span><br><span class="line">      partition.setup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; InputGates must be initialized after the partitions, since during InputGate#setup</span><br><span class="line">   &#x2F;&#x2F; we are requesting partitions</span><br><span class="line">   for (InputGate gate : inputGates) &#123;</span><br><span class="line">      gate.setup();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingleInputGate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void setup() throws IOException, InterruptedException &#123;</span><br><span class="line">   checkState(this.bufferPool &#x3D;&#x3D; null, &quot;Bug in input gate setup logic: Already registered buffer pool.&quot;);</span><br><span class="line">   &#x2F;&#x2F; assign exclusive buffers to input channels directly and use the rest for floating buffers</span><br><span class="line">   assignExclusiveSegments();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分配 LocalBufferPool 本地缓冲池，这是所有 channel 共享的</span><br><span class="line">   BufferPool bufferPool &#x3D; bufferPoolFactory.get();</span><br><span class="line">   setBufferPool(bufferPool);</span><br><span class="line"></span><br><span class="line">   requestPartitions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void assignExclusiveSegments() throws IOException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">			for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">				if (inputChannel instanceof RemoteInputChannel) &#123;</span><br><span class="line">				&#x2F;&#x2F;RemoteInputChannel 请求独占的 buffer</span><br><span class="line">					((RemoteInputChannel) inputChannel).assignExclusiveSegments();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">void requestPartitions() throws IOException, InterruptedException &#123;</span><br><span class="line">		synchronized (requestLock) &#123;</span><br><span class="line">			if (!requestedPartitionsFlag) &#123;</span><br><span class="line">				if (closeFuture.isDone()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Already released.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Sanity checks</span><br><span class="line">				if (numberOfInputChannels !&#x3D; inputChannels.size()) &#123;</span><br><span class="line">					throw new IllegalStateException(String.format(</span><br><span class="line">						&quot;Bug in input gate setup logic: mismatch between &quot; +</span><br><span class="line">						&quot;number of total input channels [%s] and the currently set number of input &quot; +</span><br><span class="line">						&quot;channels [%s].&quot;,</span><br><span class="line">						inputChannels.size(),</span><br><span class="line">						numberOfInputChannels));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				for (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">					inputChannel.requestSubpartition(consumedSubpartitionIndex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			requestedPartitionsFlag &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteInputChannel 管理可用 buffer</p>
<p>在 <code>RemoteInputChannel</code> 内部使用 <code>AvailableBufferQueue</code> 来管理所有可用的 buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分配独占的 buffer</span><br><span class="line">void assignExclusiveSegments() throws IOException &#123;</span><br><span class="line">   checkState(initialCredit &#x3D;&#x3D; 0, &quot;Bug in input channel setup logic: exclusive buffers have &quot; +</span><br><span class="line">      &quot;already been set for this input channel.&quot;);</span><br><span class="line"></span><br><span class="line">   Collection&lt;MemorySegment&gt; segments &#x3D; checkNotNull(memorySegmentProvider.requestMemorySegments());</span><br><span class="line">   checkArgument(!segments.isEmpty(), &quot;The number of exclusive buffers per channel should be larger than 0.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始的Credit</span><br><span class="line">   initialCredit &#x3D; segments.size();</span><br><span class="line">   numRequiredBuffers &#x3D; segments.size();</span><br><span class="line"></span><br><span class="line">   synchronized (bufferQueue) &#123;</span><br><span class="line">      for (MemorySegment segment : segments) &#123;</span><br><span class="line">      &#x2F;&#x2F;注意这个 NetworkBuffer 的回收器是 RemoteInputChannel 自身</span><br><span class="line">         bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AvailableBufferQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static class AvailableBufferQueue &#123;</span><br><span class="line">&#x2F;&#x2F;添加一个独占的buffer，如果当前可用的 buffer 总量超出了要求的数量，则向本地缓冲池归还一个流动的buffer</span><br><span class="line">		&#x2F;&#x2F;返回值是新增的 buffer 数量</span><br><span class="line">   int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) &#123;</span><br><span class="line">			exclusiveBuffers.add(buffer);</span><br><span class="line">			if (getAvailableBufferSize() &gt; numRequiredBuffers) &#123;</span><br><span class="line">				Buffer floatingBuffer &#x3D; floatingBuffers.poll();</span><br><span class="line">				floatingBuffer.recycleBuffer();</span><br><span class="line">				&#x2F;&#x2F;加一个，归还一个，相当于没加</span><br><span class="line">				return 0;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NetworkBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void recycleBuffer() &#123;</span><br><span class="line">&#x2F;&#x2F;最终调用deallocate</span><br><span class="line">   release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void deallocate() &#123;</span><br><span class="line">&#x2F;&#x2F;调用RemoteInputChannel 的recycle</span><br><span class="line">		recycler.recycle(memorySegment);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteInputChannel.recycle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;独占的 buffer 释放后会直接被 RemoteInputChannel 回收</span><br><span class="line">public void recycle(MemorySegment segment) &#123;</span><br><span class="line">   int numAddedBuffers;</span><br><span class="line"></span><br><span class="line">   synchronized (bufferQueue) &#123;</span><br><span class="line">      &#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">      &#x2F;&#x2F; after releaseAllResources() released all buffers (see below for details).</span><br><span class="line">      if (isReleased.get()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            &#x2F;&#x2F;如果这个 channle 已经被释放，这个 MemorySegment 会被归还给 NetworkBufferPoolmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));</span><br><span class="line">            return;</span><br><span class="line">         &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.rethrow(t);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;重新加入到 AvailableBufferQueue 中</span><br><span class="line">      numAddedBuffers &#x3D; bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (numAddedBuffers &gt; 0 &amp;&amp; unannouncedCredit.getAndAdd(numAddedBuffers) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      notifyCreditAvailable();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面SingleInputGate的requestPartitions方法里会调用inputChannel.requestSubpartition请求远端子分区，在RemoteInputChannel中的实现如下，会创建一个 <code>PartitionRequestClient</code>，并通过 Netty 发送 <code>PartitionRequest</code> 请求，这时会带上当前 InputChannel 的 id 和初始的 credit 信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException &#123;</span><br><span class="line">&#x2F;&#x2F;REMOTE，需要网络通信，使用 Netty 建立网络</span><br><span class="line">&#x2F;&#x2F;通过 ConnectionManager 来建立连接：创建 PartitionRequestClient，通过 PartitionRequestClient 发起请求</span><br><span class="line">   if (partitionRequestClient &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; Create a client and request the partition</span><br><span class="line">      try &#123;</span><br><span class="line">         partitionRequestClient &#x3D; connectionManager.createPartitionRequestClient(connectionId);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">         &#x2F;&#x2F; IOExceptions indicate that we could not open a connection to the remote TaskExecutor</span><br><span class="line">         throw new PartitionConnectionException(partitionId, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求分区，通过 netty 发起请求</span><br><span class="line">      partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyConnectionManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public PartitionRequestClient createPartitionRequestClient(ConnectionID connectionId)</span><br><span class="line">      throws IOException, InterruptedException &#123;</span><br><span class="line">      &#x2F;&#x2F;这里实际上会建立和其它 Task 的 Server 的连接</span><br><span class="line">		&#x2F;&#x2F;返回的 PartitionRequestClient 中封装了 netty channel 和 channel handler</span><br><span class="line">   return partitionRequestClientFactory.createPartitionRequestClient(connectionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PartitionRequestClientFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">NettyPartitionRequestClient createPartitionRequestClient(ConnectionID connectionId) throws IOException, InterruptedException &#123;</span><br><span class="line">   Object entry;</span><br><span class="line">   NettyPartitionRequestClient client &#x3D; null;</span><br><span class="line"></span><br><span class="line">   while (client &#x3D;&#x3D; null) &#123;</span><br><span class="line">      entry &#x3D; clients.get(connectionId);</span><br><span class="line"></span><br><span class="line">      if (entry !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;连接已经建立</span><br><span class="line">         &#x2F;&#x2F; Existing channel or connecting channel</span><br><span class="line">         if (entry instanceof NettyPartitionRequestClient) &#123;</span><br><span class="line">            client &#x3D; (NettyPartitionRequestClient) entry;</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            ConnectingChannel future &#x3D; (ConnectingChannel) entry;</span><br><span class="line">            client &#x3D; future.waitForChannel();</span><br><span class="line"></span><br><span class="line">            clients.replace(connectionId, future, client);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; No channel yet. Create one, but watch out for a race.</span><br><span class="line">         &#x2F;&#x2F; We create a &quot;connecting future&quot; and atomically add it to the map.</span><br><span class="line">         &#x2F;&#x2F; Only the thread that really added it establishes the channel.</span><br><span class="line">         &#x2F;&#x2F; The others need to wait on that original establisher&#39;s future.</span><br><span class="line">         &#x2F;&#x2F; 连接创建成功后会回调 handInChannel 方法</span><br><span class="line">         ConnectingChannel connectingChannel &#x3D; new ConnectingChannel(connectionId, this);</span><br><span class="line">         Object old &#x3D; clients.putIfAbsent(connectionId, connectingChannel);</span><br><span class="line"></span><br><span class="line">         if (old &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;连接到 Netty Server</span><br><span class="line">          nettyClient.connect(connectionId.getAddress()).addListener(connectingChannel);</span><br><span class="line"></span><br><span class="line">            client &#x3D; connectingChannel.waitForChannel();</span><br><span class="line"></span><br><span class="line">            clients.replace(connectionId, connectingChannel, client);</span><br><span class="line">         &#125;</span><br><span class="line">         else if (old instanceof ConnectingChannel) &#123;</span><br><span class="line">            client &#x3D; ((ConnectingChannel) old).waitForChannel();</span><br><span class="line">            clients.replace(connectionId, old, client);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            client &#x3D; (NettyPartitionRequestClient) old;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Make sure to increment the reference count before handing a client</span><br><span class="line">      &#x2F;&#x2F; out to ensure correct bookkeeping for channel closing.</span><br><span class="line">      if (!client.incrementReferenceCounter()) &#123;</span><br><span class="line">         destroyPartitionRequestClient(connectionId, client);</span><br><span class="line">         client &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了PartitionRequestClient之后，发送请求，调用partitionRequestClient的requestSubpartition，PartitionRequestClient接口的实现类是NettyPartitionRequestClient，进入NettyPartitionRequestClient的requestSubpartition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void requestSubpartition(</span><br><span class="line">      final ResultPartitionID partitionId,</span><br><span class="line">      final int subpartitionIndex,</span><br><span class="line">      final RemoteInputChannel inputChannel,</span><br><span class="line">      int delayMs) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">   checkNotClosed();</span><br><span class="line"></span><br><span class="line">   LOG.debug(&quot;Requesting subpartition &#123;&#125; of partition &#123;&#125; with &#123;&#125; ms delay.&quot;,</span><br><span class="line">         subpartitionIndex, partitionId, delayMs);</span><br><span class="line">&#x2F;&#x2F;向 NetworkClientHandler 注册当前 RemoteInputChannel</span><br><span class="line">		&#x2F;&#x2F;单个 Task 所有的 RemoteInputChannel 的数据传输都通过这个 PartitionRequestClient 处理</span><br><span class="line">   clientHandler.addInputChannel(inputChannel);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PartitionRequest封装了请求的 sub-partition 的信息，当前 input channel 的 ID，以及初始 credit</span><br><span class="line">   final PartitionRequest request &#x3D; new PartitionRequest(</span><br><span class="line">         partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求的监听</span><br><span class="line">   final ChannelFutureListener listener &#x3D; new ChannelFutureListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">         if (!future.isSuccess()) &#123;</span><br><span class="line">         &#x2F;&#x2F;如果请求发送失败，要移除当前的 inputChannel</span><br><span class="line">            clientHandler.removeInputChannel(inputChannel);</span><br><span class="line">            SocketAddress remoteAddr &#x3D; future.channel().remoteAddress();</span><br><span class="line">            inputChannel.onError(</span><br><span class="line">                  new LocalTransportException(</span><br><span class="line">                     String.format(&quot;Sending the partition request to &#39;%s&#39; failed.&quot;, remoteAddr),</span><br><span class="line">                     future.channel().localAddress(), future.cause()</span><br><span class="line">                  ));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 netty 发送请求</span><br><span class="line">   if (delayMs &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      ChannelFuture f &#x3D; tcpChannel.writeAndFlush(request);</span><br><span class="line">      f.addListener(listener);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      final ChannelFuture[] f &#x3D; new ChannelFuture[1];</span><br><span class="line">      tcpChannel.eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            f[0] &#x3D; tcpChannel.writeAndFlush(request);</span><br><span class="line">            f[0].addListener(listener);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, delayMs, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是生产者和消费者各自的处理流程</p>
<p>生产者端即 <code>ResultSubpartition</code> 一侧，在网络通信中对应 <code>NettyServer</code>。<code>NettyServer</code> 有两个重要的 <code>ChannelHandler</code>，即 <code>PartitionRequestServerHandler</code> 和 <code>PartitionRequestQueue</code>。其中，<code>PartitionRequestServerHandler</code> 负责处理消费端通过 <code>PartitionRequestClient</code> 发送的 <code>PartitionRequest</code> 和 <code>AddCredit</code> 等请求；<code>PartitionRequestQueue</code> 则包含了一个可以从中读取数据的 <code>NetworkSequenceViewReader</code> 队列，它会监听 Netty Channel 的可写入状态，一旦可以写入数据，就会从 <code>NetworkSequenceViewReader</code> 消费数据写入 Netty Channel。</p>
<p>消费端即 <code>RemoteInputChannel</code> 一侧，在网络通信中对应 <code>NettyClient</code></p>
<p>而<code>NettyServer</code>和<code>NettyClient</code>是在启动TaskManager的startTaskManager过程中创建的，TaskManagerServices.fromConfiguration最终调用NettyConnectionManager的start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int start() throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F;初始化 Netty Client</span><br><span class="line">   client.init(nettyProtocol, bufferPool);</span><br><span class="line">&#x2F;&#x2F;初始化并启动 Netty Server</span><br><span class="line">   return server.init(nettyProtocol, bufferPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyClient：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException &#123;</span><br><span class="line">   checkState(bootstrap &#x3D;&#x3D; null, &quot;Netty client has already been initialized.&quot;);</span><br><span class="line"></span><br><span class="line">   this.protocol &#x3D; protocol;</span><br><span class="line"></span><br><span class="line">   final long start &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">   bootstrap &#x3D; new Bootstrap();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Transport-specific configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   switch (config.getTransportType()) &#123;</span><br><span class="line">      case NIO:</span><br><span class="line">         initNioBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case EPOLL:</span><br><span class="line">         initEpollBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case AUTO:</span><br><span class="line">         if (Epoll.isAvailable()) &#123;</span><br><span class="line">            initEpollBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using EPOLL.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            initNioBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using NIO.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bootstrap.option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line">   bootstrap.option(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Timeout for new connections</span><br><span class="line">   bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getClientConnectTimeoutSeconds() * 1000);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Pooled allocator for Netty&#39;s ByteBuf instances</span><br><span class="line">   bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Receive and send buffer size</span><br><span class="line">   int receiveAndSendBufferSize &#x3D; config.getSendAndReceiveBufferSize();</span><br><span class="line">   if (receiveAndSendBufferSize &gt; 0) &#123;</span><br><span class="line">      bootstrap.option(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize);</span><br><span class="line">      bootstrap.option(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      clientSSLFactory &#x3D; config.createClientSSLEngineFactory();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new IOException(&quot;Failed to initialize SSL Context for the Netty client&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">   LOG.info(&quot;Successful initialization (took &#123;&#125; ms).&quot;, duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyServer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">int init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException &#123;</span><br><span class="line">   return init(</span><br><span class="line">      nettyBufferPool,</span><br><span class="line">      sslHandlerFactory -&gt; new ServerChannelInitializer(protocol, sslHandlerFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int init(</span><br><span class="line">      NettyBufferPool nettyBufferPool,</span><br><span class="line">      Function&lt;SSLHandlerFactory, ServerChannelInitializer&gt; channelInitializer) throws IOException &#123;</span><br><span class="line">   checkState(bootstrap &#x3D;&#x3D; null, &quot;Netty server has already been initialized.&quot;);</span><br><span class="line"></span><br><span class="line">   final long start &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">   bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Transport-specific configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   switch (config.getTransportType()) &#123;</span><br><span class="line">      case NIO:</span><br><span class="line">         initNioBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case EPOLL:</span><br><span class="line">         initEpollBootstrap();</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">      case AUTO:</span><br><span class="line">         if (Epoll.isAvailable()) &#123;</span><br><span class="line">            initEpollBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using EPOLL.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            initNioBootstrap();</span><br><span class="line">            LOG.info(&quot;Transport type &#39;auto&#39;: using NIO.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Configuration</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Server bind address</span><br><span class="line">   bootstrap.localAddress(config.getServerAddress(), config.getServerPort());</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Pooled allocators for Netty&#39;s ByteBuf instances</span><br><span class="line">   bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line">   bootstrap.childOption(ChannelOption.ALLOCATOR, nettyBufferPool);</span><br><span class="line"></span><br><span class="line">   if (config.getServerConnectBacklog() &gt; 0) &#123;</span><br><span class="line">      bootstrap.option(ChannelOption.SO_BACKLOG, config.getServerConnectBacklog());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Receive and send buffer size</span><br><span class="line">   int receiveAndSendBufferSize &#x3D; config.getSendAndReceiveBufferSize();</span><br><span class="line">   if (receiveAndSendBufferSize &gt; 0) &#123;</span><br><span class="line">      bootstrap.childOption(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize);</span><br><span class="line">      bootstrap.childOption(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Low and high water marks for flow control</span><br><span class="line">   &#x2F;&#x2F; hack around the impossibility (in the current netty version) to set both watermarks at</span><br><span class="line">   &#x2F;&#x2F; the same time:</span><br><span class="line">   final int defaultHighWaterMark &#x3D; 64 * 1024; &#x2F;&#x2F; from DefaultChannelConfig (not exposed)</span><br><span class="line">   final int newLowWaterMark &#x3D; config.getMemorySegmentSize() + 1;</span><br><span class="line">   final int newHighWaterMark &#x3D; 2 * config.getMemorySegmentSize();</span><br><span class="line">   &#x2F;&#x2F;配置水位线，确保不往网络中写入太多数据</span><br><span class="line">		&#x2F;&#x2F;当输出缓冲中的字节数超过高水位值, 则 Channel.isWritable() 会返回false</span><br><span class="line">		&#x2F;&#x2F;当输出缓存中的字节数低于低水位值, 则 Channel.isWritable() 会重新返回true</span><br><span class="line">		&#x2F;&#x2F;背压就是这么产生的</span><br><span class="line">   if (newLowWaterMark &gt; defaultHighWaterMark) &#123;</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, newHighWaterMark);</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, newLowWaterMark);</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; including (newHighWaterMark &lt; defaultLowWaterMark)</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, newLowWaterMark);</span><br><span class="line">      bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, newHighWaterMark);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; SSL related configuration</span><br><span class="line">   final SSLHandlerFactory sslHandlerFactory;</span><br><span class="line">   try &#123;</span><br><span class="line">      sslHandlerFactory &#x3D; config.createServerSSLEngineFactory();</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new IOException(&quot;Failed to initialize SSL Context for the Netty Server&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Child channel pipeline for accepted connections</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bootstrap.childHandler(channelInitializer.apply(sslHandlerFactory));</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; Start Server</span><br><span class="line">   &#x2F;&#x2F; --------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   bindFuture &#x3D; bootstrap.bind().syncUninterruptibly();</span><br><span class="line"></span><br><span class="line">   localAddress &#x3D; (InetSocketAddress) bindFuture.channel().localAddress();</span><br><span class="line"></span><br><span class="line">   final long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">   LOG.info(&quot;Successful initialization (took &#123;&#125; ms). Listening on SocketAddress &#123;&#125;.&quot;, duration, localAddress);</span><br><span class="line"></span><br><span class="line">   return localAddress.getPort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而参数NettyProtocol类提供了 <code>NettyClient</code> 和 <code>NettyServer</code> 引导启动注册的一系列 Channel Handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public class NettyProtocol &#123;</span><br><span class="line"></span><br><span class="line">   private final NettyMessage.NettyMessageEncoder</span><br><span class="line">      messageEncoder &#x3D; new NettyMessage.NettyMessageEncoder();</span><br><span class="line"></span><br><span class="line">   private final ResultPartitionProvider partitionProvider;</span><br><span class="line">   private final TaskEventPublisher taskEventPublisher;</span><br><span class="line"></span><br><span class="line">   NettyProtocol(ResultPartitionProvider partitionProvider, TaskEventPublisher taskEventPublisher) &#123;</span><br><span class="line">      this.partitionProvider &#x3D; partitionProvider;</span><br><span class="line">      this.taskEventPublisher &#x3D; taskEventPublisher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the server channel handlers.</span><br><span class="line">    *</span><br><span class="line">    * &lt;pre&gt;</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * |                        SERVER CHANNEL PIPELINE                    |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |    +----------+----------+ (3) write  +----------------------+    |</span><br><span class="line">    * |    | Queue of queues     +-----------&gt;| Message encoder      |    |</span><br><span class="line">    * |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">    * |              &#x2F;|\                                 \|&#x2F;              |</span><br><span class="line">    * |               | (2) enqueue                       |               |</span><br><span class="line">    * |    +----------+----------+                        |               |</span><br><span class="line">    * |    | Request handler     |                        |               |</span><br><span class="line">    * |    +----------+----------+                        |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |   +-----------+-----------+                       |               |</span><br><span class="line">    * |   | Message+Frame decoder |                       |               |</span><br><span class="line">    * |   +-----------+-----------+                       |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               | (1) client request               \|&#x2F;</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * &lt;&#x2F;pre&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return channel handlers</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ChannelHandler[] getServerChannelHandlers() &#123;</span><br><span class="line">   &#x2F;&#x2F;netty server 端的 ChannelHandler</span><br><span class="line">      PartitionRequestQueue queueOfPartitionQueues &#x3D; new PartitionRequestQueue();</span><br><span class="line">      PartitionRequestServerHandler serverHandler &#x3D; new PartitionRequestServerHandler(</span><br><span class="line">         partitionProvider,</span><br><span class="line">         taskEventPublisher,</span><br><span class="line">         queueOfPartitionQueues);</span><br><span class="line"></span><br><span class="line">      return new ChannelHandler[] &#123;</span><br><span class="line">         messageEncoder,</span><br><span class="line">         new NettyMessage.NettyMessageDecoder(),</span><br><span class="line">         serverHandler,</span><br><span class="line">         queueOfPartitionQueues</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the client channel handlers.</span><br><span class="line">    *</span><br><span class="line">    * &lt;pre&gt;</span><br><span class="line">    *     +-----------+----------+            +----------------------+</span><br><span class="line">    *     | Remote input channel |            | request client       |</span><br><span class="line">    *     +-----------+----------+            +-----------+----------+</span><br><span class="line">    *                 |                                   | (1) write</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |     CLIENT CHANNEL PIPELINE       |               |</span><br><span class="line">    * |               |                                  \|&#x2F;              |</span><br><span class="line">    * |    +----------+----------+            +----------------------+    |</span><br><span class="line">    * |    | Request handler     +            | Message encoder      |    |</span><br><span class="line">    * |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">    * |              &#x2F;|\                                 \|&#x2F;              |</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |    +----------+------------+                      |               |</span><br><span class="line">    * |    | Message+Frame decoder |                      |               |</span><br><span class="line">    * |    +----------+------------+                      |               |</span><br><span class="line">    * |              &#x2F;|\                                  |               |</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               | (3) server response              \|&#x2F; (2) client request</span><br><span class="line">    * +---------------+-----------------------------------+---------------+</span><br><span class="line">    * |               |                                   |               |</span><br><span class="line">    * |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">    * |                                                                   |</span><br><span class="line">    * |  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">    * +-------------------------------------------------------------------+</span><br><span class="line">    * &lt;&#x2F;pre&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return channel handlers</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ChannelHandler[] getClientChannelHandlers() &#123;</span><br><span class="line">   &#x2F;&#x2F;netty client 端的 ChannelHandler</span><br><span class="line">      return new ChannelHandler[] &#123;</span><br><span class="line">         messageEncoder,</span><br><span class="line">         new NettyMessage.NettyMessageDecoder(),</span><br><span class="line">         new CreditBasedPartitionRequestClientHandler()&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeSending.png" alt></p>
<p>首先，当 <code>NettyServer</code> 接收到 <code>PartitionRequest</code> 消息后，<code>PartitionRequestServerHandler</code> 会创建一个 <code>NetworkSequenceViewReader</code> 对象，请求创建 <code>ResultSubpartitionView</code>, 并将 <code>NetworkSequenceViewReader</code> 保存在 <code>PartitionRequestQueue</code> 中。<code>PartitionRequestQueue</code> 会持有所有请求消费数据的 <code>RemoteInputChannel</code> 的 ID 和 <code>NetworkSequenceViewReader</code> 之间的映射关系。</p>
<p>我们已经知道，<code>ResultSubpartitionView</code> 用来消费 <code>ResultSubpartition</code> 中的数据，并在 <code>ResultSubpartition</code> 中有数据可用时获得提醒；<code>NetworkSequenceViewReader</code> 则相当于对 <code>ResultSubpartition</code> 的一层包装，她会按顺序为读取的每一个 buffer 分配一个序列号，并且记录了接收数据的 <code>RemoteInputChannel</code> 的 ID。在使用 Credit-based Flow Control 的情况下，<code>NetworkSequenceViewReader</code> 的具体实现对应为 <code>CreditBasedSequenceNumberingViewReader</code>。 <code>CreditBasedSequenceNumberingViewReader</code> 同时还实现了 <code>BufferAvailabilityListener</code> 接口，因而可以作为 <code>PipelinedSubpartitionView</code> 的回调对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestServerHandler extends SimpleChannelInboundHandler&lt;NettyMessage&gt; &#123;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, NettyMessage msg) throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class&lt;?&gt; msgClazz &#x3D; msg.getClass();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			&#x2F;&#x2F; Intermediate result partition requests</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			if (msgClazz &#x3D;&#x3D; PartitionRequest.class) &#123;</span><br><span class="line">			&#x2F;&#x2F;Server 端接收到 client 发送的 PartitionRequest</span><br><span class="line">				PartitionRequest request &#x3D; (PartitionRequest) msg;</span><br><span class="line"></span><br><span class="line">				LOG.debug(&quot;Read channel on &#123;&#125;: &#123;&#125;.&quot;, ctx.channel().localAddress(), request);</span><br><span class="line"></span><br><span class="line">				try &#123;</span><br><span class="line">					NetworkSequenceViewReader reader;</span><br><span class="line">					reader &#x3D; new CreditBasedSequenceNumberingViewReader(</span><br><span class="line">						request.receiverId,</span><br><span class="line">						request.credit,</span><br><span class="line">						outboundQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 ResultPartitionProvider（实际上就是 ResultPartitionManager）创建 ResultSubpartitionView</span><br><span class="line">					&#x2F;&#x2F;在有可被消费的数据产生后，PartitionRequestQueue.notifyReaderNonEmpty 会被回调，进而在 netty channelPipeline 上触发一次 fireUserEventTriggered</span><br><span class="line">					reader.requestSubpartitionView(</span><br><span class="line">						partitionProvider,</span><br><span class="line">						request.partitionId,</span><br><span class="line">						request.queueIndex);</span><br><span class="line">&#x2F;&#x2F;通知 PartitionRequestQueue 创建了一个 NetworkSequenceViewReader</span><br><span class="line">					outboundQueue.notifyReaderCreated(reader);</span><br><span class="line">				&#125; catch (PartitionNotFoundException notFound) &#123;</span><br><span class="line">					respondWithError(ctx, notFound, request.receiverId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			&#x2F;&#x2F; Task events</span><br><span class="line">			&#x2F;&#x2F; ----------------------------------------------------------------</span><br><span class="line">			else if (msgClazz &#x3D;&#x3D; TaskEventRequest.class) &#123;</span><br><span class="line">				TaskEventRequest request &#x3D; (TaskEventRequest) msg;</span><br><span class="line"></span><br><span class="line">				if (!taskEventPublisher.publish(request.partitionId, request.event)) &#123;</span><br><span class="line">					respondWithError(ctx, new IllegalArgumentException(&quot;Task event receiver not found.&quot;), request.receiverId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; CancelPartitionRequest.class) &#123;</span><br><span class="line">				CancelPartitionRequest request &#x3D; (CancelPartitionRequest) msg;</span><br><span class="line"></span><br><span class="line">				outboundQueue.cancel(request.receiverId);</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; CloseRequest.class) &#123;</span><br><span class="line">				outboundQueue.close();</span><br><span class="line">			&#125; else if (msgClazz &#x3D;&#x3D; AddCredit.class) &#123;</span><br><span class="line">				AddCredit request &#x3D; (AddCredit) msg;</span><br><span class="line"></span><br><span class="line">				outboundQueue.addCredit(request.receiverId, request.credit);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				LOG.warn(&quot;Received unexpected client request: &#123;&#125;&quot;, msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			respondWithError(ctx, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>CreditBasedSequenceNumberingViewReader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListener, NetworkSequenceViewReader &#123;</span><br><span class="line"></span><br><span class="line">   private final Object requestLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应的 RemoteInputChannel 的 ID</span><br><span class="line">   private final InputChannelID receiverId;</span><br><span class="line"></span><br><span class="line">   private final PartitionRequestQueue requestQueue;</span><br><span class="line">&#x2F;&#x2F;消费 ResultSubpartition 的数据，并在 ResultSubpartition 有数据可用时获得通知</span><br><span class="line">   private volatile ResultSubpartitionView subpartitionView;</span><br><span class="line">&#x2F;&#x2F;numCreditsAvailable的值是消费端还能够容纳的buffer的数量，也就是允许生产端发送的buffer的数量</span><br><span class="line">   &#x2F;** The number of available buffers for holding data on the consumer side. *&#x2F;</span><br><span class="line">   private int numCreditsAvailable;</span><br><span class="line"> &#x2F;&#x2F;序列号，自增</span><br><span class="line">   private int sequenceNumber &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;创建一个 ResultSubpartitionView，用于读取数据，并在有数据可用时获得通知</span><br><span class="line">   CreditBasedSequenceNumberingViewReader(</span><br><span class="line">         InputChannelID receiverId,</span><br><span class="line">         int initialCredit,</span><br><span class="line">         PartitionRequestQueue requestQueue) &#123;</span><br><span class="line"></span><br><span class="line">      this.receiverId &#x3D; receiverId;</span><br><span class="line">      this.numCreditsAvailable &#x3D; initialCredit;</span><br><span class="line">      this.requestQueue &#x3D; requestQueue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void requestSubpartitionView(</span><br><span class="line">      ResultPartitionProvider partitionProvider,</span><br><span class="line">      ResultPartitionID resultPartitionId,</span><br><span class="line">      int subPartitionIndex) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      synchronized (requestLock) &#123;</span><br><span class="line">         if (subpartitionView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; This this call can trigger a notification we have to</span><br><span class="line">            &#x2F;&#x2F; schedule a separate task at the event loop that will</span><br><span class="line">            &#x2F;&#x2F; start consuming this. Otherwise the reference to the</span><br><span class="line">            &#x2F;&#x2F; view cannot be available in getNextBuffer().</span><br><span class="line">            this.subpartitionView &#x3D; partitionProvider.createSubpartitionView(</span><br><span class="line">               resultPartitionId,</span><br><span class="line">               subPartitionIndex,</span><br><span class="line">               this);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Subpartition already requested&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;当PartitionRequestQueue的WriteAndFlushNextMessageIfPossibleListener监听到写入数据时通过writeAndFlushNextMessageIfPossible调用getNextBuffer获取数据</span><br><span class="line">   @Override</span><br><span class="line">	public BufferAndAvailability getNextBuffer() throws IOException, InterruptedException &#123;</span><br><span class="line">		BufferAndBacklog next &#x3D; subpartitionView.getNextBuffer();</span><br><span class="line">		if (next !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;序列号</span><br><span class="line">			sequenceNumber++;</span><br><span class="line"></span><br><span class="line">			if (next.buffer().isBuffer() &amp;&amp; --numCreditsAvailable &lt; 0) &#123;</span><br><span class="line">			&#x2F;&#x2F;要发送一个buffer，对应的 numCreditsAvailable 要减 1</span><br><span class="line">				throw new IllegalStateException(&quot;no credit available&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return new BufferAndAvailability(</span><br><span class="line">				next.buffer(), isAvailable(next), next.buffersInBacklog());</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;是否还可以消费数据：</span><br><span class="line">	&#x2F;&#x2F; 1. ResultSubpartition 中有更多的数据</span><br><span class="line">	&#x2F;&#x2F; 2. credit &gt; 0 或者下一条数据是事件(事件不需要消耗credit)</span><br><span class="line">	private boolean isAvailable(BufferAndBacklog bufferAndBacklog) &#123;</span><br><span class="line">		&#x2F;&#x2F; BEWARE: this must be in sync with #isAvailable()!</span><br><span class="line">		if (numCreditsAvailable &gt; 0) &#123;</span><br><span class="line">			return bufferAndBacklog.isMoreAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return bufferAndBacklog.nextBufferIsEvent();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;在 ResultSubparition 中有数据时会回调该方法</span><br><span class="line">	@Override</span><br><span class="line">	public void notifyDataAvailable() &#123;</span><br><span class="line">	&#x2F;&#x2F;告知 PartitionRequestQueue 当前 ViewReader 有数据可读</span><br><span class="line">		requestQueue.notifyReaderNonEmpty(this);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>PartitionRequestQueue</code> 负责将 <code>ResultSubparition</code> 中的数据通过网络发送给 <code>RemoteInputChannel</code>。在 <code>PartitionRequestQueue</code> 中保存了所有的 <code>NetworkSequenceViewReader</code> 和 <code>InputChannelID</code> 之间的映射关系，以及一个 <code>ArrayDeque availableReaders</code> 队列。当一个 <code>NetworkSequenceViewReader</code> 中有数据可以被消费时，就会被加入到 <code>availableReaders</code> 队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestQueue extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(PartitionRequestQueue.class);</span><br><span class="line"></span><br><span class="line">   private final ChannelFutureListener writeListener &#x3D; new WriteAndFlushNextMessageIfPossibleListener();</span><br><span class="line"></span><br><span class="line">   &#x2F;** The readers which are already enqueued available for transferring data. *&#x2F;</span><br><span class="line">   private final ArrayDeque&lt;NetworkSequenceViewReader&gt; availableReaders &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** All the readers created for the consumers&#39; partition requests. *&#x2F;</span><br><span class="line">   private final ConcurrentMap&lt;InputChannelID, NetworkSequenceViewReader&gt; allReaders &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private boolean fatalError;</span><br><span class="line"></span><br><span class="line">   private ChannelHandlerContext ctx;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;添加新的 NetworkSequenceViewReader</span><br><span class="line">   public void notifyReaderCreated(final NetworkSequenceViewReader reader) &#123;</span><br><span class="line">		allReaders.put(reader.getReceiverId(), reader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通知 NetworkSequenceViewReader 有数据可读取</span><br><span class="line">   void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) &#123;</span><br><span class="line">      &#x2F;&#x2F; The notification might come from the same thread. For the initial writes this</span><br><span class="line">      &#x2F;&#x2F; might happen before the reader has set its reference to the view, because</span><br><span class="line">      &#x2F;&#x2F; creating the queue and the initial notification happen in the same method call.</span><br><span class="line">      &#x2F;&#x2F; This can be resolved by separating the creation of the view and allowing</span><br><span class="line">      &#x2F;&#x2F; notifications.</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; TODO This could potentially have a bad performance impact as in the</span><br><span class="line">      &#x2F;&#x2F; worst case (network consumes faster than the producer) each buffer</span><br><span class="line">      &#x2F;&#x2F; will trigger a separate event loop task being scheduled.</span><br><span class="line">      &#x2F;&#x2F;触发一次用户自定义事件</span><br><span class="line">      ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(reader));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;fireUserEventTriggered最终调用userEventTriggered</span><br><span class="line">   @Override</span><br><span class="line">	public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; The user event triggered event loop callback is used for thread-safe</span><br><span class="line">		&#x2F;&#x2F; hand over of reader queues and cancelled producers.</span><br><span class="line"></span><br><span class="line">		if (msg instanceof NetworkSequenceViewReader) &#123;</span><br><span class="line">		&#x2F;&#x2F;NetworkSequenceViewReader有数据可读取，加入队列中</span><br><span class="line">			enqueueAvailableReader((NetworkSequenceViewReader) msg);</span><br><span class="line">		&#125; else if (msg.getClass() &#x3D;&#x3D; InputChannelID.class) &#123;</span><br><span class="line">			&#x2F;&#x2F; Release partition view that get a cancel request.</span><br><span class="line">			&#x2F;&#x2F; 对应的 RemoteInputChannel 请求取消消费</span><br><span class="line">			InputChannelID toCancel &#x3D; (InputChannelID) msg;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; remove reader from queue of available readers</span><br><span class="line">			availableReaders.removeIf(reader -&gt; reader.getReceiverId().equals(toCancel));</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; remove reader from queue of all readers and release its resource</span><br><span class="line">			final NetworkSequenceViewReader toRelease &#x3D; allReaders.remove(toCancel);</span><br><span class="line">			if (toRelease !&#x3D; null) &#123;</span><br><span class="line">				releaseViewReader(toRelease);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctx.fireUserEventTriggered(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;加入队列</span><br><span class="line">	private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception &#123;</span><br><span class="line">		if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) &#123;</span><br><span class="line">		&#x2F;&#x2F;已经被注册到队列中，或者暂时没有 buffer 或没有 credit 可用</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Queue an available reader for consumption. If the queue is empty,</span><br><span class="line">		&#x2F;&#x2F; we try trigger the actual write. Otherwise this will be handled by</span><br><span class="line">		&#x2F;&#x2F; the writeAndFlushNextMessageIfPossible calls.</span><br><span class="line">		boolean triggerWrite &#x3D; availableReaders.isEmpty();</span><br><span class="line">		registerAvailableReader(reader);</span><br><span class="line"></span><br><span class="line">		if (triggerWrite) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果这是队列中第一个元素，调用 writeAndFlushNextMessageIfPossible 发送数据</span><br><span class="line">			writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>PartitionRequestQueue</code> 会监听 Netty Channel 的可写入状态，当 Channel 可写入时，就会从 <code>availableReaders</code> 队列中取出 <code>NetworkSequenceViewReader</code>，读取数据并写入网络。可写入状态是 Netty 通过水位线进行控制的，<code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException &#123;</span><br><span class="line">   if (fatalError || !channel.isWritable()) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果当前不可写入，则直接返回</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The logic here is very similar to the combined input gate and local</span><br><span class="line">   &#x2F;&#x2F; input channel logic. You can think of this class acting as the input</span><br><span class="line">   &#x2F;&#x2F; gate and the consumed views as the local input channels.</span><br><span class="line"></span><br><span class="line">   BufferAndAvailability next &#x3D; null;</span><br><span class="line">   try &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F;取出一个 reader</span><br><span class="line">         NetworkSequenceViewReader reader &#x3D; pollAvailableReader();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; No queue with available data. We allow this here, because</span><br><span class="line">         &#x2F;&#x2F; of the write callbacks that are executed after each write.</span><br><span class="line">         if (reader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         next &#x3D; reader.getNextBuffer();</span><br><span class="line">         if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;没有读到数据</span><br><span class="line">            if (!reader.isReleased()) &#123;</span><br><span class="line">            &#x2F;&#x2F;还没有释放当前 reader，继续处理下一个 数据</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;出错了</span><br><span class="line">            Throwable cause &#x3D; reader.getFailureCause();</span><br><span class="line">            if (cause !&#x3D; null) &#123;</span><br><span class="line">               ErrorResponse msg &#x3D; new ErrorResponse(</span><br><span class="line">                  new ProducerFailedException(cause),</span><br><span class="line">                  reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">               ctx.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 读到了数据</span><br><span class="line">            &#x2F;&#x2F; This channel was now removed from the available reader queue.</span><br><span class="line">            &#x2F;&#x2F; We re-add it into the queue if it is still available</span><br><span class="line">            if (next.moreAvailable()) &#123;</span><br><span class="line">            &#x2F;&#x2F;这个 reader 还可以读到更多的数据，继续加入队列</span><br><span class="line">               registerAvailableReader(reader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BufferResponse msg &#x3D; new BufferResponse(</span><br><span class="line">               next.buffer(),</span><br><span class="line">               reader.getSequenceNumber(),</span><br><span class="line">               reader.getReceiverId(),</span><br><span class="line">               next.buffersInBacklog());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Write and flush and wait until this is done before</span><br><span class="line">            &#x2F;&#x2F; trying to continue with the next buffer.</span><br><span class="line">            &#x2F;&#x2F; 向 client 发送数据，发送成功之后通过 writeListener 的回调触发下一次发送</span><br><span class="line">            channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (next !&#x3D; null) &#123;</span><br><span class="line">         next.buffer().recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throw new IOException(t.getMessage(), t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继续加入队列</span><br><span class="line">private void registerAvailableReader(NetworkSequenceViewReader reader) &#123;</span><br><span class="line">		availableReaders.add(reader);</span><br><span class="line">		reader.setRegisteredAsAvailable(true);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;writeListener类</span><br><span class="line">private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (future.isSuccess()) &#123;</span><br><span class="line">				&#x2F;&#x2F;发送成功，再次尝试写入</span><br><span class="line">					writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">				&#125; else if (future.cause() !&#x3D; null) &#123;</span><br><span class="line">					handleException(future.channel(), future.cause());</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					handleException(future.channel(), new IllegalStateException(&quot;Sending cancelled by user.&quot;));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				handleException(future.channel(), t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在 Credit-based Flow Control 算法中，每发送一个 buffer 就会消耗一点 credit，在消费端有空闲 buffer 可用时会发送 <code>AddCrdit</code> 消息。在前面的PartitionRequestServerHandler类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PartitionRequestServerHandler extends SimpleChannelInboundHandler&lt;NettyMessage&gt; &#123;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, NettyMessage msg) throws Exception &#123;</span><br><span class="line">		...</span><br><span class="line">		 else if (msgClazz &#x3D;&#x3D; AddCredit.class) &#123;</span><br><span class="line">		 &#x2F;&#x2F;增加 credit</span><br><span class="line">			AddCredit request &#x3D; (AddCredit) msg;</span><br><span class="line">			outboundQueue.addCredit(request.receiverId, request.credit);</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PartitionRequestQueue类的addCredit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void addCredit(InputChannelID receiverId, int credit) throws Exception &#123;</span><br><span class="line">   if (fatalError) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   NetworkSequenceViewReader reader &#x3D; allReaders.get(receiverId);</span><br><span class="line">   if (reader !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;增加 credit</span><br><span class="line">      reader.addCredit(credit);</span><br><span class="line">&#x2F;&#x2F;因为增加了credit，可能可以继续处理数据，因此把 reader 加入队列</span><br><span class="line">      enqueueAvailableReader(reader);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;No reader for receiverId &#x3D; &quot; + receiverId + &quot; exists.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/07/Flink%E7%9A%84Task%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/bpSourceCodeReceiving.png" alt></p>
<p>而消费端即 <code>NettyClient</code>的入口为CreditBasedPartitionRequestClientHandler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdapter implements NetworkClientHandler &#123;</span><br><span class="line"></span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(CreditBasedPartitionRequestClientHandler.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;** Channels, which already requested partitions from the producers. *&#x2F;</span><br><span class="line">   private final ConcurrentMap&lt;InputChannelID, RemoteInputChannel&gt; inputChannels &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;** Channels, which will notify the producers about unannounced credit. *&#x2F;</span><br><span class="line">   private final ArrayDeque&lt;RemoteInputChannel&gt; inputChannelsWithCredit &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private final AtomicReference&lt;Throwable&gt; channelError &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private final ChannelFutureListener writeListener &#x3D; new WriteAndFlushNextMessageIfPossibleListener();</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F;从netty channel中接收到数据</span><br><span class="line">		try &#123;</span><br><span class="line">		&#x2F;&#x2F;解析消息</span><br><span class="line">			decodeMsg(msg);</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void decodeMsg(Object msg) throws Throwable &#123;</span><br><span class="line">		final Class&lt;?&gt; msgClazz &#x3D; msg.getClass();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; ---- Buffer --------------------------------------------------------</span><br><span class="line">		if (msgClazz &#x3D;&#x3D; NettyMessage.BufferResponse.class) &#123;</span><br><span class="line">		&#x2F;&#x2F;正常的数据</span><br><span class="line">			NettyMessage.BufferResponse bufferOrEvent &#x3D; (NettyMessage.BufferResponse) msg;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据 ID 定位到对应的 RemoteInputChannel</span><br><span class="line">			RemoteInputChannel inputChannel &#x3D; inputChannels.get(bufferOrEvent.receiverId);</span><br><span class="line">			if (inputChannel &#x3D;&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果没有对应的 RemoteInputChannel</span><br><span class="line">				bufferOrEvent.releaseBuffer();</span><br><span class="line">&#x2F;&#x2F;取消对给定 receiverId 的订阅</span><br><span class="line">				cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line"></span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">&#x2F;&#x2F;解析消息，是buffer还是event</span><br><span class="line">			decodeBufferOrEvent(inputChannel, bufferOrEvent);</span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private void decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			ByteBuf nettyBuffer &#x3D; bufferOrEvent.getNettyBuffer();</span><br><span class="line">			final int receivedSize &#x3D; nettyBuffer.readableBytes();</span><br><span class="line">			if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">				&#x2F;&#x2F; ---- Buffer ------------------------------------------------</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Early return for empty buffers. Otherwise Netty&#39;s readBytes() throws an</span><br><span class="line">				&#x2F;&#x2F; IndexOutOfBoundsException.</span><br><span class="line">				if (receivedSize &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">            &#x2F;&#x2F;从对应的 RemoteInputChannel 中请求一个 Buffer</span><br><span class="line">				Buffer buffer &#x3D; inputChannel.requestBuffer();</span><br><span class="line">				if (buffer !&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;将接收的数据写入buffer</span><br><span class="line">					nettyBuffer.readBytes(buffer.asByteBuf(), receivedSize);</span><br><span class="line">					buffer.setCompressed(bufferOrEvent.isCompressed);</span><br><span class="line">&#x2F;&#x2F;通知对应的channel，backlog是生产者那边堆积的buffer数量</span><br><span class="line">					inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">				&#125; else if (inputChannel.isReleased()) &#123;</span><br><span class="line">					cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;No buffer available in credit-based input channel.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F; ---- Event -------------------------------------------------</span><br><span class="line">				&#x2F;&#x2F; TODO We can just keep the serialized data in the Netty buffer and release it later at the reader</span><br><span class="line">				byte[] byteArray &#x3D; new byte[receivedSize];</span><br><span class="line">				nettyBuffer.readBytes(byteArray);</span><br><span class="line"></span><br><span class="line">				MemorySegment memSeg &#x3D; MemorySegmentFactory.wrap(byteArray);</span><br><span class="line">				&#x2F;&#x2F;是一个事件，不需要从 RemoteInputChannel 中申请 buffer</span><br><span class="line">				Buffer buffer &#x3D; new NetworkBuffer(memSeg, FreeingBufferRecycler.INSTANCE, false, receivedSize);</span><br><span class="line">&#x2F;&#x2F;通知对应的channel，backlog是生产者那边堆积的buffer数量</span><br><span class="line">				inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			bufferOrEvent.releaseBuffer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>CreditBasedPartitionRequestClientHandler</code> 从网络中读取数据后交给 <code>RemoteInputChannel</code>， <code>RemoteInputChannel</code> 会将接收到的加入队列中，并根据生产端的堆积申请 floating buffer：</p>
<p>RemoteInputChannel类onBuffer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收到远程 ResultSubpartition 发送的 Buffer</span><br><span class="line">public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException &#123;</span><br><span class="line">   boolean recycleBuffer &#x3D; true;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line"></span><br><span class="line">      final boolean wasEmpty;</span><br><span class="line">      synchronized (receivedBuffers) &#123;</span><br><span class="line">         &#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">         &#x2F;&#x2F; after releaseAllResources() released all buffers from receivedBuffers</span><br><span class="line">         &#x2F;&#x2F; (see above for details).</span><br><span class="line">         if (isReleased.get()) &#123;</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;序号需要匹配</span><br><span class="line">         if (expectedSequenceNumber !&#x3D; sequenceNumber) &#123;</span><br><span class="line">            onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber));</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">&#x2F;&#x2F;加入 receivedBuffers 队列中</span><br><span class="line">         wasEmpty &#x3D; receivedBuffers.isEmpty();</span><br><span class="line">         receivedBuffers.add(buffer);</span><br><span class="line">         recycleBuffer &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ++expectedSequenceNumber;</span><br><span class="line"></span><br><span class="line">      if (wasEmpty) &#123;</span><br><span class="line">      &#x2F;&#x2F;通知 InputGate，当前 channel 有新数据</span><br><span class="line">         notifyChannelNonEmpty();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (backlog &gt;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F;根据客户端的积压申请float buffer</span><br><span class="line">         onSenderBacklog(backlog);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      if (recycleBuffer) &#123;</span><br><span class="line">         buffer.recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;backlog 是发送端的堆积 的 buffer 数量，</span><br><span class="line">	&#x2F;&#x2F;如果 bufferQueue 中 buffer 的数量不足，就去须从 LocalBufferPool 中请求 floating buffer</span><br><span class="line">	&#x2F;&#x2F;在请求了新的 buffer 后，通知生产者有 credit 可用</span><br><span class="line">void onSenderBacklog(int backlog) throws IOException &#123;</span><br><span class="line">		int numRequestedBuffers &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		synchronized (bufferQueue) &#123;</span><br><span class="line">			&#x2F;&#x2F; Similar to notifyBufferAvailable(), make sure that we never add a buffer</span><br><span class="line">			&#x2F;&#x2F; after releaseAllResources() released all buffers (see above for details).</span><br><span class="line">			if (isReleased.get()) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要的 buffer 数量是 backlog + initialCredit, backlog 是生产者当前的积压</span><br><span class="line">			numRequiredBuffers &#x3D; backlog + initialCredit;</span><br><span class="line">			while (bufferQueue.getAvailableBufferSize() &lt; numRequiredBuffers &amp;&amp; !isWaitingForFloatingBuffers) &#123;</span><br><span class="line">			&#x2F;&#x2F;不停地请求新的 floating buffer</span><br><span class="line">				Buffer buffer &#x3D; inputGate.getBufferPool().requestBuffer();</span><br><span class="line">				if (buffer !&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;从 buffer poll 中请求到 buffer</span><br><span class="line">					bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line">					numRequestedBuffers++;</span><br><span class="line">				&#125; else if (inputGate.getBufferProvider().addBufferListener(this)) &#123;</span><br><span class="line">				&#x2F;&#x2F; buffer pool 没有 buffer 了，加一个监听，当 LocalBufferPool 中有新的 buffer 时会回调 notifyBufferAvailable</span><br><span class="line">					&#x2F;&#x2F; If the channel has not got enough buffers, register it as listener to wait for more floating buffers.</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (numRequestedBuffers &gt; 0 &amp;&amp; unannouncedCredit.getAndAdd(numRequestedBuffers) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		&#x2F;&#x2F;请求了新的floating buffer，要更新 credit</span><br><span class="line">			notifyCreditAvailable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"> private void notifyCreditAvailable() &#123;</span><br><span class="line">		checkState(partitionRequestClient !&#x3D; null, &quot;Tried to send task event to producer before requesting a queue.&quot;);</span><br><span class="line">&#x2F;&#x2F;通知当前 channel 有新的 credit</span><br><span class="line">		partitionRequestClient.notifyCreditAvailable(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;LocalBufferPool 的recycle回收buffer并通知有 buffer 可用</span><br><span class="line">@Override</span><br><span class="line">	public NotificationResult notifyBufferAvailable(Buffer buffer) &#123;</span><br><span class="line">		NotificationResult notificationResult &#x3D; NotificationResult.BUFFER_NOT_USED;</span><br><span class="line">		try &#123;</span><br><span class="line">			synchronized (bufferQueue) &#123;</span><br><span class="line">				checkState(isWaitingForFloatingBuffers,</span><br><span class="line">					&quot;This channel should be waiting for floating buffers.&quot;);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Important: make sure that we never add a buffer after releaseAllResources()</span><br><span class="line">				&#x2F;&#x2F; released all buffers. Following scenarios exist:</span><br><span class="line">				&#x2F;&#x2F; 1) releaseAllResources() already released buffers inside bufferQueue</span><br><span class="line">				&#x2F;&#x2F; -&gt; then isReleased is set correctly</span><br><span class="line">				&#x2F;&#x2F; 2) releaseAllResources() did not yet release buffers from bufferQueue</span><br><span class="line">				&#x2F;&#x2F; -&gt; we may or may not have set isReleased yet but will always wait for the</span><br><span class="line">				&#x2F;&#x2F; lock on bufferQueue to release buffers</span><br><span class="line">				if (isReleased.get() || bufferQueue.getAvailableBufferSize() &gt;&#x3D; numRequiredBuffers) &#123;</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; false;</span><br><span class="line">					return notificationResult;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加floating buffer</span><br><span class="line">				bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line"></span><br><span class="line">				if (bufferQueue.getAvailableBufferSize() &#x3D;&#x3D; numRequiredBuffers) &#123;</span><br><span class="line">				&#x2F;&#x2F;bufferQueue中有足够多的 buffer 了</span><br><span class="line">					isWaitingForFloatingBuffers &#x3D; false;</span><br><span class="line">					notificationResult &#x3D; NotificationResult.BUFFER_USED_NO_NEED_MORE;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F;bufferQueue 中 buffer 仍然不足</span><br><span class="line">					notificationResult &#x3D; NotificationResult.BUFFER_USED_NEED_MORE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (unannouncedCredit.getAndAdd(1) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				notifyCreditAvailable();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Throwable t) &#123;</span><br><span class="line">			setError(t);</span><br><span class="line">		&#125;</span><br><span class="line">		return notificationResult;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 <code>RemoteInputChannel</code> 申请到新的 buffer，就需要通知生产者更新 credit，这需要发送一条 <code>AddCredit</code>消息：</p>
<p>NettyPartitionRequestClient.notifyCreditAvailable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void notifyCreditAvailable(RemoteInputChannel inputChannel) &#123;</span><br><span class="line">   clientHandler.notifyCreditAvailable(inputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreditBasedPartitionRequestClientHandler.notifyCreditAvailable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public void notifyCreditAvailable(final RemoteInputChannel inputChannel) &#123;</span><br><span class="line">&#x2F;&#x2F;有新的credit触发一次自定义事件</span><br><span class="line">   ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(inputChannel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;触发自定义事件</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">		if (msg instanceof RemoteInputChannel) &#123;</span><br><span class="line">		&#x2F;&#x2F;有新的credit会触发</span><br><span class="line">			boolean triggerWrite &#x3D; inputChannelsWithCredit.isEmpty();</span><br><span class="line">         &#x2F;&#x2F;加入到队列中</span><br><span class="line">			inputChannelsWithCredit.add((RemoteInputChannel) msg);</span><br><span class="line"></span><br><span class="line">			if (triggerWrite) &#123;</span><br><span class="line">				writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctx.fireUserEventTriggered(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private void writeAndFlushNextMessageIfPossible(Channel channel) &#123;</span><br><span class="line">		if (channelError.get() !&#x3D; null || !channel.isWritable()) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">&#x2F;&#x2F;从队列中取出 RemoteInputChannel， 发送消息</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			RemoteInputChannel inputChannel &#x3D; inputChannelsWithCredit.poll();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; The input channel may be null because of the write callbacks</span><br><span class="line">			&#x2F;&#x2F; that are executed after each write.</span><br><span class="line">			if (inputChannel &#x3D;&#x3D; null) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;It is no need to notify credit for the released channel.</span><br><span class="line">			if (!inputChannel.isReleased()) &#123;</span><br><span class="line">				AddCredit msg &#x3D; new AddCredit(</span><br><span class="line">				&#x2F;&#x2F;发送 AddCredit 的消息</span><br><span class="line">					inputChannel.getPartitionId(),</span><br><span class="line">					inputChannel.getAndResetUnannouncedCredit(),</span><br><span class="line">					inputChannel.getInputChannelId());</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F; Write and flush and wait until this is done before</span><br><span class="line">				&#x2F;&#x2F; trying to continue with the next input channel.</span><br><span class="line">				&#x2F;&#x2F;发送成功之后通过writeListener监听继续发送</span><br><span class="line">				channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private class WriteAndFlushNextMessageIfPossibleListener implements ChannelFutureListener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (future.isSuccess()) &#123;</span><br><span class="line">					writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">				&#125; else if (future.cause() !&#x3D; null) &#123;</span><br><span class="line">					notifyAllChannelsOfErrorAndClose(future.cause());</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					notifyAllChannelsOfErrorAndClose(new IllegalStateException(&quot;Sending cancelled by user.&quot;));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Throwable t) &#123;</span><br><span class="line">				notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Credit-based Flow Control 的具体机制为：</p>
<ul>
<li>接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一点 credit）；</li>
<li>当发送端获得了 X 点 Credit，表明它可以向网络中发送 X 个 buffer；当接收端分配了 X 点 Credit 给发送端，表明它有 X 个空闲的 buffer 可以接收数据；</li>
<li>只有在 Credit &gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少一点</li>
<li>由于 <code>CheckpointBarrier</code>，<code>EndOfPartitionEvent</code> 等事件可以被立即处理，因而事件可以立即发送，无需使用 Credit</li>
<li>当发送端发送 buffer 的时候，它同样把当前堆积的 buffer 数量（backlog size）告知接收端；接收端根据发送端堆积的数量来申请 floating buffer</li>
</ul>
<p>这种流量控制机制可以有效地改善网络的利用率，不会因为 buffer 长时间停留在网络链路中进而导致整个所有的 Task 都无法继续处理数据，也无法进行 Checkpoint 操作。但是它的一个潜在的缺点是增加了上下游之间的通信成本（需要发送 credit 和 backlog 信息）</p>
<p>在上面几节，我们已经详细地分析了 Task 之间的数据交换机制和它们的实现原理，理解这这些实际上就已经理解了 Flink 的“反压”机制。</p>
<p>所谓“反压”，就是指在流处理系统中，下游任务的处理速度跟不上上游任务的数据生产速度。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。反压机制就是指系统能够自己检测到被阻塞的算子，然后系统自适应地降低源头或者上游的发送速率。在 Flink 中，应对“反压”是一种极其自然的方式，因为 Flink 中的数据传输机制已经提供了应对反压的措施。</p>
<p>在本地数据交换的情况下，两个 Task 实际上是同一个 JVM 中的两个线程，Task1 产生的 Buffer 直接被 Task2 使用，当 Task2 处理完之后这个 Buffer 就会被回收到本地缓冲池中。一旦 Task2 的处理速度比 Task2 产生 Buffer 的速度慢，那么缓冲池中 Buffer 渐渐地就会被耗尽，Task1 无法申请到新的 Buffer 自然就会阻塞，因而会导致 Task1 的降速。</p>
<p>在网络数据交换的情况下，如果下游 Task 的处理速度较慢，下游 Task 的接收缓冲池逐渐耗尽后就无法从网络中读取新的数据，这回导致上游 Task 无法将缓冲池中的 Buffer 发送到网络中，因此上游 Task 的缓冲池也会被耗尽，进而导致上游任务的降速。为了解决网络连接阻塞导致所有 Task 都无法处理数据的情况，Flink 还引入了 Credit-based Flow Control 算法，在上游生产者下游消费只之间通过“信用点”来协调发送速度，确保网络连接永远不会被阻塞。同时，Flink 的网络栈基于 Netty 构建，通过 Netty 的水位线机制也可以控制发送端的发送速率。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/06/Flink%E7%9A%84Task%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="next" title="Flink的Task的调度过程及生命周期">
                <i class="fa fa-chevron-left"></i> Flink的Task的调度过程及生命周期
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/15/Flink%E7%9A%84checkpoint%E7%94%9F%E6%88%90/" rel="prev" title="Flink的checkpoint生成">
                Flink的checkpoint生成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HH KKs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HH KKs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
